{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_ffrt/build.rs", "line": 21, "evidence": "let root = PathBuf::from(env::var_os(\"                  \").unwrap());", "confidence": 0.65, "severity": "medium", "gid": 1, "verify": "验证环境变量是否存在且有效，文件路径是否存在且可访问，路径连接和转换操作是否成功", "preconditions": "环境变量未设置或路径不存在/无效", "trigger_path": "调用路径推导：main() -> env::var_os().unwrap() / fs::canonicalize().unwrap() / env::join_paths().unwrap().to_str().unwrap()。数据流：1) 环境变量 CARGO_MANIFEST_DIR 通过 env::var_os() 获取；2) 文件路径通过 root.join() 构造；3) 路径连接通过 env::join_paths() 处理。关键调用点：所有 unwrap() 调用点均未进行错误处理。", "consequences": "程序 panic 导致构建失败", "suggestions": "使用 expect() 提供有意义的错误信息，或使用 Result 进行适当的错误处理", "has_risk": true, "verification_notes": "分析结论正确，前置条件合理（环境变量和路径确实可能不存在），触发路径清晰（直接调用链），后果评估准确（unwrap会导致panic），建议合适（推荐使用expect或Result处理）"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_ffrt/build.rs", "line": 22, "evidence": "let library_dir = fs::canonicalize(root.join(\"   \")).unwrap();", "confidence": 0.65, "severity": "medium", "gid": 2, "verify": "验证环境变量是否存在且有效，文件路径是否存在且可访问，路径连接和转换操作是否成功", "preconditions": "环境变量未设置或路径不存在/无效", "trigger_path": "调用路径推导：main() -> env::var_os().unwrap() / fs::canonicalize().unwrap() / env::join_paths().unwrap().to_str().unwrap()。数据流：1) 环境变量 CARGO_MANIFEST_DIR 通过 env::var_os() 获取；2) 文件路径通过 root.join() 构造；3) 路径连接通过 env::join_paths() 处理。关键调用点：所有 unwrap() 调用点均未进行错误处理。", "consequences": "程序 panic 导致构建失败", "suggestions": "使用 expect() 提供有意义的错误信息，或使用 Result 进行适当的错误处理", "has_risk": true, "verification_notes": "分析结论正确，前置条件合理（环境变量和路径确实可能不存在），触发路径清晰（直接调用链），后果评估准确（unwrap会导致panic），建议合适（推荐使用expect或Result处理）"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_ffrt/build.rs", "line": 27, "evidence": "env::join_paths([library_dir]).unwrap().to_str().unwrap()", "confidence": 0.65, "severity": "medium", "gid": 3, "verify": "验证环境变量是否存在且有效，文件路径是否存在且可访问，路径连接和转换操作是否成功", "preconditions": "环境变量未设置或路径不存在/无效", "trigger_path": "调用路径推导：main() -> env::var_os().unwrap() / fs::canonicalize().unwrap() / env::join_paths().unwrap().to_str().unwrap()。数据流：1) 环境变量 CARGO_MANIFEST_DIR 通过 env::var_os() 获取；2) 文件路径通过 root.join() 构造；3) 路径连接通过 env::join_paths() 处理。关键调用点：所有 unwrap() 调用点均未进行错误处理。", "consequences": "程序 panic 导致构建失败", "suggestions": "使用 expect() 提供有意义的错误信息，或使用 Result 进行适当的错误处理", "has_risk": true, "verification_notes": "分析结论正确，前置条件合理（环境变量和路径确实可能不存在），触发路径清晰（直接调用链），后果评估准确（unwrap会导致panic），建议合适（推荐使用expect或Result处理）"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/executor/async_pool.rs", "line": 477, "evidence": "let _ = set_current_affinity(cpu_id);", "confidence": 0.55, "severity": "low", "gid": 280, "verify": "验证忽略函数返回值set_current_affinity是否会导致问题", "has_risk": true, "preconditions": "系统调用失败（如无效的CPU ID或权限不足）或CPU核心数动态变化导致worker_id % cpu_core_num产生无效CPU ID", "trigger_path": "调用路径推导：async_pool.rs中的线程创建(builder.spawn) -> set_current_affinity(cpu_id)。数据流：worker_id -> cpu_id(通过worker_id % cpu_core_num计算) -> set_current_affinity参数。关键调用点：builder.spawn未检查set_current_affinity的返回值。", "consequences": "线程亲和性设置失败被静默忽略，可能导致线程调度效率降低", "suggestions": "处理set_current_affinity返回值，至少记录错误日志；添加CPU ID有效性检查", "verification_notes": "分析结论正确，前置条件合理（存在系统调用失败或CPU核心数动态变化风险），触发路径清晰（builder.spawn未检查set_current_affinity返回值），后果评估准确（线程亲和性设置失败被静默忽略可能导致调度效率降低），建议合适（应处理返回值和添加有效性检查）"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 77, "evidence": "let mut shared = self.inner.shared.lock().unwrap();", "confidence": 0.65, "severity": "medium", "has_risk": true, "preconditions": "线程被中断或Mutex锁被破坏", "trigger_path": "调用路径推导：BlockPoolSpawner::new() -> Inner结构体初始化 -> Mutex::new()。数据流：所有对共享数据的访问都通过Mutex锁保护，但在获取锁时直接使用unwrap()。关键调用点：shutdown(), create_permanent_threads(), spawn(), run()等方法中直接调用lock().unwrap()，未处理可能的锁获取失败情况。", "consequences": "如果锁操作失败会导致线程panic，可能引发线程池崩溃或任务丢失", "suggestions": "使用lock().expect()提供更有意义的错误信息，或者实现锁获取失败时的恢复逻辑", "gid": 291, "verification_notes": "分析结论正确：\n1. 前置条件合理：代码中确实存在线程被中断或Mutex锁被破坏的风险\n2. 触发路径成立：代码中所有锁操作都直接使用unwrap()，分布在shutdown、create_permanent_threads、spawn、run等关键方法中\n3. 后果评估准确：锁操作失败会导致线程panic，可能引发线程池崩溃或任务丢失\n4. 建议合适：使用expect()提供更有意义的错误信息或实现恢复逻辑是合理的改进方案"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 86, "evidence": "let shutdown_shared = self.inner.shutdown_shared.lock().unwrap();", "confidence": 0.65, "severity": "medium", "has_risk": true, "preconditions": "线程被中断或Mutex锁被破坏", "trigger_path": "调用路径推导：BlockPoolSpawner::new() -> Inner结构体初始化 -> Mutex::new()。数据流：所有对共享数据的访问都通过Mutex锁保护，但在获取锁时直接使用unwrap()。关键调用点：shutdown(), create_permanent_threads(), spawn(), run()等方法中直接调用lock().unwrap()，未处理可能的锁获取失败情况。", "consequences": "如果锁操作失败会导致线程panic，可能引发线程池崩溃或任务丢失", "suggestions": "使用lock().expect()提供更有意义的错误信息，或者实现锁获取失败时的恢复逻辑", "gid": 292, "verification_notes": "分析结论正确：\n1. 前置条件合理：代码中确实存在线程被中断或Mutex锁被破坏的风险\n2. 触发路径成立：代码中所有锁操作都直接使用unwrap()，分布在shutdown、create_permanent_threads、spawn、run等关键方法中\n3. 后果评估准确：锁操作失败会导致线程panic，可能引发线程池崩溃或任务丢失\n4. 建议合适：使用expect()提供更有意义的错误信息或实现恢复逻辑是合理的改进方案"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 172, "evidence": "let mut shared = self.inner.shared.lock().unwrap();", "confidence": 0.65, "severity": "medium", "has_risk": true, "preconditions": "线程被中断或Mutex锁被破坏", "trigger_path": "调用路径推导：BlockPoolSpawner::new() -> Inner结构体初始化 -> Mutex::new()。数据流：所有对共享数据的访问都通过Mutex锁保护，但在获取锁时直接使用unwrap()。关键调用点：shutdown(), create_permanent_threads(), spawn(), run()等方法中直接调用lock().unwrap()，未处理可能的锁获取失败情况。", "consequences": "如果锁操作失败会导致线程panic，可能引发线程池崩溃或任务丢失", "suggestions": "使用lock().expect()提供更有意义的错误信息，或者实现锁获取失败时的恢复逻辑", "gid": 294, "verification_notes": "分析结论正确：\n1. 前置条件合理：代码中确实存在线程被中断或Mutex锁被破坏的风险\n2. 触发路径成立：代码中所有锁操作都直接使用unwrap()，分布在shutdown、create_permanent_threads、spawn、run等关键方法中\n3. 后果评估准确：锁操作失败会导致线程panic，可能引发线程池崩溃或任务丢失\n4. 建议合适：使用expect()提供更有意义的错误信息或实现恢复逻辑是合理的改进方案"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 208, "evidence": "let mut shared = self.inner.shared.lock().unwrap();", "confidence": 0.65, "severity": "medium", "has_risk": true, "preconditions": "线程被中断或Mutex锁被破坏", "trigger_path": "调用路径推导：BlockPoolSpawner::new() -> Inner结构体初始化 -> Mutex::new()。数据流：所有对共享数据的访问都通过Mutex锁保护，但在获取锁时直接使用unwrap()。关键调用点：shutdown(), create_permanent_threads(), spawn(), run()等方法中直接调用lock().unwrap()，未处理可能的锁获取失败情况。", "consequences": "如果锁操作失败会导致线程panic，可能引发线程池崩溃或任务丢失", "suggestions": "使用lock().expect()提供更有意义的错误信息，或者实现锁获取失败时的恢复逻辑", "gid": 295, "verification_notes": "分析结论正确：\n1. 前置条件合理：代码中确实存在线程被中断或Mutex锁被破坏的风险\n2. 触发路径成立：代码中所有锁操作都直接使用unwrap()，分布在shutdown、create_permanent_threads、spawn、run等关键方法中\n3. 后果评估准确：锁操作失败会导致线程panic，可能引发线程池崩溃或任务丢失\n4. 建议合适：使用expect()提供更有意义的错误信息或实现恢复逻辑是合理的改进方案"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 458, "evidence": "blocking_pool.inner.shared.lock().unwrap().shutdown = true;", "confidence": 0.55, "severity": "low", "has_risk": true, "preconditions": "线程被中断或Mutex锁被破坏", "trigger_path": "调用路径推导：BlockPoolSpawner::new() -> Inner结构体初始化 -> Mutex::new()。数据流：所有对共享数据的访问都通过Mutex锁保护，但在获取锁时直接使用unwrap()。关键调用点：shutdown(), create_permanent_threads(), spawn(), run()等方法中直接调用lock().unwrap()，未处理可能的锁获取失败情况。", "consequences": "如果锁操作失败会导致线程panic，可能引发线程池崩溃或任务丢失", "suggestions": "使用lock().expect()提供更有意义的错误信息，或者实现锁获取失败时的恢复逻辑", "gid": 298, "verification_notes": "分析结论正确：\n1. 前置条件合理：代码中确实存在线程被中断或Mutex锁被破坏的风险\n2. 触发路径成立：代码中所有锁操作都直接使用unwrap()，分布在shutdown、create_permanent_threads、spawn、run等关键方法中\n3. 后果评估准确：锁操作失败会导致线程panic，可能引发线程池崩溃或任务丢失\n4. 建议合适：使用expect()提供更有意义的错误信息或实现恢复逻辑是合理的改进方案"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 465, "evidence": "*spawner_inner_clone.shutdown_shared.lock().unwrap() = true;", "confidence": 0.55, "severity": "low", "has_risk": true, "preconditions": "线程被中断或Mutex锁被破坏", "trigger_path": "调用路径推导：BlockPoolSpawner::new() -> Inner结构体初始化 -> Mutex::new()。数据流：所有对共享数据的访问都通过Mutex锁保护，但在获取锁时直接使用unwrap()。关键调用点：shutdown(), create_permanent_threads(), spawn(), run()等方法中直接调用lock().unwrap()，未处理可能的锁获取失败情况。", "consequences": "如果锁操作失败会导致线程panic，可能引发线程池崩溃或任务丢失", "suggestions": "使用lock().expect()提供更有意义的错误信息，或者实现锁获取失败时的恢复逻辑", "gid": 299, "verification_notes": "分析结论正确：\n1. 前置条件合理：代码中确实存在线程被中断或Mutex锁被破坏的风险\n2. 触发路径成立：代码中所有锁操作都直接使用unwrap()，分布在shutdown、create_permanent_threads、spawn、run等关键方法中\n3. 后果评估准确：锁操作失败会导致线程panic，可能引发线程池崩溃或任务丢失\n4. 建议合适：使用expect()提供更有意义的错误信息或实现恢复逻辑是合理的改进方案"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 477, "evidence": "blocking_pool.inner.shared.lock().unwrap().shutdown = true;", "confidence": 0.55, "severity": "low", "has_risk": true, "preconditions": "线程被中断或Mutex锁被破坏", "trigger_path": "调用路径推导：BlockPoolSpawner::new() -> Inner结构体初始化 -> Mutex::new()。数据流：所有对共享数据的访问都通过Mutex锁保护，但在获取锁时直接使用unwrap()。关键调用点：shutdown(), create_permanent_threads(), spawn(), run()等方法中直接调用lock().unwrap()，未处理可能的锁获取失败情况。", "consequences": "如果锁操作失败会导致线程panic，可能引发线程池崩溃或任务丢失", "suggestions": "使用lock().expect()提供更有意义的错误信息，或者实现锁获取失败时的恢复逻辑", "gid": 300, "verification_notes": "分析结论正确：\n1. 前置条件合理：代码中确实存在线程被中断或Mutex锁被破坏的风险\n2. 触发路径成立：代码中所有锁操作都直接使用unwrap()，分布在shutdown、create_permanent_threads、spawn、run等关键方法中\n3. 后果评估准确：锁操作失败会导致线程panic，可能引发线程池崩溃或任务丢失\n4. 建议合适：使用expect()提供更有意义的错误信息或实现恢复逻辑是合理的改进方案"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 495, "evidence": "assert_eq!(blocking_pool.inner.shared.lock().unwrap().worker_id, 4);", "confidence": 0.55, "severity": "low", "has_risk": true, "preconditions": "线程被中断或Mutex锁被破坏", "trigger_path": "调用路径推导：BlockPoolSpawner::new() -> Inner结构体初始化 -> Mutex::new()。数据流：所有对共享数据的访问都通过Mutex锁保护，但在获取锁时直接使用unwrap()。关键调用点：shutdown(), create_permanent_threads(), spawn(), run()等方法中直接调用lock().unwrap()，未处理可能的锁获取失败情况。", "consequences": "如果锁操作失败会导致线程panic，可能引发线程池崩溃或任务丢失", "suggestions": "使用lock().expect()提供更有意义的错误信息，或者实现锁获取失败时的恢复逻辑", "gid": 301, "verification_notes": "分析结论正确：\n1. 前置条件合理：代码中确实存在线程被中断或Mutex锁被破坏的风险\n2. 触发路径成立：代码中所有锁操作都直接使用unwrap()，分布在shutdown、create_permanent_threads、spawn、run等关键方法中\n3. 后果评估准确：锁操作失败会导致线程panic，可能引发线程池崩溃或任务丢失\n4. 建议合适：使用expect()提供更有意义的错误信息或实现恢复逻辑是合理的改进方案"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 503, "evidence": "blocking_pool.inner.shared.lock().unwrap().worker_id,", "confidence": 0.55, "severity": "low", "has_risk": true, "preconditions": "线程被中断或Mutex锁被破坏", "trigger_path": "调用路径推导：BlockPoolSpawner::new() -> Inner结构体初始化 -> Mutex::new()。数据流：所有对共享数据的访问都通过Mutex锁保护，但在获取锁时直接使用unwrap()。关键调用点：shutdown(), create_permanent_threads(), spawn(), run()等方法中直接调用lock().unwrap()，未处理可能的锁获取失败情况。", "consequences": "如果锁操作失败会导致线程panic，可能引发线程池崩溃或任务丢失", "suggestions": "使用lock().expect()提供更有意义的错误信息，或者实现锁获取失败时的恢复逻辑", "gid": 302, "verification_notes": "分析结论正确：\n1. 前置条件合理：代码中确实存在线程被中断或Mutex锁被破坏的风险\n2. 触发路径成立：代码中所有锁操作都直接使用unwrap()，分布在shutdown、create_permanent_threads、spawn、run等关键方法中\n3. 后果评估准确：锁操作失败会导致线程panic，可能引发线程池崩溃或任务丢失\n4. 建议合适：使用expect()提供更有意义的错误信息或实现恢复逻辑是合理的改进方案"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 531, "evidence": "blocking_pool.inner.shared.lock().unwrap().worker_id,", "confidence": 0.65, "severity": "medium", "has_risk": true, "preconditions": "线程被中断或Mutex锁被破坏", "trigger_path": "调用路径推导：BlockPoolSpawner::new() -> Inner结构体初始化 -> Mutex::new()。数据流：所有对共享数据的访问都通过Mutex锁保护，但在获取锁时直接使用unwrap()。关键调用点：shutdown(), create_permanent_threads(), spawn(), run()等方法中直接调用lock().unwrap()，未处理可能的锁获取失败情况。", "consequences": "如果锁操作失败会导致线程panic，可能引发线程池崩溃或任务丢失", "suggestions": "使用lock().expect()提供更有意义的错误信息，或者实现锁获取失败时的恢复逻辑", "gid": 306, "verification_notes": "分析结论正确：\n1. 前置条件合理：代码中确实存在线程被中断或Mutex锁被破坏的风险\n2. 触发路径成立：代码中所有锁操作都直接使用unwrap()，分布在shutdown、create_permanent_threads、spawn、run等关键方法中\n3. 后果评估准确：锁操作失败会导致线程panic，可能引发线程池崩溃或任务丢失\n4. 建议合适：使用expect()提供更有意义的错误信息或实现恢复逻辑是合理的改进方案"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 92, "evidence": ".unwrap()", "confidence": 0.65, "severity": "medium", "gid": 293, "has_risk": true, "preconditions": "线程被意外中断或条件变量操作失败", "trigger_path": "调用路径推导：BlockPoolSpawner::shutdown() -> Condvar::wait_timeout().unwrap()。数据流：通过shutdown方法调用条件变量的wait_timeout，在极少数情况下可能因线程中断而返回Err。关键调用点：未对Condvar::wait_timeout的结果进行错误处理。", "consequences": "线程池关闭过程中可能因panic导致资源未正确释放", "suggestions": "使用unwrap_or或模式匹配处理可能的Err情况", "verification_notes": "分析结论正确，前置条件合理（确实存在线程中断或条件变量操作失败可能），触发路径清晰（shutdown()调用Condvar::wait_timeout().unwrap()），后果评估准确（panic可能导致资源未释放），建议合适（应处理可能的Err情况）"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 96, "evidence": "let _ = handle.1.join();", "confidence": 0.55, "severity": "low", "gid": 310, "has_risk": true, "preconditions": "工作线程在执行过程中发生panic", "trigger_path": "调用路径推导：线程池关闭流程 -> 等待工作线程完成 -> 忽略join()结果。数据流：当线程池关闭时，会遍历所有工作线程并调用join()等待线程结束，但忽略了join()返回的Result。关键调用点：join()方法的返回值被显式忽略。", "consequences": "丢失线程panic的调试信息，影响问题诊断", "suggestions": "处理join()的错误结果，例如记录日志：if let Err(e) = handle.1.join() { log::error!(\"Worker thread panicked: {:?}\", e); }", "verification_notes": "分析结论正确：\n1. 前置条件合理：代码中确实存在线程panic的可能性（如第247行panic处理）\n2. 触发路径成立：shutdown()方法中确实忽略了join()的返回值（第96行）\n3. 后果评估准确：确实会丢失线程panic的调试信息\n4. 建议合适：添加错误日志记录是合理的改进方案"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/sleeper.rs", "line": 35, "evidence": "let idle_list = self.idle_list.lock().unwrap();", "confidence": 0.65, "severity": "medium", "has_risk": true, "preconditions": "线程持有锁时panic且未释放锁(中毒状态)或系统资源不足无法获取锁", "trigger_path": "调用路径推导：线程池工作线程 -> Sleeper结构体的各方法(如is_parked/pop_worker_by_id等) -> Mutex::lock().unwrap()。数据流：线程池工作线程调用Sleeper的各同步方法，这些方法直接对Mutex加锁并使用unwrap()处理结果。关键调用点：所有调用点都直接使用unwrap()而没有错误处理。", "consequences": "锁操作panic会导致整个线程池不可用，影响系统稳定性", "suggestions": "考虑使用match或unwrap_or_else处理锁获取错误，或者在更高层级实现恢复机制", "gid": 334, "verification_notes": "分析结论正确：\n1. 前置条件合理：代码中确实存在线程持有锁时panic且未释放锁的风险\n2. 触发路径成立：所有Mutex锁操作都直接使用unwrap()而没有错误处理\n3. 后果评估准确：锁操作panic确实会导致整个线程池不可用\n4. 建议合适：使用match或unwrap_or_else处理锁获取错误是合理的改进方案\n验证依据：\n- blocking_pool.rs文件中所有Mutex锁操作都直接使用unwrap()\n- 记忆检索显示这是系统级组件的设计选择，允许在锁失败时panic"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/sleeper.rs", "line": 40, "evidence": "let mut idle_list = self.idle_list.lock().unwrap();", "confidence": 0.65, "severity": "medium", "has_risk": true, "preconditions": "线程持有锁时panic且未释放锁(中毒状态)或系统资源不足无法获取锁", "trigger_path": "调用路径推导：线程池工作线程 -> Sleeper结构体的各方法(如is_parked/pop_worker_by_id等) -> Mutex::lock().unwrap()。数据流：线程池工作线程调用Sleeper的各同步方法，这些方法直接对Mutex加锁并使用unwrap()处理结果。关键调用点：所有调用点都直接使用unwrap()而没有错误处理。", "consequences": "锁操作panic会导致整个线程池不可用，影响系统稳定性", "suggestions": "考虑使用match或unwrap_or_else处理锁获取错误，或者在更高层级实现恢复机制", "gid": 335, "verification_notes": "分析结论正确：\n1. 前置条件合理：代码中确实存在线程持有锁时panic且未释放锁的风险\n2. 触发路径成立：所有Mutex锁操作都直接使用unwrap()而没有错误处理\n3. 后果评估准确：锁操作panic确实会导致整个线程池不可用\n4. 建议合适：使用match或unwrap_or_else处理锁获取错误是合理的改进方案\n验证依据：\n- blocking_pool.rs文件中所有Mutex锁操作都直接使用unwrap()\n- 记忆检索显示这是系统级组件的设计选择，允许在锁失败时panic"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/sleeper.rs", "line": 57, "evidence": "let mut idle_list = self.idle_list.lock().unwrap();", "confidence": 0.65, "severity": "medium", "has_risk": true, "preconditions": "线程持有锁时panic且未释放锁(中毒状态)或系统资源不足无法获取锁", "trigger_path": "调用路径推导：线程池工作线程 -> Sleeper结构体的各方法(如is_parked/pop_worker_by_id等) -> Mutex::lock().unwrap()。数据流：线程池工作线程调用Sleeper的各同步方法，这些方法直接对Mutex加锁并使用unwrap()处理结果。关键调用点：所有调用点都直接使用unwrap()而没有错误处理。", "consequences": "锁操作panic会导致整个线程池不可用，影响系统稳定性", "suggestions": "考虑使用match或unwrap_or_else处理锁获取错误，或者在更高层级实现恢复机制", "gid": 336, "verification_notes": "分析结论正确：\n1. 前置条件合理：代码中确实存在线程持有锁时panic且未释放锁的风险\n2. 触发路径成立：所有Mutex锁操作都直接使用unwrap()而没有错误处理\n3. 后果评估准确：锁操作panic确实会导致整个线程池不可用\n4. 建议合适：使用match或unwrap_or_else处理锁获取错误是合理的改进方案\n验证依据：\n- blocking_pool.rs文件中所有Mutex锁操作都直接使用unwrap()\n- 记忆检索显示这是系统级组件的设计选择，允许在锁失败时panic"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/sleeper.rs", "line": 63, "evidence": "let mut search_list = self.wake_by_search.lock().unwrap();", "confidence": 0.65, "severity": "medium", "has_risk": true, "preconditions": "线程持有锁时panic且未释放锁(中毒状态)或系统资源不足无法获取锁", "trigger_path": "调用路径推导：线程池工作线程 -> Sleeper结构体的各方法(如is_parked/pop_worker_by_id等) -> Mutex::lock().unwrap()。数据流：线程池工作线程调用Sleeper的各同步方法，这些方法直接对Mutex加锁并使用unwrap()处理结果。关键调用点：所有调用点都直接使用unwrap()而没有错误处理。", "consequences": "锁操作panic会导致整个线程池不可用，影响系统稳定性", "suggestions": "考虑使用match或unwrap_or_else处理锁获取错误，或者在更高层级实现恢复机制", "gid": 337, "verification_notes": "分析结论正确：\n1. 前置条件合理：代码中确实存在线程持有锁时panic且未释放锁的风险\n2. 触发路径成立：所有Mutex锁操作都直接使用unwrap()而没有错误处理\n3. 后果评估准确：锁操作panic确实会导致整个线程池不可用\n4. 建议合适：使用match或unwrap_or_else处理锁获取错误是合理的改进方案\n验证依据：\n- blocking_pool.rs文件中所有Mutex锁操作都直接使用unwrap()\n- 记忆检索显示这是系统级组件的设计选择，允许在锁失败时panic"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/sleeper.rs", "line": 74, "evidence": "let mut idle_list = self.idle_list.lock().unwrap();", "confidence": 0.65, "severity": "medium", "has_risk": true, "preconditions": "线程持有锁时panic且未释放锁(中毒状态)或系统资源不足无法获取锁", "trigger_path": "调用路径推导：线程池工作线程 -> Sleeper结构体的各方法(如is_parked/pop_worker_by_id等) -> Mutex::lock().unwrap()。数据流：线程池工作线程调用Sleeper的各同步方法，这些方法直接对Mutex加锁并使用unwrap()处理结果。关键调用点：所有调用点都直接使用unwrap()而没有错误处理。", "consequences": "锁操作panic会导致整个线程池不可用，影响系统稳定性", "suggestions": "考虑使用match或unwrap_or_else处理锁获取错误，或者在更高层级实现恢复机制", "gid": 338, "verification_notes": "分析结论正确：\n1. 前置条件合理：代码中确实存在线程持有锁时panic且未释放锁的风险\n2. 触发路径成立：所有Mutex锁操作都直接使用unwrap()而没有错误处理\n3. 后果评估准确：锁操作panic确实会导致整个线程池不可用\n4. 建议合适：使用match或unwrap_or_else处理锁获取错误是合理的改进方案\n验证依据：\n- blocking_pool.rs文件中所有Mutex锁操作都直接使用unwrap()\n- 记忆检索显示这是系统级组件的设计选择，允许在锁失败时panic"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/schedule_io.rs", "line": 343, "evidence": "let mut waiters = schedule_io.waiters.lock().unwrap();", "confidence": 0.65, "severity": "medium", "gid": 411, "verify": "检查unwrap()是否有适当的错误处理或是否可以被更安全的处理方式替代", "has_risk": true, "preconditions": "当互斥锁被污染（如持有锁时发生panic）", "trigger_path": "调用路径推导：异步IO操作 -> poll_init()/set_waker() -> Mutex::lock().unwrap()。数据流：ScheduleIO.waiters字段的Mutex锁在poll_init()和set_waker()函数中被直接调用unwrap()获取。关键调用点：这两个函数都没有处理Mutex锁可能返回的Err情况。", "consequences": "可能导致运行时panic，影响网络连接的正常处理", "suggestions": "使用expect()提供更有意义的错误信息，或使用?操作符将错误传播到调用者，或使用lock().unwrap_or_else()提供恢复逻辑", "verification_notes": "分析结论正确，前置条件合理（Mutex锁确实存在被污染风险），触发路径成立（poll_init和set_waker函数中直接使用unwrap()获取锁），后果评估准确（可能导致运行时panic），建议合适（推荐使用expect()或?操作符）"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/ffrt/ffrt_task.rs", "line": 24, "evidence": "let task_ctx = unsafe { ffrt_get_current_task() };", "confidence": 0.8, "severity": "high", "gid": 551, "verify": "验证所有FFRT任务上下文相关的指针操作是否安全，包括ffrt_get_current_task()返回的指针有效性、RawTaskCtx类型的使用安全性以及unsafe块中的边界检查", "has_risk": true, "preconditions": "ffrt_get_current_task()返回无效指针或FfrtTaskCtx被构造时传入空指针", "trigger_path": "调用路径推导：外部调用者 -> FfrtTaskCtx::get_current() -> unsafe { ffrt_get_current_task() } 或外部调用者 -> FfrtTaskCtx::wake_task() -> unsafe { ffrt_wake_coroutine() }。数据流：1) 通过FfrtTaskCtx::get_current()获取的原始指针未经校验直接使用；2) 通过FfrtTaskCtx构造器传入的原始指针在wake_task()中未经校验直接使用。关键调用点：1) get_current()未对ffrt_get_current_task()返回值进行校验；2) wake_task()未对self.0指针进行校验。", "consequences": "可能导致空指针解引用或未定义行为，引发程序崩溃或内存安全问题", "suggestions": "1) 在FfrtTaskCtx::get_current()中对ffrt_get_current_task()返回值进行空指针检查；2) 在FfrtTaskCtx::wake_task()中添加指针有效性检查；3) 考虑为RawTaskCtx类型添加安全封装层", "verification_notes": "分析结论正确，前置条件合理（ffrt_get_current_task()可能返回无效指针），触发路径清晰（直接使用未校验指针），后果评估准确（可能导致空指针解引用），建议合适（添加指针校验和安全封装）"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/ffrt/ffrt_task.rs", "line": 29, "evidence": "unsafe {", "confidence": 0.8, "severity": "high", "gid": 552, "verify": "验证所有FFRT任务上下文相关的指针操作是否安全，包括ffrt_get_current_task()返回的指针有效性、RawTaskCtx类型的使用安全性以及unsafe块中的边界检查", "has_risk": true, "preconditions": "ffrt_get_current_task()返回无效指针或FfrtTaskCtx被构造时传入空指针", "trigger_path": "调用路径推导：外部调用者 -> FfrtTaskCtx::get_current() -> unsafe { ffrt_get_current_task() } 或外部调用者 -> FfrtTaskCtx::wake_task() -> unsafe { ffrt_wake_coroutine() }。数据流：1) 通过FfrtTaskCtx::get_current()获取的原始指针未经校验直接使用；2) 通过FfrtTaskCtx构造器传入的原始指针在wake_task()中未经校验直接使用。关键调用点：1) get_current()未对ffrt_get_current_task()返回值进行校验；2) wake_task()未对self.0指针进行校验。", "consequences": "可能导致空指针解引用或未定义行为，引发程序崩溃或内存安全问题", "suggestions": "1) 在FfrtTaskCtx::get_current()中对ffrt_get_current_task()返回值进行空指针检查；2) 在FfrtTaskCtx::wake_task()中添加指针有效性检查；3) 考虑为RawTaskCtx类型添加安全封装层", "verification_notes": "分析结论正确，前置条件合理（ffrt_get_current_task()可能返回无效指针），触发路径清晰（直接使用未校验指针），后果评估准确（可能导致空指针解引用），建议合适（添加指针校验和安全封装）"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/ffrt/ffrt_task.rs", "line": 17, "evidence": "type RawTaskCtx = *mut c_void;", "confidence": 0.75, "severity": "medium", "gid": 553, "verify": "验证所有FFRT任务上下文相关的指针操作是否安全，包括ffrt_get_current_task()返回的指针有效性、RawTaskCtx类型的使用安全性以及unsafe块中的边界检查", "has_risk": true, "preconditions": "ffrt_get_current_task()返回无效指针或FfrtTaskCtx被构造时传入空指针", "trigger_path": "调用路径推导：外部调用者 -> FfrtTaskCtx::get_current() -> unsafe { ffrt_get_current_task() } 或外部调用者 -> FfrtTaskCtx::wake_task() -> unsafe { ffrt_wake_coroutine() }。数据流：1) 通过FfrtTaskCtx::get_current()获取的原始指针未经校验直接使用；2) 通过FfrtTaskCtx构造器传入的原始指针在wake_task()中未经校验直接使用。关键调用点：1) get_current()未对ffrt_get_current_task()返回值进行校验；2) wake_task()未对self.0指针进行校验。", "consequences": "可能导致空指针解引用或未定义行为，引发程序崩溃或内存安全问题", "suggestions": "1) 在FfrtTaskCtx::get_current()中对ffrt_get_current_task()返回值进行空指针检查；2) 在FfrtTaskCtx::wake_task()中添加指针有效性检查；3) 考虑为RawTaskCtx类型添加安全封装层", "verification_notes": "分析结论正确，前置条件合理（ffrt_get_current_task()可能返回无效指针），触发路径清晰（直接使用未校验指针），后果评估准确（可能导致空指针解引用），建议合适（添加指针校验和安全封装）"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/time/wheel.rs", "line": 125, "evidence": "unsafe impl Link for Clock {", "confidence": 0.8, "severity": "high", "gid": 650, "verify": "确认unsafe实现和函数有足够的文档说明其安全性保证", "has_risk": true, "preconditions": "调用者需要确保Clock结构体的内存布局稳定，且NonNull指针有效", "trigger_path": "调用路径推导：1) 输入来源：Clock结构体的NonNull指针；2) 调用链：直接调用unsafe impl Link for Clock或unsafe fn node；3) 校验情况：没有对NonNull指针的有效性进行检查；4) 触发条件：当传入无效的NonNull指针或Clock结构体布局发生变化时", "consequences": "可能导致未定义行为，包括内存损坏或程序崩溃", "suggestions": "1) 添加详细的文档说明安全前提条件；2) 在文档中明确调用者需要保证的不变量；3) 考虑添加运行时检查（如NonNull指针有效性验证）", "verification_notes": "代码验证确认分析结论正确：1) Clock结构体确实使用NonNull指针；2) unsafe impl Link确实缺少指针有效性检查；3) 可能导致未定义行为；4) 建议合理"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/time/wheel.rs", "line": 126, "evidence": "unsafe fn node(mut ptr: NonNull<Self>) -> NonNull<Node<Self>>", "confidence": 0.8, "severity": "high", "gid": 651, "verify": "确认unsafe实现和函数有足够的文档说明其安全性保证", "has_risk": true, "preconditions": "调用者需要确保Clock结构体的内存布局稳定，且NonNull指针有效", "trigger_path": "调用路径推导：1) 输入来源：Clock结构体的NonNull指针；2) 调用链：直接调用unsafe impl Link for Clock或unsafe fn node；3) 校验情况：没有对NonNull指针的有效性进行检查；4) 触发条件：当传入无效的NonNull指针或Clock结构体布局发生变化时", "consequences": "可能导致未定义行为，包括内存损坏或程序崩溃", "suggestions": "1) 添加详细的文档说明安全前提条件；2) 在文档中明确调用者需要保证的不变量；3) 考虑添加运行时检查（如NonNull指针有效性验证）", "verification_notes": "代码验证确认分析结论正确：1) Clock结构体确实使用NonNull指针；2) unsafe impl Link确实缺少指针有效性检查；3) 可能导致未定义行为；4) 建议合理"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/fs/async_file.rs", "line": 285, "evidence": "_ => unreachable!(),", "confidence": 0.6, "severity": "medium", "gid": 819, "verify": "确认 unreachable!() 宏的使用是否合理，是否真的不可能到达该分支", "has_risk": true, "preconditions": "调用 set_len() 方法时文件状态不是 Idle 状态（可能是 Reading/Writing/Seeking 状态）", "trigger_path": "调用路径推导：外部调用者 -> set_len() -> FileState 匹配。数据流：外部调用者直接调用 set_len() 方法，该方法未检查文件状态就直接匹配 FileState。关键调用点：set_len() 方法未对文件状态进行前置检查。", "consequences": "程序会触发 panic，可能导致服务中断或数据不一致", "suggestions": "1) 在 set_len() 方法开始时检查文件状态，如果不是 Idle 状态则返回错误；2) 或者修改设计确保 set_len() 只能在 Idle 状态下被调用", "verification_notes": "分析结论正确，FileState确实有四种状态(Idle/Reading/Writing/Seeking)，set_len方法需要确保文件处于Idle状态，当前实现直接使用unreachable!()处理非Idle状态存在风险，触发路径和后果评估准确，建议合理"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/sync/mpsc/bounded/mod.rs", "line": 225, "evidence": "SendPosition::Full => unreachable!(),", "confidence": 0.6, "severity": "medium", "gid": 843, "verify": "验证候选 843 的安全风险", "has_risk": true, "preconditions": "通道已满且调用send_timeout方法", "trigger_path": "调用路径推导：send_timeout() -> get_position() -> Position.await -> prepare_send()。数据流：send_timeout方法调用get_position()获取发送位置，prepare_send()可能返回SendPosition::Full状态，但send_timeout()错误地将其标记为unreachable。关键调用点：get_position()可能返回SendPosition::Full，但调用链未正确处理该状态。", "consequences": "当通道已满时会导致程序panic，可能造成服务中断", "suggestions": "应正确处理SendPosition::Full状态，返回适当的错误（如SendTimeoutError::Full）而不是使用unreachable!()", "verification_notes": "代码分析确认send_timeout()方法确实未处理SendPosition::Full状态，会导致panic。前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 47, "evidence": "data: unsafe { MaybeUninit::zeroed().assume_init() },", "confidence": 0.7999999999999999, "severity": "medium", "gid": 858, "verify": "验证MaybeUninit使用是否正确，assume_init调用前是否确保初始化", "has_risk": true, "preconditions": "Block::new() 被调用且其 data 数组被使用前未完全初始化", "trigger_path": "调用路径推导：Queue::new() -> Block::new() -> MaybeUninit::zeroed().assume_init()。数据流：Queue::new() 创建新的 Block 实例，Block::new() 使用 MaybeUninit::zeroed().assume_init() 初始化 data 数组。关键调用点：Block::new() 直接假设 zeroed 内存已初始化。", "consequences": "可能读取未初始化的内存，导致未定义行为", "suggestions": "应确保所有数组元素在使用前被显式初始化，或使用 MaybeUninit::uninit() 并手动初始化每个元素", "verification_notes": "分析结论正确：\n1. 前置条件合理：Block::new()确实使用了MaybeUninit::zeroed().assume_init()初始化data数组\n2. 触发路径成立：Queue::new() → Block::new() → MaybeUninit::zeroed().assume_init()调用路径正确\n3. 后果评估准确：确实可能导致读取未初始化内存的未定义行为\n4. 建议合适：建议显式初始化或手动初始化每个元素是合理的解决方案"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 47, "evidence": "data: unsafe { MaybeUninit::zeroed().assume_init() },", "confidence": 0.75, "severity": "medium", "gid": 870, "verify": "验证MaybeUninit使用是否正确，assume_init调用前是否确保初始化", "has_risk": true, "preconditions": "Block::new() 被调用且其 data 数组被使用前未完全初始化", "trigger_path": "调用路径推导：Queue::new() -> Block::new() -> MaybeUninit::zeroed().assume_init()。数据流：Queue::new() 创建新的 Block 实例，Block::new() 使用 MaybeUninit::zeroed().assume_init() 初始化 data 数组。关键调用点：Block::new() 直接假设 zeroed 内存已初始化。", "consequences": "可能读取未初始化的内存，导致未定义行为", "suggestions": "应确保所有数组元素在使用前被显式初始化，或使用 MaybeUninit::uninit() 并手动初始化每个元素", "verification_notes": "分析结论正确：\n1. 前置条件合理：Block::new()确实使用了MaybeUninit::zeroed().assume_init()初始化data数组\n2. 触发路径成立：Queue::new() → Block::new() → MaybeUninit::zeroed().assume_init()调用路径正确\n3. 后果评估准确：确实可能导致读取未初始化内存的未定义行为\n4. 建议合适：建议显式初始化或手动初始化每个元素是合理的解决方案"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1523, "evidence": "let (connected_sender, _) = udp_try_bind_connect(ADDR, socket_deal).await.unwrap();", "confidence": 0.65, "severity": "medium", "gid": 882, "verify": "验证udp_try_bind_connect()调用是否可能失败", "has_risk": true, "preconditions": "udp_try_bind_connect()函数执行过程中遇到非AddrInUse类型的错误", "trigger_path": "调用路径推导：测试函数（如ut_udp_basic_v4）-> udp_try_bind_connect()。数据流：测试函数直接调用udp_try_bind_connect()并立即unwrap()结果。关键调用点：所有测试函数都未对udp_try_bind_connect()的结果进行错误处理。触发条件：当绑定UDP套接字或连接套接字失败时（非AddrInUse错误）。", "consequences": "测试用例会因panic而提前终止，可能导致测试覆盖率不足或掩盖其他问题", "suggestions": "使用expect()提供更有意义的错误信息，或使用?将错误传播给测试框架", "verification_notes": "分析结论正确：\n1. 前置条件合理：udp_try_bind_connect()确实可能遇到非AddrInUse错误\n2. 触发路径成立：测试函数确实直接调用udp_try_bind_connect()并立即unwrap()结果\n3. 后果评估准确：测试用例确实会因panic而提前终止\n4. 建议合适：使用expect()或?传播错误是更好的错误处理方式\n验证通过，测试代码中的unwrap()确实存在风险，需要改进错误处理"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1576, "evidence": "let (connected_sender, _) = udp_try_bind_connect(addr, socket_deal).await.unwrap();", "confidence": 0.65, "severity": "medium", "gid": 896, "verify": "验证udp_try_bind_connect()调用是否可能失败", "has_risk": true, "preconditions": "udp_try_bind_connect()函数执行过程中遇到非AddrInUse类型的错误", "trigger_path": "调用路径推导：测试函数（如ut_udp_basic_v4）-> udp_try_bind_connect()。数据流：测试函数直接调用udp_try_bind_connect()并立即unwrap()结果。关键调用点：所有测试函数都未对udp_try_bind_connect()的结果进行错误处理。触发条件：当绑定UDP套接字或连接套接字失败时（非AddrInUse错误）。", "consequences": "测试用例会因panic而提前终止，可能导致测试覆盖率不足或掩盖其他问题", "suggestions": "使用expect()提供更有意义的错误信息，或使用?将错误传播给测试框架", "verification_notes": "分析结论正确：\n1. 前置条件合理：udp_try_bind_connect()确实可能遇到非AddrInUse错误\n2. 触发路径成立：测试函数确实直接调用udp_try_bind_connect()并立即unwrap()结果\n3. 后果评估准确：测试用例确实会因panic而提前终止\n4. 建议合适：使用expect()或?传播错误是更好的错误处理方式\n验证通过，测试代码中的unwrap()确实存在风险，需要改进错误处理"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1603, "evidence": "udp_try_bind_connect(ADDR, |_| {}).await.unwrap();", "confidence": 0.55, "severity": "low", "gid": 901, "verify": "验证udp_try_bind_connect()调用是否可能失败", "has_risk": true, "preconditions": "udp_try_bind_connect()函数执行过程中遇到非AddrInUse类型的错误", "trigger_path": "调用路径推导：测试函数（如ut_udp_basic_v4）-> udp_try_bind_connect()。数据流：测试函数直接调用udp_try_bind_connect()并立即unwrap()结果。关键调用点：所有测试函数都未对udp_try_bind_connect()的结果进行错误处理。触发条件：当绑定UDP套接字或连接套接字失败时（非AddrInUse错误）。", "consequences": "测试用例会因panic而提前终止，可能导致测试覆盖率不足或掩盖其他问题", "suggestions": "使用expect()提供更有意义的错误信息，或使用?将错误传播给测试框架", "verification_notes": "分析结论正确：\n1. 前置条件合理：udp_try_bind_connect()确实可能遇到非AddrInUse错误\n2. 触发路径成立：测试函数确实直接调用udp_try_bind_connect()并立即unwrap()结果\n3. 后果评估准确：测试用例确实会因panic而提前终止\n4. 建议合适：使用expect()或?传播错误是更好的错误处理方式\n验证通过，测试代码中的unwrap()确实存在风险，需要改进错误处理"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1672, "evidence": "let (broadcast_socket, _) = udp_try_bind_connect(ADDR, |_| {}).await.unwrap();", "confidence": 0.55, "severity": "low", "gid": 916, "verify": "验证udp_try_bind_connect()调用是否可能失败", "has_risk": true, "preconditions": "udp_try_bind_connect()函数执行过程中遇到非AddrInUse类型的错误", "trigger_path": "调用路径推导：测试函数（如ut_udp_basic_v4）-> udp_try_bind_connect()。数据流：测试函数直接调用udp_try_bind_connect()并立即unwrap()结果。关键调用点：所有测试函数都未对udp_try_bind_connect()的结果进行错误处理。触发条件：当绑定UDP套接字或连接套接字失败时（非AddrInUse错误）。", "consequences": "测试用例会因panic而提前终止，可能导致测试覆盖率不足或掩盖其他问题", "suggestions": "使用expect()提供更有意义的错误信息，或使用?将错误传播给测试框架", "verification_notes": "分析结论正确：\n1. 前置条件合理：udp_try_bind_connect()确实可能遇到非AddrInUse错误\n2. 触发路径成立：测试函数确实直接调用udp_try_bind_connect()并立即unwrap()结果\n3. 后果评估准确：测试用例确实会因panic而提前终止\n4. 建议合适：使用expect()或?传播错误是更好的错误处理方式\n验证通过，测试代码中的unwrap()确实存在风险，需要改进错误处理"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_io/src/waker.rs", "line": 48, "evidence": "let poll = Poll::new().unwrap();", "confidence": 0.55, "severity": "low", "gid": 1166, "verify": "验证 Poll::new() 和 Waker::new() 是否会返回 Err 导致 panic", "has_risk": true, "preconditions": "系统资源不足（如文件描述符耗尽、内存不足等）导致 Poll::new() 或 Waker::new() 返回 Err", "trigger_path": "调用路径推导：测试函数 ut_waker_debug_info() -> Poll::new() -> Selector::new() -> 系统调用(kqueue/epoll_create1/CompletionPort)。数据流：测试代码直接调用 Poll::new() 和 Waker::new()，未处理可能的错误。关键调用点：Poll::new() 和 Waker::new() 都依赖系统资源分配，可能因系统资源不足而失败。", "consequences": "测试用例 panic，可能导致测试框架中断或测试结果不准确", "suggestions": "在测试代码中添加错误处理逻辑，或确保测试环境有足够系统资源", "verification_notes": "分析结论正确，前置条件合理（系统资源不足确实可能导致Poll::new()或Waker::new()失败），触发路径清晰（测试函数直接调用且未处理错误），后果评估准确（测试panic会导致测试框架中断），建议合适（添加错误处理或确保资源足够）"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_io/src/waker.rs", "line": 49, "evidence": "let waker = Waker::new(&poll, Token::from_usize(0)).unwrap();", "confidence": 0.55, "severity": "low", "gid": 1167, "verify": "验证 Poll::new() 和 Waker::new() 是否会返回 Err 导致 panic", "has_risk": true, "preconditions": "系统资源不足（如文件描述符耗尽、内存不足等）导致 Poll::new() 或 Waker::new() 返回 Err", "trigger_path": "调用路径推导：测试函数 ut_waker_debug_info() -> Poll::new() -> Selector::new() -> 系统调用(kqueue/epoll_create1/CompletionPort)。数据流：测试代码直接调用 Poll::new() 和 Waker::new()，未处理可能的错误。关键调用点：Poll::new() 和 Waker::new() 都依赖系统资源分配，可能因系统资源不足而失败。", "consequences": "测试用例 panic，可能导致测试框架中断或测试结果不准确", "suggestions": "在测试代码中添加错误处理逻辑，或确保测试环境有足够系统资源", "verification_notes": "分析结论正确，前置条件合理（系统资源不足确实可能导致Poll::new()或Waker::new()失败），触发路径清晰（测试函数直接调用且未处理错误），后果评估准确（测试panic会导致测试框架中断），建议合适（添加错误处理或确保资源足够）"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_io/src/sys/windows/afd.rs", "line": 209, "evidence": "let mut afd_group = self.afd_group.lock().unwrap();", "confidence": 0.65, "severity": "medium", "gid": 1254, "verify": "验证unwrap/expect是否可能导致panic", "has_risk": true, "preconditions": "线程在持有Mutex锁时发生panic", "trigger_path": "调用路径推导：AfdGroup::acquire() -> Mutex::lock().unwrap() 和 AfdGroup::release_unused_afd() -> Mutex::lock().unwrap()。数据流：内部线程同步操作直接访问Mutex，没有外部输入直接影响。关键调用点：直接调用Mutex::lock()后使用unwrap()，没有错误处理。", "consequences": "线程panic导致程序崩溃", "suggestions": "使用Mutex::lock()的Result返回值进行错误处理，或者使用Mutex::lock().expect()提供更有意义的错误信息", "verification_notes": "分析结论正确，前置条件合理（确实使用Mutex保护共享状态且直接unwrap），触发路径清晰（acquire和release_unused_afd方法都直接unwrap锁），后果评估准确（线程panic会导致锁永久占用），建议合适（应处理Result或使用expect）"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_io/src/sys/windows/afd.rs", "line": 231, "evidence": "let mut afd_group = self.afd_group.lock().unwrap();", "confidence": 0.65, "severity": "medium", "gid": 1256, "verify": "验证unwrap/expect是否可能导致panic", "has_risk": true, "preconditions": "线程在持有Mutex锁时发生panic", "trigger_path": "调用路径推导：AfdGroup::acquire() -> Mutex::lock().unwrap() 和 AfdGroup::release_unused_afd() -> Mutex::lock().unwrap()。数据流：内部线程同步操作直接访问Mutex，没有外部输入直接影响。关键调用点：直接调用Mutex::lock()后使用unwrap()，没有错误处理。", "consequences": "线程panic导致程序崩溃", "suggestions": "使用Mutex::lock()的Result返回值进行错误处理，或者使用Mutex::lock().expect()提供更有意义的错误信息", "verification_notes": "分析结论正确，前置条件合理（确实使用Mutex保护共享状态且直接unwrap），触发路径清晰（acquire和release_unused_afd方法都直接unwrap锁），后果评估准确（线程panic会导致锁永久占用），建议合适（应处理Result或使用expect）"}
