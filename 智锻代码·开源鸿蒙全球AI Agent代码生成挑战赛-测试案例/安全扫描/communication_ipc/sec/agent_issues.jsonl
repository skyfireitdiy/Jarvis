{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dl_deps/dsoftbus_interface.h", "line": 1229, "evidence": "bool (*OnNegotiate)(int32_t socket, PeerSocketInfo info);", "confidence": 0.6, "severity": "high", "gid": 1, "verify": "验证函数指针在被调用前是否被正确初始化/赋值", "has_risk": true, "preconditions": "ISocketListener结构体中的OnNegotiate或OnNegotiate2函数指针被调用", "trigger_path": "调用路径推导：DBinderSoftbusClient::Bind() -> 底层socket库 -> 调用ISocketListener中的回调函数。数据流：ISocketListener结构体在DBinderRemoteListener构造函数中初始化，但未初始化OnNegotiate和OnNegotiate2函数指针，该结构体被传递给DBinderSoftbusClient::Bind()方法。关键调用点：底层socket库可能调用未初始化的函数指针。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "1. 在DBinderRemoteListener构造函数中初始化所有函数指针；2. 在调用函数指针前添加空指针检查；3. 如果不需要这些回调，应将其显式设置为nullptr", "verification_notes": "分析结论正确：\n1. 前置条件合理：ISocketListener结构体中的OnNegotiate和OnNegotiate2函数指针确实未被初始化\n2. 触发路径成立：DBinderSoftbusClient::Bind()确实会将ISocketListener传递给底层socket库\n3. 后果评估准确：未初始化的函数指针被调用确实会导致空指针解引用和程序崩溃\n4. 建议合适：初始化函数指针、添加空指针检查和显式设置为nullptr都是有效的解决方案"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dl_deps/dsoftbus_interface.h", "line": 1231, "evidence": "bool (*OnNegotiate2)(int32_t socket, PeerSocketInfo info, SocketAccessInfo *peerInfo, SocketAccessInfo *localInfo);", "confidence": 0.6, "severity": "high", "gid": 2, "verify": "验证函数指针在被调用前是否被正确初始化/赋值", "has_risk": true, "preconditions": "ISocketListener结构体中的OnNegotiate或OnNegotiate2函数指针被调用", "trigger_path": "调用路径推导：DBinderSoftbusClient::Bind() -> 底层socket库 -> 调用ISocketListener中的回调函数。数据流：ISocketListener结构体在DBinderRemoteListener构造函数中初始化，但未初始化OnNegotiate和OnNegotiate2函数指针，该结构体被传递给DBinderSoftbusClient::Bind()方法。关键调用点：底层socket库可能调用未初始化的函数指针。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "1. 在DBinderRemoteListener构造函数中初始化所有函数指针；2. 在调用函数指针前添加空指针检查；3. 如果不需要这些回调，应将其显式设置为nullptr", "verification_notes": "分析结论正确：\n1. 前置条件合理：ISocketListener结构体中的OnNegotiate和OnNegotiate2函数指针确实未被初始化\n2. 触发路径成立：DBinderSoftbusClient::Bind()确实会将ISocketListener传递给底层socket库\n3. 后果评估准确：未初始化的函数指针被调用确实会导致空指针解引用和程序崩溃\n4. 建议合适：初始化函数指针、添加空指针检查和显式设置为nullptr都是有效的解决方案"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "utils/include/doubly_linked_list.h", "line": 34, "evidence": "list->pstNext = list;", "confidence": 0.6, "severity": "high", "gid": 35, "verify": "验证所有链表操作中对指针的解引用前都进行了空指针检查", "has_risk": true, "preconditions": "传入的链表指针或节点指针为NULL", "trigger_path": "调用路径推导：多个调用路径(如rpc_session_handle.c中的CreateSessionIdNode() -> DLListAdd(), ipc_process_skeleton.c中的AddDeathRecipient() -> DLListAdd()等)。数据流：链表操作函数被多个模块调用，部分调用点未对传入指针进行空指针检查。关键调用点：doubly_linked_list.h中的链表操作函数未进行空指针检查，且部分调用者也未进行充分检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在链表操作函数内部添加空指针检查；2. 确保所有调用者在调用链表操作函数前进行空指针检查；3. 使用断言或日志记录潜在的空指针问题", "verification_notes": "分析结论正确，前置条件合理（链表操作函数确实未进行空指针检查），触发路径成立（多个调用路径中存在空指针风险），后果评估准确（空指针解引用会导致程序崩溃），建议合适（记忆中也提出了类似的改进建议）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "utils/include/doubly_linked_list.h", "line": 35, "evidence": "list->pstPrev = list;", "confidence": 0.6, "severity": "high", "gid": 36, "verify": "验证所有链表操作中对指针的解引用前都进行了空指针检查", "has_risk": true, "preconditions": "传入的链表指针或节点指针为NULL", "trigger_path": "调用路径推导：多个调用路径(如rpc_session_handle.c中的CreateSessionIdNode() -> DLListAdd(), ipc_process_skeleton.c中的AddDeathRecipient() -> DLListAdd()等)。数据流：链表操作函数被多个模块调用，部分调用点未对传入指针进行空指针检查。关键调用点：doubly_linked_list.h中的链表操作函数未进行空指针检查，且部分调用者也未进行充分检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在链表操作函数内部添加空指针检查；2. 确保所有调用者在调用链表操作函数前进行空指针检查；3. 使用断言或日志记录潜在的空指针问题", "verification_notes": "分析结论正确，前置条件合理（链表操作函数确实未进行空指针检查），触发路径成立（多个调用路径中存在空指针风险），后果评估准确（空指针解引用会导致程序崩溃），建议合适（记忆中也提出了类似的改进建议）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "utils/include/doubly_linked_list.h", "line": 47, "evidence": "node->pstNext = list->pstNext;", "confidence": 0.6, "severity": "high", "gid": 37, "verify": "验证所有链表操作中对指针的解引用前都进行了空指针检查", "has_risk": true, "preconditions": "传入的链表指针或节点指针为NULL", "trigger_path": "调用路径推导：多个调用路径(如rpc_session_handle.c中的CreateSessionIdNode() -> DLListAdd(), ipc_process_skeleton.c中的AddDeathRecipient() -> DLListAdd()等)。数据流：链表操作函数被多个模块调用，部分调用点未对传入指针进行空指针检查。关键调用点：doubly_linked_list.h中的链表操作函数未进行空指针检查，且部分调用者也未进行充分检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在链表操作函数内部添加空指针检查；2. 确保所有调用者在调用链表操作函数前进行空指针检查；3. 使用断言或日志记录潜在的空指针问题", "verification_notes": "分析结论正确，前置条件合理（链表操作函数确实未进行空指针检查），触发路径成立（多个调用路径中存在空指针风险），后果评估准确（空指针解引用会导致程序崩溃），建议合适（记忆中也提出了类似的改进建议）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "utils/include/doubly_linked_list.h", "line": 47, "evidence": "node->pstNext = list->pstNext;", "confidence": 0.6, "severity": "high", "gid": 38, "verify": "验证所有链表操作中对指针的解引用前都进行了空指针检查", "has_risk": true, "preconditions": "传入的链表指针或节点指针为NULL", "trigger_path": "调用路径推导：多个调用路径(如rpc_session_handle.c中的CreateSessionIdNode() -> DLListAdd(), ipc_process_skeleton.c中的AddDeathRecipient() -> DLListAdd()等)。数据流：链表操作函数被多个模块调用，部分调用点未对传入指针进行空指针检查。关键调用点：doubly_linked_list.h中的链表操作函数未进行空指针检查，且部分调用者也未进行充分检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在链表操作函数内部添加空指针检查；2. 确保所有调用者在调用链表操作函数前进行空指针检查；3. 使用断言或日志记录潜在的空指针问题", "verification_notes": "分析结论正确，前置条件合理（链表操作函数确实未进行空指针检查），触发路径成立（多个调用路径中存在空指针风险），后果评估准确（空指针解引用会导致程序崩溃），建议合适（记忆中也提出了类似的改进建议）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "utils/include/doubly_linked_list.h", "line": 48, "evidence": "node->pstPrev = list;", "confidence": 0.6, "severity": "high", "gid": 39, "verify": "验证所有链表操作中对指针的解引用前都进行了空指针检查", "has_risk": true, "preconditions": "传入的链表指针或节点指针为NULL", "trigger_path": "调用路径推导：多个调用路径(如rpc_session_handle.c中的CreateSessionIdNode() -> DLListAdd(), ipc_process_skeleton.c中的AddDeathRecipient() -> DLListAdd()等)。数据流：链表操作函数被多个模块调用，部分调用点未对传入指针进行空指针检查。关键调用点：doubly_linked_list.h中的链表操作函数未进行空指针检查，且部分调用者也未进行充分检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在链表操作函数内部添加空指针检查；2. 确保所有调用者在调用链表操作函数前进行空指针检查；3. 使用断言或日志记录潜在的空指针问题", "verification_notes": "分析结论正确，前置条件合理（链表操作函数确实未进行空指针检查），触发路径成立（多个调用路径中存在空指针风险），后果评估准确（空指针解引用会导致程序崩溃），建议合适（记忆中也提出了类似的改进建议）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "utils/include/doubly_linked_list.h", "line": 49, "evidence": "list->pstNext->pstPrev = node;", "confidence": 0.6, "severity": "high", "gid": 40, "verify": "验证所有链表操作中对指针的解引用前都进行了空指针检查", "has_risk": true, "preconditions": "传入的链表指针或节点指针为NULL", "trigger_path": "调用路径推导：多个调用路径(如rpc_session_handle.c中的CreateSessionIdNode() -> DLListAdd(), ipc_process_skeleton.c中的AddDeathRecipient() -> DLListAdd()等)。数据流：链表操作函数被多个模块调用，部分调用点未对传入指针进行空指针检查。关键调用点：doubly_linked_list.h中的链表操作函数未进行空指针检查，且部分调用者也未进行充分检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在链表操作函数内部添加空指针检查；2. 确保所有调用者在调用链表操作函数前进行空指针检查；3. 使用断言或日志记录潜在的空指针问题", "verification_notes": "分析结论正确，前置条件合理（链表操作函数确实未进行空指针检查），触发路径成立（多个调用路径中存在空指针风险），后果评估准确（空指针解引用会导致程序崩溃），建议合适（记忆中也提出了类似的改进建议）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "utils/include/doubly_linked_list.h", "line": 49, "evidence": "list->pstNext->pstPrev = node;", "confidence": 0.6, "severity": "high", "gid": 41, "verify": "验证所有链表操作中对指针的解引用前都进行了空指针检查", "has_risk": true, "preconditions": "传入的链表指针或节点指针为NULL", "trigger_path": "调用路径推导：多个调用路径(如rpc_session_handle.c中的CreateSessionIdNode() -> DLListAdd(), ipc_process_skeleton.c中的AddDeathRecipient() -> DLListAdd()等)。数据流：链表操作函数被多个模块调用，部分调用点未对传入指针进行空指针检查。关键调用点：doubly_linked_list.h中的链表操作函数未进行空指针检查，且部分调用者也未进行充分检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在链表操作函数内部添加空指针检查；2. 确保所有调用者在调用链表操作函数前进行空指针检查；3. 使用断言或日志记录潜在的空指针问题", "verification_notes": "分析结论正确，前置条件合理（链表操作函数确实未进行空指针检查），触发路径成立（多个调用路径中存在空指针风险），后果评估准确（空指针解引用会导致程序崩溃），建议合适（记忆中也提出了类似的改进建议）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "utils/include/doubly_linked_list.h", "line": 50, "evidence": "list->pstNext = node;", "confidence": 0.6, "severity": "high", "gid": 42, "verify": "验证所有链表操作中对指针的解引用前都进行了空指针检查", "has_risk": true, "preconditions": "传入的链表指针或节点指针为NULL", "trigger_path": "调用路径推导：多个调用路径(如rpc_session_handle.c中的CreateSessionIdNode() -> DLListAdd(), ipc_process_skeleton.c中的AddDeathRecipient() -> DLListAdd()等)。数据流：链表操作函数被多个模块调用，部分调用点未对传入指针进行空指针检查。关键调用点：doubly_linked_list.h中的链表操作函数未进行空指针检查，且部分调用者也未进行充分检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在链表操作函数内部添加空指针检查；2. 确保所有调用者在调用链表操作函数前进行空指针检查；3. 使用断言或日志记录潜在的空指针问题", "verification_notes": "分析结论正确，前置条件合理（链表操作函数确实未进行空指针检查），触发路径成立（多个调用路径中存在空指针风险），后果评估准确（空指针解引用会导致程序崩溃），建议合适（记忆中也提出了类似的改进建议）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "utils/include/doubly_linked_list.h", "line": 56, "evidence": "DLListAdd(list->pstPrev, node);", "confidence": 0.6, "severity": "high", "gid": 43, "verify": "验证所有链表操作中对指针的解引用前都进行了空指针检查", "has_risk": true, "preconditions": "传入的链表指针或节点指针为NULL", "trigger_path": "调用路径推导：多个调用路径(如rpc_session_handle.c中的CreateSessionIdNode() -> DLListAdd(), ipc_process_skeleton.c中的AddDeathRecipient() -> DLListAdd()等)。数据流：链表操作函数被多个模块调用，部分调用点未对传入指针进行空指针检查。关键调用点：doubly_linked_list.h中的链表操作函数未进行空指针检查，且部分调用者也未进行充分检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在链表操作函数内部添加空指针检查；2. 确保所有调用者在调用链表操作函数前进行空指针检查；3. 使用断言或日志记录潜在的空指针问题", "verification_notes": "分析结论正确，前置条件合理（链表操作函数确实未进行空指针检查），触发路径成立（多个调用路径中存在空指针风险），后果评估准确（空指针解引用会导致程序崩溃），建议合适（记忆中也提出了类似的改进建议）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "utils/include/doubly_linked_list.h", "line": 68, "evidence": "node->pstNext->pstPrev = node->pstPrev;", "confidence": 0.6, "severity": "high", "gid": 44, "verify": "验证所有链表操作中对指针的解引用前都进行了空指针检查", "has_risk": true, "preconditions": "传入的链表指针或节点指针为NULL", "trigger_path": "调用路径推导：多个调用路径(如rpc_session_handle.c中的CreateSessionIdNode() -> DLListAdd(), ipc_process_skeleton.c中的AddDeathRecipient() -> DLListAdd()等)。数据流：链表操作函数被多个模块调用，部分调用点未对传入指针进行空指针检查。关键调用点：doubly_linked_list.h中的链表操作函数未进行空指针检查，且部分调用者也未进行充分检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在链表操作函数内部添加空指针检查；2. 确保所有调用者在调用链表操作函数前进行空指针检查；3. 使用断言或日志记录潜在的空指针问题", "verification_notes": "分析结论正确，前置条件合理（链表操作函数确实未进行空指针检查），触发路径成立（多个调用路径中存在空指针风险），后果评估准确（空指针解引用会导致程序崩溃），建议合适（记忆中也提出了类似的改进建议）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "utils/include/doubly_linked_list.h", "line": 68, "evidence": "node->pstNext->pstPrev = node->pstPrev;", "confidence": 0.6, "severity": "high", "gid": 45, "verify": "验证所有链表操作中对指针的解引用前都进行了空指针检查", "has_risk": true, "preconditions": "传入的链表指针或节点指针为NULL", "trigger_path": "调用路径推导：多个调用路径(如rpc_session_handle.c中的CreateSessionIdNode() -> DLListAdd(), ipc_process_skeleton.c中的AddDeathRecipient() -> DLListAdd()等)。数据流：链表操作函数被多个模块调用，部分调用点未对传入指针进行空指针检查。关键调用点：doubly_linked_list.h中的链表操作函数未进行空指针检查，且部分调用者也未进行充分检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在链表操作函数内部添加空指针检查；2. 确保所有调用者在调用链表操作函数前进行空指针检查；3. 使用断言或日志记录潜在的空指针问题", "verification_notes": "分析结论正确，前置条件合理（链表操作函数确实未进行空指针检查），触发路径成立（多个调用路径中存在空指针风险），后果评估准确（空指针解引用会导致程序崩溃），建议合适（记忆中也提出了类似的改进建议）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "utils/include/doubly_linked_list.h", "line": 69, "evidence": "node->pstPrev->pstNext = node->pstNext;", "confidence": 0.6, "severity": "high", "gid": 46, "verify": "验证所有链表操作中对指针的解引用前都进行了空指针检查", "has_risk": true, "preconditions": "传入的链表指针或节点指针为NULL", "trigger_path": "调用路径推导：多个调用路径(如rpc_session_handle.c中的CreateSessionIdNode() -> DLListAdd(), ipc_process_skeleton.c中的AddDeathRecipient() -> DLListAdd()等)。数据流：链表操作函数被多个模块调用，部分调用点未对传入指针进行空指针检查。关键调用点：doubly_linked_list.h中的链表操作函数未进行空指针检查，且部分调用者也未进行充分检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在链表操作函数内部添加空指针检查；2. 确保所有调用者在调用链表操作函数前进行空指针检查；3. 使用断言或日志记录潜在的空指针问题", "verification_notes": "分析结论正确，前置条件合理（链表操作函数确实未进行空指针检查），触发路径成立（多个调用路径中存在空指针风险），后果评估准确（空指针解引用会导致程序崩溃），建议合适（记忆中也提出了类似的改进建议）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "utils/include/doubly_linked_list.h", "line": 69, "evidence": "node->pstPrev->pstNext = node->pstNext;", "confidence": 0.6, "severity": "high", "gid": 47, "verify": "验证所有链表操作中对指针的解引用前都进行了空指针检查", "has_risk": true, "preconditions": "传入的链表指针或节点指针为NULL", "trigger_path": "调用路径推导：多个调用路径(如rpc_session_handle.c中的CreateSessionIdNode() -> DLListAdd(), ipc_process_skeleton.c中的AddDeathRecipient() -> DLListAdd()等)。数据流：链表操作函数被多个模块调用，部分调用点未对传入指针进行空指针检查。关键调用点：doubly_linked_list.h中的链表操作函数未进行空指针检查，且部分调用者也未进行充分检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在链表操作函数内部添加空指针检查；2. 确保所有调用者在调用链表操作函数前进行空指针检查；3. 使用断言或日志记录潜在的空指针问题", "verification_notes": "分析结论正确，前置条件合理（链表操作函数确实未进行空指针检查），触发路径成立（多个调用路径中存在空指针风险），后果评估准确（空指针解引用会导致程序崩溃），建议合适（记忆中也提出了类似的改进建议）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "utils/include/doubly_linked_list.h", "line": 70, "evidence": "node->pstNext = NULL;", "confidence": 0.6, "severity": "high", "gid": 48, "verify": "验证所有链表操作中对指针的解引用前都进行了空指针检查", "has_risk": true, "preconditions": "传入的链表指针或节点指针为NULL", "trigger_path": "调用路径推导：多个调用路径(如rpc_session_handle.c中的CreateSessionIdNode() -> DLListAdd(), ipc_process_skeleton.c中的AddDeathRecipient() -> DLListAdd()等)。数据流：链表操作函数被多个模块调用，部分调用点未对传入指针进行空指针检查。关键调用点：doubly_linked_list.h中的链表操作函数未进行空指针检查，且部分调用者也未进行充分检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在链表操作函数内部添加空指针检查；2. 确保所有调用者在调用链表操作函数前进行空指针检查；3. 使用断言或日志记录潜在的空指针问题", "verification_notes": "分析结论正确，前置条件合理（链表操作函数确实未进行空指针检查），触发路径成立（多个调用路径中存在空指针风险），后果评估准确（空指针解引用会导致程序崩溃），建议合适（记忆中也提出了类似的改进建议）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "utils/include/doubly_linked_list.h", "line": 71, "evidence": "node->pstPrev = NULL;", "confidence": 0.6, "severity": "high", "gid": 49, "verify": "验证所有链表操作中对指针的解引用前都进行了空指针检查", "has_risk": true, "preconditions": "传入的链表指针或节点指针为NULL", "trigger_path": "调用路径推导：多个调用路径(如rpc_session_handle.c中的CreateSessionIdNode() -> DLListAdd(), ipc_process_skeleton.c中的AddDeathRecipient() -> DLListAdd()等)。数据流：链表操作函数被多个模块调用，部分调用点未对传入指针进行空指针检查。关键调用点：doubly_linked_list.h中的链表操作函数未进行空指针检查，且部分调用者也未进行充分检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在链表操作函数内部添加空指针检查；2. 确保所有调用者在调用链表操作函数前进行空指针检查；3. 使用断言或日志记录潜在的空指针问题", "verification_notes": "分析结论正确，前置条件合理（链表操作函数确实未进行空指针检查），触发路径成立（多个调用路径中存在空指针风险），后果评估准确（空指针解引用会导致程序崩溃），建议合适（记忆中也提出了类似的改进建议）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "utils/include/doubly_linked_list.h", "line": 77, "evidence": "return (bool)(list->pstNext == list);", "confidence": 0.6, "severity": "high", "gid": 50, "verify": "验证所有链表操作中对指针的解引用前都进行了空指针检查", "has_risk": true, "preconditions": "传入的链表指针或节点指针为NULL", "trigger_path": "调用路径推导：多个调用路径(如rpc_session_handle.c中的CreateSessionIdNode() -> DLListAdd(), ipc_process_skeleton.c中的AddDeathRecipient() -> DLListAdd()等)。数据流：链表操作函数被多个模块调用，部分调用点未对传入指针进行空指针检查。关键调用点：doubly_linked_list.h中的链表操作函数未进行空指针检查，且部分调用者也未进行充分检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在链表操作函数内部添加空指针检查；2. 确保所有调用者在调用链表操作函数前进行空指针检查；3. 使用断言或日志记录潜在的空指针问题", "verification_notes": "分析结论正确，前置条件合理（链表操作函数确实未进行空指针检查），触发路径成立（多个调用路径中存在空指针风险），后果评估准确（空指针解引用会导致程序崩溃），建议合适（记忆中也提出了类似的改进建议）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "utils/include/doubly_linked_list.h", "line": 103, "evidence": "nextNode->pstPrev = prevNode;", "confidence": 0.6, "severity": "high", "gid": 51, "verify": "验证所有链表操作中对指针的解引用前都进行了空指针检查", "has_risk": true, "preconditions": "传入的链表指针或节点指针为NULL", "trigger_path": "调用路径推导：多个调用路径(如rpc_session_handle.c中的CreateSessionIdNode() -> DLListAdd(), ipc_process_skeleton.c中的AddDeathRecipient() -> DLListAdd()等)。数据流：链表操作函数被多个模块调用，部分调用点未对传入指针进行空指针检查。关键调用点：doubly_linked_list.h中的链表操作函数未进行空指针检查，且部分调用者也未进行充分检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在链表操作函数内部添加空指针检查；2. 确保所有调用者在调用链表操作函数前进行空指针检查；3. 使用断言或日志记录潜在的空指针问题", "verification_notes": "分析结论正确，前置条件合理（链表操作函数确实未进行空指针检查），触发路径成立（多个调用路径中存在空指针风险），后果评估准确（空指针解引用会导致程序崩溃），建议合适（记忆中也提出了类似的改进建议）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "utils/include/doubly_linked_list.h", "line": 104, "evidence": "prevNode->pstNext = nextNode;", "confidence": 0.6, "severity": "high", "gid": 52, "verify": "验证所有链表操作中对指针的解引用前都进行了空指针检查", "has_risk": true, "preconditions": "传入的链表指针或节点指针为NULL", "trigger_path": "调用路径推导：多个调用路径(如rpc_session_handle.c中的CreateSessionIdNode() -> DLListAdd(), ipc_process_skeleton.c中的AddDeathRecipient() -> DLListAdd()等)。数据流：链表操作函数被多个模块调用，部分调用点未对传入指针进行空指针检查。关键调用点：doubly_linked_list.h中的链表操作函数未进行空指针检查，且部分调用者也未进行充分检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在链表操作函数内部添加空指针检查；2. 确保所有调用者在调用链表操作函数前进行空指针检查；3. 使用断言或日志记录潜在的空指针问题", "verification_notes": "分析结论正确，前置条件合理（链表操作函数确实未进行空指针检查），触发路径成立（多个调用路径中存在空指针风险），后果评估准确（空指针解引用会导致程序崩溃），建议合适（记忆中也提出了类似的改进建议）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "utils/include/doubly_linked_list.h", "line": 110, "evidence": "DLListDel(list->pstPrev, list->pstNext);", "confidence": 0.6, "severity": "high", "gid": 53, "verify": "验证所有链表操作中对指针的解引用前都进行了空指针检查", "has_risk": true, "preconditions": "传入的链表指针或节点指针为NULL", "trigger_path": "调用路径推导：多个调用路径(如rpc_session_handle.c中的CreateSessionIdNode() -> DLListAdd(), ipc_process_skeleton.c中的AddDeathRecipient() -> DLListAdd()等)。数据流：链表操作函数被多个模块调用，部分调用点未对传入指针进行空指针检查。关键调用点：doubly_linked_list.h中的链表操作函数未进行空指针检查，且部分调用者也未进行充分检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在链表操作函数内部添加空指针检查；2. 确保所有调用者在调用链表操作函数前进行空指针检查；3. 使用断言或日志记录潜在的空指针问题", "verification_notes": "分析结论正确，前置条件合理（链表操作函数确实未进行空指针检查），触发路径成立（多个调用路径中存在空指针风险），后果评估准确（空指针解引用会导致程序崩溃），建议合适（记忆中也提出了类似的改进建议）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 159, "evidence": "data->bufferBase = data->bufferCur = (char *)tr->data.ptr.buffer;", "confidence": 0.6, "severity": "high", "gid": 124, "verify": "验证tr指针在访问前非空", "has_risk": true, "preconditions": "传入的tr指针为NULL", "trigger_path": "调用路径推导：binder驱动 -> HandleTransaction() -> ToIpcData()。数据流：binder驱动传递的transaction数据通过HandleTransaction()处理，直接传递给ToIpcData()函数。关键调用点：HandleTransaction()函数未对tr指针进行NULL检查。", "consequences": "NULL指针解引用，可能导致程序崩溃", "suggestions": "在ToIpcData()函数入口处添加tr指针的NULL检查，或确保调用者不会传入NULL指针", "verification_notes": "分析结论正确，ToIpcData函数确实存在NULL指针解引用风险，前置条件合理，触发路径清晰（binder驱动->HandleTransaction->ToIpcData），后果评估准确（NULL解引用会导致程序崩溃），建议在函数入口添加NULL检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 159, "evidence": "data->bufferBase = data->bufferCur = (char *)tr->data.ptr.buffer;", "confidence": 0.6, "severity": "high", "gid": 125, "verify": "验证tr指针在访问前非空", "has_risk": true, "preconditions": "传入的tr指针为NULL", "trigger_path": "调用路径推导：binder驱动 -> HandleTransaction() -> ToIpcData()。数据流：binder驱动传递的transaction数据通过HandleTransaction()处理，直接传递给ToIpcData()函数。关键调用点：HandleTransaction()函数未对tr指针进行NULL检查。", "consequences": "NULL指针解引用，可能导致程序崩溃", "suggestions": "在ToIpcData()函数入口处添加tr指针的NULL检查，或确保调用者不会传入NULL指针", "verification_notes": "分析结论正确，ToIpcData函数确实存在NULL指针解引用风险，前置条件合理，触发路径清晰（binder驱动->HandleTransaction->ToIpcData），后果评估准确（NULL解引用会导致程序崩溃），建议在函数入口添加NULL检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 160, "evidence": "data->bufferLeft = (size_t)tr->data_size;", "confidence": 0.6, "severity": "high", "gid": 126, "verify": "验证tr指针在访问前非空", "has_risk": true, "preconditions": "传入的tr指针为NULL", "trigger_path": "调用路径推导：binder驱动 -> HandleTransaction() -> ToIpcData()。数据流：binder驱动传递的transaction数据通过HandleTransaction()处理，直接传递给ToIpcData()函数。关键调用点：HandleTransaction()函数未对tr指针进行NULL检查。", "consequences": "NULL指针解引用，可能导致程序崩溃", "suggestions": "在ToIpcData()函数入口处添加tr指针的NULL检查，或确保调用者不会传入NULL指针", "verification_notes": "分析结论正确，ToIpcData函数确实存在NULL指针解引用风险，前置条件合理，触发路径清晰（binder驱动->HandleTransaction->ToIpcData），后果评估准确（NULL解引用会导致程序崩溃），建议在函数入口添加NULL检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 160, "evidence": "data->bufferLeft = (size_t)tr->data_size;", "confidence": 0.6, "severity": "high", "gid": 127, "verify": "验证tr指针在访问前非空", "has_risk": true, "preconditions": "传入的tr指针为NULL", "trigger_path": "调用路径推导：binder驱动 -> HandleTransaction() -> ToIpcData()。数据流：binder驱动传递的transaction数据通过HandleTransaction()处理，直接传递给ToIpcData()函数。关键调用点：HandleTransaction()函数未对tr指针进行NULL检查。", "consequences": "NULL指针解引用，可能导致程序崩溃", "suggestions": "在ToIpcData()函数入口处添加tr指针的NULL检查，或确保调用者不会传入NULL指针", "verification_notes": "分析结论正确，ToIpcData函数确实存在NULL指针解引用风险，前置条件合理，触发路径清晰（binder驱动->HandleTransaction->ToIpcData），后果评估准确（NULL解引用会导致程序崩溃），建议在函数入口添加NULL检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 161, "evidence": "data->offsetsBase = data->offsetsCur = (size_t *)tr->data.ptr.offsets;", "confidence": 0.6, "severity": "high", "gid": 128, "verify": "验证tr指针在访问前非空", "has_risk": true, "preconditions": "传入的tr指针为NULL", "trigger_path": "调用路径推导：binder驱动 -> HandleTransaction() -> ToIpcData()。数据流：binder驱动传递的transaction数据通过HandleTransaction()处理，直接传递给ToIpcData()函数。关键调用点：HandleTransaction()函数未对tr指针进行NULL检查。", "consequences": "NULL指针解引用，可能导致程序崩溃", "suggestions": "在ToIpcData()函数入口处添加tr指针的NULL检查，或确保调用者不会传入NULL指针", "verification_notes": "分析结论正确，ToIpcData函数确实存在NULL指针解引用风险，前置条件合理，触发路径清晰（binder驱动->HandleTransaction->ToIpcData），后果评估准确（NULL解引用会导致程序崩溃），建议在函数入口添加NULL检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 161, "evidence": "data->offsetsBase = data->offsetsCur = (size_t *)tr->data.ptr.offsets;", "confidence": 0.6, "severity": "high", "gid": 129, "verify": "验证tr指针在访问前非空", "has_risk": true, "preconditions": "传入的tr指针为NULL", "trigger_path": "调用路径推导：binder驱动 -> HandleTransaction() -> ToIpcData()。数据流：binder驱动传递的transaction数据通过HandleTransaction()处理，直接传递给ToIpcData()函数。关键调用点：HandleTransaction()函数未对tr指针进行NULL检查。", "consequences": "NULL指针解引用，可能导致程序崩溃", "suggestions": "在ToIpcData()函数入口处添加tr指针的NULL检查，或确保调用者不会传入NULL指针", "verification_notes": "分析结论正确，ToIpcData函数确实存在NULL指针解引用风险，前置条件合理，触发路径清晰（binder驱动->HandleTransaction->ToIpcData），后果评估准确（NULL解引用会导致程序崩溃），建议在函数入口添加NULL检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 162, "evidence": "data->offsetsLeft = (tr->offsets_size) / sizeof(binder_size_t);", "confidence": 0.6, "severity": "high", "gid": 130, "verify": "验证tr指针在访问前非空", "has_risk": true, "preconditions": "传入的tr指针为NULL", "trigger_path": "调用路径推导：binder驱动 -> HandleTransaction() -> ToIpcData()。数据流：binder驱动传递的transaction数据通过HandleTransaction()处理，直接传递给ToIpcData()函数。关键调用点：HandleTransaction()函数未对tr指针进行NULL检查。", "consequences": "NULL指针解引用，可能导致程序崩溃", "suggestions": "在ToIpcData()函数入口处添加tr指针的NULL检查，或确保调用者不会传入NULL指针", "verification_notes": "分析结论正确，ToIpcData函数确实存在NULL指针解引用风险，前置条件合理，触发路径清晰（binder驱动->HandleTransaction->ToIpcData），后果评估准确（NULL解引用会导致程序崩溃），建议在函数入口添加NULL检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 162, "evidence": "data->offsetsLeft = (tr->offsets_size) / sizeof(binder_size_t);", "confidence": 0.6, "severity": "high", "gid": 131, "verify": "验证tr指针在访问前非空", "has_risk": true, "preconditions": "传入的tr指针为NULL", "trigger_path": "调用路径推导：binder驱动 -> HandleTransaction() -> ToIpcData()。数据流：binder驱动传递的transaction数据通过HandleTransaction()处理，直接传递给ToIpcData()函数。关键调用点：HandleTransaction()函数未对tr指针进行NULL检查。", "consequences": "NULL指针解引用，可能导致程序崩溃", "suggestions": "在ToIpcData()函数入口处添加tr指针的NULL检查，或确保调用者不会传入NULL指针", "verification_notes": "分析结论正确，ToIpcData函数确实存在NULL指针解引用风险，前置条件合理，触发路径清晰（binder驱动->HandleTransaction->ToIpcData），后果评估准确（NULL解引用会导致程序崩溃），建议在函数入口添加NULL检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 159, "evidence": "data->bufferBase = data->bufferCur = (char *)tr->data.ptr.buffer;", "confidence": 0.6, "severity": "high", "gid": 124, "verify": "验证tr指针在访问前非空", "has_risk": true, "preconditions": "传入的tr指针为NULL", "trigger_path": "调用路径推导：BinderRead() -> HandleTransaction()/HandleReply() -> ToIpcData()。数据流：binder驱动通过BinderRead()接收数据，传递给HandleTransaction()或HandleReply()处理，这两个函数未对tr指针进行空指针检查，直接传递给ToIpcData()使用。关键调用点：HandleTransaction()和HandleReply()函数未对tr指针进行空指针校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在HandleTransaction()和HandleReply()函数中对tr指针进行空指针检查，或在ToIpcData()函数入口处添加空指针检查", "verification_notes": "分析结论正确，代码确实存在tr指针为NULL的风险场景，调用路径成立且后果评估准确，建议的防护措施合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 159, "evidence": "data->bufferBase = data->bufferCur = (char *)tr->data.ptr.buffer;", "confidence": 0.6, "severity": "high", "gid": 125, "verify": "验证tr指针在访问前非空", "has_risk": true, "preconditions": "传入的tr指针为NULL", "trigger_path": "调用路径推导：BinderRead() -> HandleTransaction()/HandleReply() -> ToIpcData()。数据流：binder驱动通过BinderRead()接收数据，传递给HandleTransaction()或HandleReply()处理，这两个函数未对tr指针进行空指针检查，直接传递给ToIpcData()使用。关键调用点：HandleTransaction()和HandleReply()函数未对tr指针进行空指针校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在HandleTransaction()和HandleReply()函数中对tr指针进行空指针检查，或在ToIpcData()函数入口处添加空指针检查", "verification_notes": "分析结论正确，代码确实存在tr指针为NULL的风险场景，调用路径成立且后果评估准确，建议的防护措施合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 160, "evidence": "data->bufferLeft = (size_t)tr->data_size;", "confidence": 0.6, "severity": "high", "gid": 126, "verify": "验证tr指针在访问前非空", "has_risk": true, "preconditions": "传入的tr指针为NULL", "trigger_path": "调用路径推导：BinderRead() -> HandleTransaction()/HandleReply() -> ToIpcData()。数据流：binder驱动通过BinderRead()接收数据，传递给HandleTransaction()或HandleReply()处理，这两个函数未对tr指针进行空指针检查，直接传递给ToIpcData()使用。关键调用点：HandleTransaction()和HandleReply()函数未对tr指针进行空指针校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在HandleTransaction()和HandleReply()函数中对tr指针进行空指针检查，或在ToIpcData()函数入口处添加空指针检查", "verification_notes": "分析结论正确，代码确实存在tr指针为NULL的风险场景，调用路径成立且后果评估准确，建议的防护措施合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 160, "evidence": "data->bufferLeft = (size_t)tr->data_size;", "confidence": 0.6, "severity": "high", "gid": 127, "verify": "验证tr指针在访问前非空", "has_risk": true, "preconditions": "传入的tr指针为NULL", "trigger_path": "调用路径推导：BinderRead() -> HandleTransaction()/HandleReply() -> ToIpcData()。数据流：binder驱动通过BinderRead()接收数据，传递给HandleTransaction()或HandleReply()处理，这两个函数未对tr指针进行空指针检查，直接传递给ToIpcData()使用。关键调用点：HandleTransaction()和HandleReply()函数未对tr指针进行空指针校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在HandleTransaction()和HandleReply()函数中对tr指针进行空指针检查，或在ToIpcData()函数入口处添加空指针检查", "verification_notes": "分析结论正确，代码确实存在tr指针为NULL的风险场景，调用路径成立且后果评估准确，建议的防护措施合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 161, "evidence": "data->offsetsBase = data->offsetsCur = (size_t *)tr->data.ptr.offsets;", "confidence": 0.6, "severity": "high", "gid": 128, "verify": "验证tr指针在访问前非空", "has_risk": true, "preconditions": "传入的tr指针为NULL", "trigger_path": "调用路径推导：BinderRead() -> HandleTransaction()/HandleReply() -> ToIpcData()。数据流：binder驱动通过BinderRead()接收数据，传递给HandleTransaction()或HandleReply()处理，这两个函数未对tr指针进行空指针检查，直接传递给ToIpcData()使用。关键调用点：HandleTransaction()和HandleReply()函数未对tr指针进行空指针校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在HandleTransaction()和HandleReply()函数中对tr指针进行空指针检查，或在ToIpcData()函数入口处添加空指针检查", "verification_notes": "分析结论正确，代码确实存在tr指针为NULL的风险场景，调用路径成立且后果评估准确，建议的防护措施合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 161, "evidence": "data->offsetsBase = data->offsetsCur = (size_t *)tr->data.ptr.offsets;", "confidence": 0.6, "severity": "high", "gid": 129, "verify": "验证tr指针在访问前非空", "has_risk": true, "preconditions": "传入的tr指针为NULL", "trigger_path": "调用路径推导：BinderRead() -> HandleTransaction()/HandleReply() -> ToIpcData()。数据流：binder驱动通过BinderRead()接收数据，传递给HandleTransaction()或HandleReply()处理，这两个函数未对tr指针进行空指针检查，直接传递给ToIpcData()使用。关键调用点：HandleTransaction()和HandleReply()函数未对tr指针进行空指针校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在HandleTransaction()和HandleReply()函数中对tr指针进行空指针检查，或在ToIpcData()函数入口处添加空指针检查", "verification_notes": "分析结论正确，代码确实存在tr指针为NULL的风险场景，调用路径成立且后果评估准确，建议的防护措施合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 162, "evidence": "data->offsetsLeft = (tr->offsets_size) / sizeof(binder_size_t);", "confidence": 0.6, "severity": "high", "gid": 130, "verify": "验证tr指针在访问前非空", "has_risk": true, "preconditions": "传入的tr指针为NULL", "trigger_path": "调用路径推导：BinderRead() -> HandleTransaction()/HandleReply() -> ToIpcData()。数据流：binder驱动通过BinderRead()接收数据，传递给HandleTransaction()或HandleReply()处理，这两个函数未对tr指针进行空指针检查，直接传递给ToIpcData()使用。关键调用点：HandleTransaction()和HandleReply()函数未对tr指针进行空指针校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在HandleTransaction()和HandleReply()函数中对tr指针进行空指针检查，或在ToIpcData()函数入口处添加空指针检查", "verification_notes": "分析结论正确，代码确实存在tr指针为NULL的风险场景，调用路径成立且后果评估准确，建议的防护措施合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 162, "evidence": "data->offsetsLeft = (tr->offsets_size) / sizeof(binder_size_t);", "confidence": 0.6, "severity": "high", "gid": 131, "verify": "验证tr指针在访问前非空", "has_risk": true, "preconditions": "传入的tr指针为NULL", "trigger_path": "调用路径推导：BinderRead() -> HandleTransaction()/HandleReply() -> ToIpcData()。数据流：binder驱动通过BinderRead()接收数据，传递给HandleTransaction()或HandleReply()处理，这两个函数未对tr指针进行空指针检查，直接传递给ToIpcData()使用。关键调用点：HandleTransaction()和HandleReply()函数未对tr指针进行空指针校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在HandleTransaction()和HandleReply()函数中对tr指针进行空指针检查，或在ToIpcData()函数入口处添加空指针检查", "verification_notes": "分析结论正确，代码确实存在tr指针为NULL的风险场景，调用路径成立且后果评估准确，建议的防护措施合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 223, "evidence": "threadContext->callerPid = tr->sender_pid;", "confidence": 0.6, "severity": "high", "gid": 138, "verify": "验证tr指针在访问前非空", "has_risk": true, "preconditions": "传入的tr指针为NULL", "trigger_path": "调用路径推导：BinderRead() -> HandleTransaction()/HandleReply() -> ToIpcData()。数据流：binder驱动通过BinderRead()接收数据，传递给HandleTransaction()或HandleReply()处理，这两个函数未对tr指针进行空指针检查，直接传递给ToIpcData()使用。关键调用点：HandleTransaction()和HandleReply()函数未对tr指针进行空指针校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在HandleTransaction()和HandleReply()函数中对tr指针进行空指针检查，或在ToIpcData()函数入口处添加空指针检查", "verification_notes": "分析结论正确，代码确实存在tr指针为NULL的风险场景，调用路径成立且后果评估准确，建议的防护措施合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 223, "evidence": "threadContext->callerPid = tr->sender_pid;", "confidence": 0.6, "severity": "high", "gid": 139, "verify": "验证tr指针在访问前非空", "has_risk": true, "preconditions": "传入的tr指针为NULL", "trigger_path": "调用路径推导：BinderRead() -> HandleTransaction()/HandleReply() -> ToIpcData()。数据流：binder驱动通过BinderRead()接收数据，传递给HandleTransaction()或HandleReply()处理，这两个函数未对tr指针进行空指针检查，直接传递给ToIpcData()使用。关键调用点：HandleTransaction()和HandleReply()函数未对tr指针进行空指针校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在HandleTransaction()和HandleReply()函数中对tr指针进行空指针检查，或在ToIpcData()函数入口处添加空指针检查", "verification_notes": "分析结论正确，代码确实存在tr指针为NULL的风险场景，调用路径成立且后果评估准确，建议的防护措施合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 224, "evidence": "threadContext->callerUid = (pid_t)tr->sender_euid;", "confidence": 0.6, "severity": "high", "gid": 140, "verify": "验证tr指针在访问前非空", "has_risk": true, "preconditions": "传入的tr指针为NULL", "trigger_path": "调用路径推导：BinderRead() -> HandleTransaction()/HandleReply() -> ToIpcData()。数据流：binder驱动通过BinderRead()接收数据，传递给HandleTransaction()或HandleReply()处理，这两个函数未对tr指针进行空指针检查，直接传递给ToIpcData()使用。关键调用点：HandleTransaction()和HandleReply()函数未对tr指针进行空指针校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在HandleTransaction()和HandleReply()函数中对tr指针进行空指针检查，或在ToIpcData()函数入口处添加空指针检查", "verification_notes": "分析结论正确，代码确实存在tr指针为NULL的风险场景，调用路径成立且后果评估准确，建议的防护措施合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 224, "evidence": "threadContext->callerUid = (pid_t)tr->sender_euid;", "confidence": 0.6, "severity": "high", "gid": 141, "verify": "验证tr指针在访问前非空", "has_risk": true, "preconditions": "传入的tr指针为NULL", "trigger_path": "调用路径推导：BinderRead() -> HandleTransaction()/HandleReply() -> ToIpcData()。数据流：binder驱动通过BinderRead()接收数据，传递给HandleTransaction()或HandleReply()处理，这两个函数未对tr指针进行空指针检查，直接传递给ToIpcData()使用。关键调用点：HandleTransaction()和HandleReply()函数未对tr指针进行空指针校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在HandleTransaction()和HandleReply()函数中对tr指针进行空指针检查，或在ToIpcData()函数入口处添加空指针检查", "verification_notes": "分析结论正确，代码确实存在tr指针为NULL的风险场景，调用路径成立且后果评估准确，建议的防护措施合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 227, "evidence": "objectStub = (IpcObjectStub *)tr->cookie;", "confidence": 0.6, "severity": "high", "gid": 143, "verify": "验证tr指针在访问前非空", "has_risk": true, "preconditions": "传入的tr指针为NULL", "trigger_path": "调用路径推导：BinderRead() -> HandleTransaction()/HandleReply() -> ToIpcData()。数据流：binder驱动通过BinderRead()接收数据，传递给HandleTransaction()或HandleReply()处理，这两个函数未对tr指针进行空指针检查，直接传递给ToIpcData()使用。关键调用点：HandleTransaction()和HandleReply()函数未对tr指针进行空指针校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在HandleTransaction()和HandleReply()函数中对tr指针进行空指针检查，或在ToIpcData()函数入口处添加空指针检查", "verification_notes": "分析结论正确，代码确实存在tr指针为NULL的风险场景，调用路径成立且后果评估准确，建议的防护措施合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 235, "evidence": ".flags = tr->flags,", "confidence": 0.6, "severity": "high", "gid": 145, "verify": "验证tr指针在访问前非空", "has_risk": true, "preconditions": "传入的tr指针为NULL", "trigger_path": "调用路径推导：BinderRead() -> HandleTransaction()/HandleReply() -> ToIpcData()。数据流：binder驱动通过BinderRead()接收数据，传递给HandleTransaction()或HandleReply()处理，这两个函数未对tr指针进行空指针检查，直接传递给ToIpcData()使用。关键调用点：HandleTransaction()和HandleReply()函数未对tr指针进行空指针校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在HandleTransaction()和HandleReply()函数中对tr指针进行空指针检查，或在ToIpcData()函数入口处添加空指针检查", "verification_notes": "分析结论正确，代码确实存在tr指针为NULL的风险场景，调用路径成立且后果评估准确，建议的防护措施合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 241, "evidence": "int32_t error = OnRemoteRequestInner(tr->code, &data, &reply, option, objectStub);", "confidence": 0.6, "severity": "high", "gid": 147, "verify": "验证tr指针在访问前非空", "has_risk": true, "preconditions": "传入的tr指针为NULL", "trigger_path": "调用路径推导：BinderRead() -> HandleTransaction()/HandleReply() -> ToIpcData()。数据流：binder驱动通过BinderRead()接收数据，传递给HandleTransaction()或HandleReply()处理，这两个函数未对tr指针进行空指针检查，直接传递给ToIpcData()使用。关键调用点：HandleTransaction()和HandleReply()函数未对tr指针进行空指针校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在HandleTransaction()和HandleReply()函数中对tr指针进行空指针检查，或在ToIpcData()函数入口处添加空指针检查", "verification_notes": "分析结论正确，代码确实存在tr指针为NULL的风险场景，调用路径成立且后果评估准确，建议的防护措施合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 242, "evidence": "if (tr->flags & TF_ONE_WAY) {", "confidence": 0.6, "severity": "high", "gid": 148, "verify": "验证tr指针在访问前非空", "has_risk": true, "preconditions": "传入的tr指针为NULL", "trigger_path": "调用路径推导：BinderRead() -> HandleTransaction()/HandleReply() -> ToIpcData()。数据流：binder驱动通过BinderRead()接收数据，传递给HandleTransaction()或HandleReply()处理，这两个函数未对tr指针进行空指针检查，直接传递给ToIpcData()使用。关键调用点：HandleTransaction()和HandleReply()函数未对tr指针进行空指针校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在HandleTransaction()和HandleReply()函数中对tr指针进行空指针检查，或在ToIpcData()函数入口处添加空指针检查", "verification_notes": "分析结论正确，代码确实存在tr指针为NULL的风险场景，调用路径成立且后果评估准确，建议的防护措施合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 243, "evidence": "IpcFreeBuffer((void *)(tr->data.ptr.buffer));", "confidence": 0.6, "severity": "high", "gid": 149, "verify": "验证tr指针在访问前非空", "has_risk": true, "preconditions": "传入的tr指针为NULL", "trigger_path": "调用路径推导：BinderRead() -> HandleTransaction()/HandleReply() -> ToIpcData()。数据流：binder驱动通过BinderRead()接收数据，传递给HandleTransaction()或HandleReply()处理，这两个函数未对tr指针进行空指针检查，直接传递给ToIpcData()使用。关键调用点：HandleTransaction()和HandleReply()函数未对tr指针进行空指针校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在HandleTransaction()和HandleReply()函数中对tr指针进行空指针检查，或在ToIpcData()函数入口处添加空指针检查", "verification_notes": "分析结论正确，代码确实存在tr指针为NULL的风险场景，调用路径成立且后果评估准确，建议的防护措施合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 114, "evidence": "res = ioctl(g_connector->fd, BINDER_WRITE_READ, &bwr);", "confidence": 0.6, "severity": "high", "gid": 108, "verify": "验证g_connector->fd在ioctl调用前非空", "has_risk": true, "preconditions": "g_connector未被正确初始化或已被释放", "trigger_path": "调用路径推导：全局变量g_connector初始化为NULL -> 任何调用BinderWrite的函数（如AcquireHandle/ReleaseHandle） -> BinderWrite() -> ioctl(g_connector->fd)。数据流：全局变量g_connector可能未被初始化或已被释放，BinderWrite函数直接使用g_connector->fd而未检查其是否为NULL。关键调用点：BinderWrite函数未对g_connector进行空指针检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在BinderWrite函数开头添加g_connector的空指针检查，或确保所有调用路径前g_connector已被正确初始化", "verification_notes": "分析结论正确，g_connector确实存在未初始化风险，BinderWrite函数未进行空指针检查，触发路径清晰，后果评估准确，建议合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 374, "evidence": "ret = ioctl(g_connector->fd, BINDER_WRITE_READ, &bwr);", "confidence": 0.6, "severity": "high", "gid": 162, "verify": "g_connector指针在使用前非空", "has_risk": true, "preconditions": "g_connector指针未被正确初始化或已被释放", "trigger_path": "调用路径推导：InitBinderConnector()初始化g_connector -> 通过g_ipcInvoker结构体调用IpcJoinThread()/IpcExitCurrentThread()。数据流：全局变量g_connector在InitBinderConnector()中初始化，但IpcJoinThread()和IpcExitCurrentThread()函数直接使用g_connector->fd而未进行判空检查。关键调用点：调用者可能未确保g_connector已初始化就直接调用这些函数。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "1. 在IpcJoinThread()和IpcExitCurrentThread()函数开头添加g_connector判空检查；2. 确保所有调用路径都先调用InitBinderConnector()初始化g_connector", "verification_notes": "分析结论正确，g_connector指针确实存在未初始化风险，IpcJoinThread和IpcExitCurrentThread函数缺少判空检查，可能导致空指针解引用崩溃，建议添加判空检查合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 530, "evidence": "ioctl(g_connector->fd, BINDER_THREAD_EXIT, 0);", "confidence": 0.6, "severity": "high", "gid": 179, "verify": "g_connector指针在使用前非空", "has_risk": true, "preconditions": "g_connector指针未被正确初始化或已被释放", "trigger_path": "调用路径推导：InitBinderConnector()初始化g_connector -> 通过g_ipcInvoker结构体调用IpcJoinThread()/IpcExitCurrentThread()。数据流：全局变量g_connector在InitBinderConnector()中初始化，但IpcJoinThread()和IpcExitCurrentThread()函数直接使用g_connector->fd而未进行判空检查。关键调用点：调用者可能未确保g_connector已初始化就直接调用这些函数。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "1. 在IpcJoinThread()和IpcExitCurrentThread()函数开头添加g_connector判空检查；2. 确保所有调用路径都先调用InitBinderConnector()初始化g_connector", "verification_notes": "分析结论正确，g_connector指针确实存在未初始化风险，IpcJoinThread和IpcExitCurrentThread函数缺少判空检查，可能导致空指针解引用崩溃，建议添加判空检查合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 245, "evidence": "IpcFreeBuffer((void *)(tr->data.ptr.buffer));", "confidence": 0.6, "severity": "high", "gid": 150, "verify": "tr指针及其data.ptr.buffer成员在使用前非空", "has_risk": true, "preconditions": "传入的 binder_transaction_data 结构体指针 tr 为 NULL 或 tr->data.ptr.buffer 为 NULL", "trigger_path": "调用路径推导：Binder驱动 -> HandleTransaction()/HandleReply() -> 缺陷代码。数据流：Binder驱动传递的tr参数直接用于解引用。关键调用点：HandleTransaction()和HandleReply()函数均未对tr参数进行空指针检查，也未检查tr->data.ptr.buffer的有效性。", "consequences": "空指针解引用可能导致程序崩溃或拒绝服务", "suggestions": "在HandleTransaction()和HandleReply()函数开头添加tr参数的非空检查，并检查tr->data.ptr.buffer的有效性", "verification_notes": "分析结论正确，前置条件合理（需要检查tr及tr->data.ptr.buffer为NULL的情况），触发路径清晰（Binder驱动直接传递tr参数），后果评估准确（空指针解引用会导致崩溃），建议合适（应添加非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 256, "evidence": "IpcFreeBuffer((void *)(tr->data.ptr.buffer));", "confidence": 0.6, "severity": "high", "gid": 153, "verify": "tr指针及其data.ptr.buffer成员在使用前非空", "has_risk": true, "preconditions": "传入的 binder_transaction_data 结构体指针 tr 为 NULL 或 tr->data.ptr.buffer 为 NULL", "trigger_path": "调用路径推导：Binder驱动 -> HandleTransaction()/HandleReply() -> 缺陷代码。数据流：Binder驱动传递的tr参数直接用于解引用。关键调用点：HandleTransaction()和HandleReply()函数均未对tr参数进行空指针检查，也未检查tr->data.ptr.buffer的有效性。", "consequences": "空指针解引用可能导致程序崩溃或拒绝服务", "suggestions": "在HandleTransaction()和HandleReply()函数开头添加tr参数的非空检查，并检查tr->data.ptr.buffer的有效性", "verification_notes": "分析结论正确，前置条件合理（需要检查tr及tr->data.ptr.buffer为NULL的情况），触发路径清晰（Binder驱动直接传递tr参数），后果评估准确（空指针解引用会导致崩溃），建议合适（应添加非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 260, "evidence": "*buffer = (uintptr_t)tr->data.ptr.buffer;", "confidence": 0.6, "severity": "high", "gid": 154, "verify": "tr指针及其data.ptr.buffer成员在使用前非空", "has_risk": true, "preconditions": "传入的 binder_transaction_data 结构体指针 tr 为 NULL 或 tr->data.ptr.buffer 为 NULL", "trigger_path": "调用路径推导：Binder驱动 -> HandleTransaction()/HandleReply() -> 缺陷代码。数据流：Binder驱动传递的tr参数直接用于解引用。关键调用点：HandleTransaction()和HandleReply()函数均未对tr参数进行空指针检查，也未检查tr->data.ptr.buffer的有效性。", "consequences": "空指针解引用可能导致程序崩溃或拒绝服务", "suggestions": "在HandleTransaction()和HandleReply()函数开头添加tr参数的非空检查，并检查tr->data.ptr.buffer的有效性", "verification_notes": "分析结论正确，前置条件合理（需要检查tr及tr->data.ptr.buffer为NULL的情况），触发路径清晰（Binder驱动直接传递tr参数），后果评估准确（空指针解引用会导致崩溃），建议合适（应添加非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/linux/ipc_invoker.c", "line": 260, "evidence": "*buffer = (uintptr_t)tr->data.ptr.buffer;", "confidence": 0.6, "severity": "high", "gid": 155, "verify": "tr指针及其data.ptr.buffer成员在使用前非空", "has_risk": true, "preconditions": "传入的 binder_transaction_data 结构体指针 tr 为 NULL 或 tr->data.ptr.buffer 为 NULL", "trigger_path": "调用路径推导：Binder驱动 -> HandleTransaction()/HandleReply() -> 缺陷代码。数据流：Binder驱动传递的tr参数直接用于解引用。关键调用点：HandleTransaction()和HandleReply()函数均未对tr参数进行空指针检查，也未检查tr->data.ptr.buffer的有效性。", "consequences": "空指针解引用可能导致程序崩溃或拒绝服务", "suggestions": "在HandleTransaction()和HandleReply()函数开头添加tr参数的非空检查，并检查tr->data.ptr.buffer的有效性", "verification_notes": "分析结论正确，前置条件合理（需要检查tr及tr->data.ptr.buffer为NULL的情况），触发路径清晰（Binder驱动直接传递tr参数），后果评估准确（空指针解引用会导致崩溃），建议合适（应添加非空检查）"}
{"language": "c/cpp", "category": "resource_leak", "pattern": "thread_leak_no_join", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 409, "evidence": "ret = pthread_create(&tid, NULL, CallbackBatchHandler, tArg);", "confidence": 0.6, "severity": "medium", "gid": 228, "verify": "检查线程是否在所有路径上都被正确join", "has_risk": true, "preconditions": "CallbackDispatchLoop函数持续运行且创建线程成功", "trigger_path": "调用路径推导：CallbackDispatchLoop() -> pthread_create()。数据流：在CallbackDispatchLoop的无限循环中，每次处理IPC消息时会创建新线程(CallbackBatchHandler)，但未在任何路径上join该线程。关键调用点：CallbackDispatchLoop函数未对创建的线程进行join操作。", "consequences": "线程资源泄漏，可能导致系统资源耗尽", "suggestions": "1) 跟踪创建的线程ID并适时join；或2) 将线程设置为PTHREAD_CREATE_DETACHED状态", "verification_notes": "分析结论正确，CallbackDispatchLoop确实会创建未join的线程，存在资源泄漏风险，建议的解决方案合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 287, "evidence": "for (uint32_t i = 0; i < hdlerArg->num; i++) {", "confidence": 0.6, "severity": "high", "gid": 273, "verify": "检查hdlerArg指针是否非空", "has_risk": true, "preconditions": "hdlerArg指针为NULL", "trigger_path": "调用路径推导：pthread_create() -> CallbackBatchHandler() -> CallIpcCallback()。数据流：tArg/hdlerArg指针通过pthread_create传递给CallbackBatchHandler，再传递给CallIpcCallback。关键调用点：pthread_create调用前仅检查了tArg->num是否为0，未检查tArg/hdlerArg指针本身是否为NULL。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在pthread_create调用前添加对tArg/hdlerArg指针的NULL检查", "verification_notes": "分析结论正确，代码中确实存在空指针解引用风险。CallbackBatchHandler和CallIpcCallback函数中未对hdlerArg指针进行NULL检查，而该指针通过pthread_create传递。触发路径分析准确，后果评估合理，建议在pthread_create调用前添加NULL检查是合适的解决方案。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 288, "evidence": "if (hdlerArg->useFlag == false) {", "confidence": 0.6, "severity": "high", "gid": 274, "verify": "检查hdlerArg指针是否非空", "has_risk": true, "preconditions": "hdlerArg指针为NULL", "trigger_path": "调用路径推导：pthread_create() -> CallbackBatchHandler() -> CallIpcCallback()。数据流：tArg/hdlerArg指针通过pthread_create传递给CallbackBatchHandler，再传递给CallIpcCallback。关键调用点：pthread_create调用前仅检查了tArg->num是否为0，未检查tArg/hdlerArg指针本身是否为NULL。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在pthread_create调用前添加对tArg/hdlerArg指针的NULL检查", "verification_notes": "分析结论正确，代码中确实存在空指针解引用风险。CallbackBatchHandler和CallIpcCallback函数中未对hdlerArg指针进行NULL检查，而该指针通过pthread_create传递。触发路径分析准确，后果评估合理，建议在pthread_create调用前添加NULL检查是合适的解决方案。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 298, "evidence": "threadContext->callerPid = ipcMsg->processID;", "confidence": 0.6, "severity": "high", "gid": 278, "verify": "ipcMsg pointer is not null before dereference", "has_risk": true, "preconditions": "ioctl系统调用返回的content.inMsg为空指针", "trigger_path": "调用路径推导：CallbackDispatchLoop() -> ioctl() -> 直接使用ipcMsg。数据流：ipcMsg指针来源于ioctl系统调用填充的content.inMsg，在CallbackDispatchLoop函数中直接赋值给ipcMsg变量后立即解引用。关键调用点：ioctl调用后未检查content.inMsg是否为空指针。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在使用ipcMsg前添加空指针检查，例如：if (ipcMsg == NULL) { RPC_LOG_ERROR(...); return; }", "verification_notes": "分析结论正确，代码确实缺少对content.inMsg的空指针检查，直接解引用ipcMsg指针存在风险，建议添加空指针检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 299, "evidence": "threadContext->callerUid = (pid_t)ipcMsg->userID;", "confidence": 0.6, "severity": "high", "gid": 279, "verify": "ipcMsg pointer is not null before dereference", "has_risk": true, "preconditions": "ioctl系统调用返回的content.inMsg为空指针", "trigger_path": "调用路径推导：CallbackDispatchLoop() -> ioctl() -> 直接使用ipcMsg。数据流：ipcMsg指针来源于ioctl系统调用填充的content.inMsg，在CallbackDispatchLoop函数中直接赋值给ipcMsg变量后立即解引用。关键调用点：ioctl调用后未检查content.inMsg是否为空指针。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在使用ipcMsg前添加空指针检查，例如：if (ipcMsg == NULL) { RPC_LOG_ERROR(...); return; }", "verification_notes": "分析结论正确，代码确实缺少对content.inMsg的空指针检查，直接解引用ipcMsg指针存在风险，建议添加空指针检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 299, "evidence": "threadContext->callerUid = (pid_t)ipcMsg->userID;", "confidence": 0.6, "severity": "high", "gid": 280, "verify": "ipcMsg pointer is not null before dereference", "has_risk": true, "preconditions": "ioctl系统调用返回的content.inMsg为空指针", "trigger_path": "调用路径推导：CallbackDispatchLoop() -> ioctl() -> 直接使用ipcMsg。数据流：ipcMsg指针来源于ioctl系统调用填充的content.inMsg，在CallbackDispatchLoop函数中直接赋值给ipcMsg变量后立即解引用。关键调用点：ioctl调用后未检查content.inMsg是否为空指针。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在使用ipcMsg前添加空指针检查，例如：if (ipcMsg == NULL) { RPC_LOG_ERROR(...); return; }", "verification_notes": "分析结论正确，代码确实缺少对content.inMsg的空指针检查，直接解引用ipcMsg指针存在风险，建议添加空指针检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 301, "evidence": ".flags = ipcMsg->flag,", "confidence": 0.6, "severity": "high", "gid": 281, "verify": "ipcMsg pointer is not null before dereference", "has_risk": true, "preconditions": "ioctl系统调用返回的content.inMsg为空指针", "trigger_path": "调用路径推导：CallbackDispatchLoop() -> ioctl() -> 直接使用ipcMsg。数据流：ipcMsg指针来源于ioctl系统调用填充的content.inMsg，在CallbackDispatchLoop函数中直接赋值给ipcMsg变量后立即解引用。关键调用点：ioctl调用后未检查content.inMsg是否为空指针。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在使用ipcMsg前添加空指针检查，例如：if (ipcMsg == NULL) { RPC_LOG_ERROR(...); return; }", "verification_notes": "分析结论正确，代码确实缺少对content.inMsg的空指针检查，直接解引用ipcMsg指针存在风险，建议添加空指针检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 307, "evidence": "int32_t error = OnRemoteRequestInner(ipcMsg->code, &hdlerArg->io, &reply, option, &hdlerArg->cbs[i]);", "confidence": 0.6, "severity": "high", "gid": 283, "verify": "hdlerArg pointer is not null before dereference", "has_risk": true, "preconditions": "ioctl系统调用返回的content.inMsg为空指针", "trigger_path": "调用路径推导：CallbackDispatchLoop() -> ioctl() -> 直接使用ipcMsg。数据流：ipcMsg指针来源于ioctl系统调用填充的content.inMsg，在CallbackDispatchLoop函数中直接赋值给ipcMsg变量后立即解引用。关键调用点：ioctl调用后未检查content.inMsg是否为空指针。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在使用ipcMsg前添加空指针检查，例如：if (ipcMsg == NULL) { RPC_LOG_ERROR(...); return; }", "verification_notes": "分析结论正确，代码确实缺少对content.inMsg的空指针检查，直接解引用ipcMsg指针存在风险，建议添加空指针检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 307, "evidence": "int32_t error = OnRemoteRequestInner(ipcMsg->code, &hdlerArg->io, &reply, option, &hdlerArg->cbs[i]);", "confidence": 0.6, "severity": "high", "gid": 284, "verify": "hdlerArg pointer is not null before dereference", "has_risk": true, "preconditions": "ioctl系统调用返回的content.inMsg为空指针", "trigger_path": "调用路径推导：CallbackDispatchLoop() -> ioctl() -> 直接使用ipcMsg。数据流：ipcMsg指针来源于ioctl系统调用填充的content.inMsg，在CallbackDispatchLoop函数中直接赋值给ipcMsg变量后立即解引用。关键调用点：ioctl调用后未检查content.inMsg是否为空指针。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在使用ipcMsg前添加空指针检查，例如：if (ipcMsg == NULL) { RPC_LOG_ERROR(...); return; }", "verification_notes": "分析结论正确，代码确实缺少对content.inMsg的空指针检查，直接解引用ipcMsg指针存在风险，建议添加空指针检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 311, "evidence": "if (!(ipcMsg->flag & TF_OP_ASYNC)) {", "confidence": 0.6, "severity": "high", "gid": 285, "verify": "ipcMsg pointer is not null before dereference", "has_risk": true, "preconditions": "ioctl系统调用返回的content.inMsg为空指针", "trigger_path": "调用路径推导：CallbackDispatchLoop() -> ioctl() -> 直接使用ipcMsg。数据流：ipcMsg指针来源于ioctl系统调用填充的content.inMsg，在CallbackDispatchLoop函数中直接赋值给ipcMsg变量后立即解引用。关键调用点：ioctl调用后未检查content.inMsg是否为空指针。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在使用ipcMsg前添加空指针检查，例如：if (ipcMsg == NULL) { RPC_LOG_ERROR(...); return; }", "verification_notes": "分析结论正确，代码确实缺少对content.inMsg的空指针检查，直接解引用ipcMsg指针存在风险，建议添加空指针检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 326, "evidence": "switch (ipcMsg->type) {", "confidence": 0.6, "severity": "high", "gid": 289, "verify": "ipcMsg pointer is not null before dereference", "has_risk": true, "preconditions": "ioctl系统调用返回的content.inMsg为空指针", "trigger_path": "调用路径推导：CallbackDispatchLoop() -> ioctl() -> 直接使用ipcMsg。数据流：ipcMsg指针来源于ioctl系统调用填充的content.inMsg，在CallbackDispatchLoop函数中直接赋值给ipcMsg变量后立即解引用。关键调用点：ioctl调用后未检查content.inMsg是否为空指针。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在使用ipcMsg前添加空指针检查，例如：if (ipcMsg == NULL) { RPC_LOG_ERROR(...); return; }", "verification_notes": "分析结论正确，代码确实缺少对content.inMsg的空指针检查，直接解引用ipcMsg指针存在风险，建议添加空指针检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 392, "evidence": "switch (ipcMsg->type) {", "confidence": 0.6, "severity": "high", "gid": 304, "verify": "ipcMsg pointer is not null before dereference", "has_risk": true, "preconditions": "ioctl系统调用返回的content.inMsg为空指针", "trigger_path": "调用路径推导：CallbackDispatchLoop() -> ioctl() -> 直接使用ipcMsg。数据流：ipcMsg指针来源于ioctl系统调用填充的content.inMsg，在CallbackDispatchLoop函数中直接赋值给ipcMsg变量后立即解引用。关键调用点：ioctl调用后未检查content.inMsg是否为空指针。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在使用ipcMsg前添加空指针检查，例如：if (ipcMsg == NULL) { RPC_LOG_ERROR(...); return; }", "verification_notes": "分析结论正确，代码确实缺少对content.inMsg的空指针检查，直接解引用ipcMsg指针存在风险，建议添加空指针检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 400, "evidence": "RPC_LOG_ERROR(\"                                                          \", ipcMsg->type);", "confidence": 0.6, "severity": "high", "gid": 305, "verify": "ipcMsg pointer is not null before dereference", "has_risk": true, "preconditions": "ioctl系统调用返回的content.inMsg为空指针", "trigger_path": "调用路径推导：CallbackDispatchLoop() -> ioctl() -> 直接使用ipcMsg。数据流：ipcMsg指针来源于ioctl系统调用填充的content.inMsg，在CallbackDispatchLoop函数中直接赋值给ipcMsg变量后立即解引用。关键调用点：ioctl调用后未检查content.inMsg是否为空指针。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在使用ipcMsg前添加空指针检查，例如：if (ipcMsg == NULL) { RPC_LOG_ERROR(...); return; }", "verification_notes": "分析结论正确，代码确实缺少对content.inMsg的空指针检查，直接解引用ipcMsg指针存在风险，建议添加空指针检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 418, "evidence": "if ((ipcMsg->type == MT_REQUEST) && (ipcMsg->flag == TF_OP_SYNC)) {", "confidence": 0.6, "severity": "high", "gid": 307, "verify": "ipcMsg pointer is not null before dereference", "has_risk": true, "preconditions": "ioctl系统调用返回的content.inMsg为空指针", "trigger_path": "调用路径推导：CallbackDispatchLoop() -> ioctl() -> 直接使用ipcMsg。数据流：ipcMsg指针来源于ioctl系统调用填充的content.inMsg，在CallbackDispatchLoop函数中直接赋值给ipcMsg变量后立即解引用。关键调用点：ioctl调用后未检查content.inMsg是否为空指针。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在使用ipcMsg前添加空指针检查，例如：if (ipcMsg == NULL) { RPC_LOG_ERROR(...); return; }", "verification_notes": "分析结论正确，代码确实缺少对content.inMsg的空指针检查，直接解引用ipcMsg指针存在风险，建议添加空指针检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 504, "evidence": "threadContext->callerPid = ipcMsg->processID;", "confidence": 0.6, "severity": "high", "gid": 312, "verify": "ipcMsg pointer is not null before dereference", "has_risk": true, "preconditions": "ioctl系统调用返回的content.inMsg为空指针", "trigger_path": "调用路径推导：CallbackDispatchLoop() -> ioctl() -> 直接使用ipcMsg。数据流：ipcMsg指针来源于ioctl系统调用填充的content.inMsg，在CallbackDispatchLoop函数中直接赋值给ipcMsg变量后立即解引用。关键调用点：ioctl调用后未检查content.inMsg是否为空指针。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在使用ipcMsg前添加空指针检查，例如：if (ipcMsg == NULL) { RPC_LOG_ERROR(...); return; }", "verification_notes": "分析结论正确，代码确实缺少对content.inMsg的空指针检查，直接解引用ipcMsg指针存在风险，建议添加空指针检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 504, "evidence": "threadContext->callerPid = ipcMsg->processID;", "confidence": 0.6, "severity": "high", "gid": 313, "verify": "ipcMsg pointer is not null before dereference", "has_risk": true, "preconditions": "ioctl系统调用返回的content.inMsg为空指针", "trigger_path": "调用路径推导：CallbackDispatchLoop() -> ioctl() -> 直接使用ipcMsg。数据流：ipcMsg指针来源于ioctl系统调用填充的content.inMsg，在CallbackDispatchLoop函数中直接赋值给ipcMsg变量后立即解引用。关键调用点：ioctl调用后未检查content.inMsg是否为空指针。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在使用ipcMsg前添加空指针检查，例如：if (ipcMsg == NULL) { RPC_LOG_ERROR(...); return; }", "verification_notes": "分析结论正确，代码确实缺少对content.inMsg的空指针检查，直接解引用ipcMsg指针存在风险，建议添加空指针检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 505, "evidence": "threadContext->callerUid = (pid_t)ipcMsg->userID;", "confidence": 0.6, "severity": "high", "gid": 314, "verify": "ipcMsg pointer is not null before dereference", "has_risk": true, "preconditions": "ioctl系统调用返回的content.inMsg为空指针", "trigger_path": "调用路径推导：CallbackDispatchLoop() -> ioctl() -> 直接使用ipcMsg。数据流：ipcMsg指针来源于ioctl系统调用填充的content.inMsg，在CallbackDispatchLoop函数中直接赋值给ipcMsg变量后立即解引用。关键调用点：ioctl调用后未检查content.inMsg是否为空指针。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在使用ipcMsg前添加空指针检查，例如：if (ipcMsg == NULL) { RPC_LOG_ERROR(...); return; }", "verification_notes": "分析结论正确，代码确实缺少对content.inMsg的空指针检查，直接解引用ipcMsg指针存在风险，建议添加空指针检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 505, "evidence": "threadContext->callerUid = (pid_t)ipcMsg->userID;", "confidence": 0.6, "severity": "high", "gid": 315, "verify": "ipcMsg pointer is not null before dereference", "has_risk": true, "preconditions": "ioctl系统调用返回的content.inMsg为空指针", "trigger_path": "调用路径推导：CallbackDispatchLoop() -> ioctl() -> 直接使用ipcMsg。数据流：ipcMsg指针来源于ioctl系统调用填充的content.inMsg，在CallbackDispatchLoop函数中直接赋值给ipcMsg变量后立即解引用。关键调用点：ioctl调用后未检查content.inMsg是否为空指针。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在使用ipcMsg前添加空指针检查，例如：if (ipcMsg == NULL) { RPC_LOG_ERROR(...); return; }", "verification_notes": "分析结论正确，代码确实缺少对content.inMsg的空指针检查，直接解引用ipcMsg指针存在风险，建议添加空指针检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 512, "evidence": ".flags = ipcMsg->flag,", "confidence": 0.6, "severity": "high", "gid": 316, "verify": "ipcMsg pointer is not null before dereference", "has_risk": true, "preconditions": "ioctl系统调用返回的content.inMsg为空指针", "trigger_path": "调用路径推导：CallbackDispatchLoop() -> ioctl() -> 直接使用ipcMsg。数据流：ipcMsg指针来源于ioctl系统调用填充的content.inMsg，在CallbackDispatchLoop函数中直接赋值给ipcMsg变量后立即解引用。关键调用点：ioctl调用后未检查content.inMsg是否为空指针。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在使用ipcMsg前添加空指针检查，例如：if (ipcMsg == NULL) { RPC_LOG_ERROR(...); return; }", "verification_notes": "分析结论正确，代码确实缺少对content.inMsg的空指针检查，直接解引用ipcMsg指针存在风险，建议添加空指针检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 515, "evidence": "int32_t error = OnRemoteRequestInner(ipcMsg->code, &data, &reply, option, objectStub);", "confidence": 0.6, "severity": "high", "gid": 318, "verify": "ipcMsg pointer is not null before dereference", "has_risk": true, "preconditions": "ioctl系统调用返回的content.inMsg为空指针", "trigger_path": "调用路径推导：CallbackDispatchLoop() -> ioctl() -> 直接使用ipcMsg。数据流：ipcMsg指针来源于ioctl系统调用填充的content.inMsg，在CallbackDispatchLoop函数中直接赋值给ipcMsg变量后立即解引用。关键调用点：ioctl调用后未检查content.inMsg是否为空指针。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在使用ipcMsg前添加空指针检查，例如：if (ipcMsg == NULL) { RPC_LOG_ERROR(...); return; }", "verification_notes": "分析结论正确，代码确实缺少对content.inMsg的空指针检查，直接解引用ipcMsg指针存在风险，建议添加空指针检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 519, "evidence": "if (!(ipcMsg->flag & TF_OP_ASYNC)) {", "confidence": 0.6, "severity": "high", "gid": 319, "verify": "ipcMsg pointer is not null before dereference", "has_risk": true, "preconditions": "ioctl系统调用返回的content.inMsg为空指针", "trigger_path": "调用路径推导：CallbackDispatchLoop() -> ioctl() -> 直接使用ipcMsg。数据流：ipcMsg指针来源于ioctl系统调用填充的content.inMsg，在CallbackDispatchLoop函数中直接赋值给ipcMsg变量后立即解引用。关键调用点：ioctl调用后未检查content.inMsg是否为空指针。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在使用ipcMsg前添加空指针检查，例如：if (ipcMsg == NULL) { RPC_LOG_ERROR(...); return; }", "verification_notes": "分析结论正确，代码确实缺少对content.inMsg的空指针检查，直接解引用ipcMsg指针存在风险，建议添加空指针检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 513, "evidence": ".args = objectStub->args", "confidence": 0.6, "severity": "high", "gid": 317, "verify": "objectStub pointer is not null before dereference", "has_risk": true, "preconditions": "GetObjectStub(0)返回NULL或objectStub在循环中被修改为NULL", "trigger_path": "调用路径推导：IpcJoinThread() -> IpcJoinThreadLoop() -> GetObjectStub(0) -> objectStub解引用。数据流：通过GetObjectStub(0)获取objectStub指针，虽然初始有NULL检查，但在循环中可能被修改。关键调用点：IpcJoinThreadLoop()函数中option.args = objectStub->args处未在循环中保持NULL检查。", "consequences": "NULL指针解引用，可能导致程序崩溃或拒绝服务", "suggestions": "在option.args = objectStub->args前添加NULL检查，或确保objectStub在循环中不会被置为NULL", "verification_notes": "分析结论正确，GetObjectStub(0)确实可能返回NULL，IpcJoinThreadLoop函数中循环内未保持NULL检查，存在NULL指针解引用风险，建议在循环中保持NULL检查是合理的解决方案"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 363, "evidence": "if (node->token == msg->target.token) {", "confidence": 0.6, "severity": "high", "gid": 294, "verify": "node and msg pointers are not null before dereference", "has_risk": true, "preconditions": "ioctl返回的content.inMsg为空或链表遍历返回的node为空", "trigger_path": "调用路径推导：IpcCallbackThread() -> CallbackDispatchLoop() -> GetIpcCallback()。数据流：通过ioctl获取content消息，content.inMsg传递给GetIpcCallback作为msg参数。关键调用点：1) CallbackDispatchLoop()未检查content.inMsg是否为空；2) GetIpcCallback()未检查msg参数和链表遍历返回的node是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "1) 在GetIpcCallback开始处添加msg空指针检查；2) 在链表遍历前添加node空指针检查；3) 在CallbackDispatchLoop中添加content.inMsg空指针检查", "verification_notes": "分析结论正确：\n1. 前置条件合理：记忆确认IPC消息处理路径中确实缺少对ioctl返回消息和链表遍历节点的空指针检查\n2. 触发路径成立：记忆确认CallbackBatchHandler调用路径存在空指针解引用风险\n3. 后果评估准确：空指针解引用会导致程序崩溃\n4. 建议合适：与记忆中的建议一致，包括添加msg和node空指针检查"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 363, "evidence": "if (node->token == msg->target.token) {", "confidence": 0.6, "severity": "high", "gid": 295, "verify": "node and msg pointers are not null before dereference", "has_risk": true, "preconditions": "ioctl返回的content.inMsg为空或链表遍历返回的node为空", "trigger_path": "调用路径推导：IpcCallbackThread() -> CallbackDispatchLoop() -> GetIpcCallback()。数据流：通过ioctl获取content消息，content.inMsg传递给GetIpcCallback作为msg参数。关键调用点：1) CallbackDispatchLoop()未检查content.inMsg是否为空；2) GetIpcCallback()未检查msg参数和链表遍历返回的node是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "1) 在GetIpcCallback开始处添加msg空指针检查；2) 在链表遍历前添加node空指针检查；3) 在CallbackDispatchLoop中添加content.inMsg空指针检查", "verification_notes": "分析结论正确：\n1. 前置条件合理：记忆确认IPC消息处理路径中确实缺少对ioctl返回消息和链表遍历节点的空指针检查\n2. 触发路径成立：记忆确认CallbackBatchHandler调用路径存在空指针解引用风险\n3. 后果评估准确：空指针解引用会导致程序崩溃\n4. 建议合适：与记忆中的建议一致，包括添加msg和node空指针检查"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 140, "evidence": "return ioctl(g_connector->fd, IPC_SEND_RECV_MSG, &content);", "confidence": 0.5, "severity": "medium", "gid": 341, "verify": "验证ioctl操作的并发安全性", "has_risk": true, "preconditions": "多线程环境下同时访问g_connector->fd进行ioctl操作", "trigger_path": "调用路径推导：所有ioctl调用都通过全局变量g_connector访问文件描述符fd。数据流：1) IpcFreeBuffer()直接访问g_connector->fd进行ioctl(140行)；2) SendReply()和SendFailedReply()通过消息处理路径访问g_connector->fd进行ioctl(222,259行)；3) CallbackDispatchLoop()在消息循环中访问g_connector->fd进行ioctl(382行)。关键调用点：所有ioctl调用点都未对g_connector->fd的访问进行同步保护。", "consequences": "可能导致数据竞争或竞态条件，包括使用已关闭的文件描述符或并发访问冲突", "suggestions": "在所有ioctl调用点添加g_connectorMutex互斥锁保护，或使用读写锁优化并发性能", "verification_notes": "分析结论正确，前置条件合理（多线程环境下访问g_connector->fd），触发路径清晰（所有ioctl调用都通过g_connector访问fd且无同步保护），后果评估准确（可能导致数据竞争或竞态条件），建议合适（项目中已有使用g_connectorMutex的模式）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 222, "evidence": "ret = ioctl(g_connector->fd, IPC_SEND_RECV_MSG, &content);", "confidence": 0.5, "severity": "medium", "gid": 351, "verify": "验证ioctl操作的并发安全性", "has_risk": true, "preconditions": "多线程环境下同时访问g_connector->fd进行ioctl操作", "trigger_path": "调用路径推导：所有ioctl调用都通过全局变量g_connector访问文件描述符fd。数据流：1) IpcFreeBuffer()直接访问g_connector->fd进行ioctl(140行)；2) SendReply()和SendFailedReply()通过消息处理路径访问g_connector->fd进行ioctl(222,259行)；3) CallbackDispatchLoop()在消息循环中访问g_connector->fd进行ioctl(382行)。关键调用点：所有ioctl调用点都未对g_connector->fd的访问进行同步保护。", "consequences": "可能导致数据竞争或竞态条件，包括使用已关闭的文件描述符或并发访问冲突", "suggestions": "在所有ioctl调用点添加g_connectorMutex互斥锁保护，或使用读写锁优化并发性能", "verification_notes": "分析结论正确，前置条件合理（多线程环境下访问g_connector->fd），触发路径清晰（所有ioctl调用都通过g_connector访问fd且无同步保护），后果评估准确（可能导致数据竞争或竞态条件），建议合适（项目中已有使用g_connectorMutex的模式）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 259, "evidence": "ret = ioctl(g_connector->fd, IPC_SEND_RECV_MSG, &content);", "confidence": 0.5, "severity": "medium", "gid": 355, "verify": "验证ioctl操作的并发安全性", "has_risk": true, "preconditions": "多线程环境下同时访问g_connector->fd进行ioctl操作", "trigger_path": "调用路径推导：所有ioctl调用都通过全局变量g_connector访问文件描述符fd。数据流：1) IpcFreeBuffer()直接访问g_connector->fd进行ioctl(140行)；2) SendReply()和SendFailedReply()通过消息处理路径访问g_connector->fd进行ioctl(222,259行)；3) CallbackDispatchLoop()在消息循环中访问g_connector->fd进行ioctl(382行)。关键调用点：所有ioctl调用点都未对g_connector->fd的访问进行同步保护。", "consequences": "可能导致数据竞争或竞态条件，包括使用已关闭的文件描述符或并发访问冲突", "suggestions": "在所有ioctl调用点添加g_connectorMutex互斥锁保护，或使用读写锁优化并发性能", "verification_notes": "分析结论正确，前置条件合理（多线程环境下访问g_connector->fd），触发路径清晰（所有ioctl调用都通过g_connector访问fd且无同步保护），后果评估准确（可能导致数据竞争或竞态条件），建议合适（项目中已有使用g_connectorMutex的模式）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 382, "evidence": "int32_t ret = ioctl(g_connector->fd, IPC_SEND_RECV_MSG, &content);", "confidence": 0.5, "severity": "medium", "gid": 376, "verify": "验证ioctl操作的并发安全性", "has_risk": true, "preconditions": "多线程环境下同时访问g_connector->fd进行ioctl操作", "trigger_path": "调用路径推导：所有ioctl调用都通过全局变量g_connector访问文件描述符fd。数据流：1) IpcFreeBuffer()直接访问g_connector->fd进行ioctl(140行)；2) SendReply()和SendFailedReply()通过消息处理路径访问g_connector->fd进行ioctl(222,259行)；3) CallbackDispatchLoop()在消息循环中访问g_connector->fd进行ioctl(382行)。关键调用点：所有ioctl调用点都未对g_connector->fd的访问进行同步保护。", "consequences": "可能导致数据竞争或竞态条件，包括使用已关闭的文件描述符或并发访问冲突", "suggestions": "在所有ioctl调用点添加g_connectorMutex互斥锁保护，或使用读写锁优化并发性能", "verification_notes": "分析结论正确，前置条件合理（多线程环境下访问g_connector->fd），触发路径清晰（所有ioctl调用都通过g_connector访问fd且无同步保护），后果评估准确（可能导致数据竞争或竞态条件），建议合适（项目中已有使用g_connectorMutex的模式）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 55, "evidence": "static inline void InitIpcCallback(void)", "confidence": 0.5, "severity": "medium", "gid": 333, "verify": "验证InitIpcCallback函数的并发安全性", "has_risk": true, "preconditions": "多线程环境下同时调用OpenDriver函数", "trigger_path": "调用路径推导：OpenDriver() -> InitIpcCallback()。数据流：全局变量g_ipcCallback.apis通过InitIpcCallback()初始化。关键调用点：OpenDriver()函数未对InitIpcCallback()调用进行同步保护，在多线程环境下可能被并发调用。", "consequences": "多线程并发初始化链表可能导致数据结构损坏或数据竞争", "suggestions": "1. 在InitIpcCallback内部使用g_ipcCallback.mutex进行保护；2. 或在OpenDriver调用InitIpcCallback前加锁", "verification_notes": "分析结论正确，前置条件合理（多线程环境下调用OpenDriver），触发路径清晰（OpenDriver->InitIpcCallback操作全局变量），后果评估准确（并发初始化可能导致数据结构损坏），建议合适（使用mutex保护）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 125, "evidence": "static int32_t IpcFreeBuffer(void *buffer)", "confidence": 0.5, "severity": "medium", "gid": 338, "verify": "验证IpcFreeBuffer函数的并发安全性", "has_risk": true, "preconditions": "多线程环境下同时调用IpcFreeBuffer函数", "trigger_path": "调用路径推导：\n1. CallIpcCallback -> IpcFreeBuffer (异步消息处理路径)\n2. CallbackDispatchLoop -> IpcFreeBuffer (错误处理路径)\n数据流：全局变量g_connector在多个线程中共享访问\n关键调用点：\n- IpcFreeBuffer直接访问全局变量g_connector未加锁\n- 虽然CloseDriver函数中对g_connector有mutex保护，但IpcFreeBuffer中没有同步机制\n触发条件：多线程环境下同时释放IPC缓冲区\n", "consequences": "可能导致use-after-free或空指针解引用，内核状态不一致", "suggestions": "1. 在IpcFreeBuffer中添加对g_connector的互斥锁保护\n2. 或者确保g_connector的生命周期管理完全线程安全\n3. 考虑使用原子操作或读写锁优化性能", "verification_notes": "分析结论正确：\n1. 前置条件合理：代码显示IpcFreeBuffer确实在多线程环境下被调用（如HandleTransaction和HandleReply）\n2. 触发路径成立：存在CallIpcCallback->IpcFreeBuffer和CallbackDispatchLoop->IpcFreeBuffer的调用路径\n3. 后果评估准确：确实存在对全局变量g_connector的未加锁访问，可能导致竞态条件\n4. 建议合适：添加互斥锁保护是合理的解决方案\n代码分析和记忆检索确认了分析Agent的结论"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 125, "evidence": "static int32_t IpcFreeBuffer(void *buffer)", "confidence": 0.5, "severity": "medium", "gid": 339, "verify": "验证IpcFreeBuffer函数的并发安全性", "has_risk": true, "preconditions": "多线程环境下同时调用IpcFreeBuffer函数", "trigger_path": "调用路径推导：\n1. CallIpcCallback -> IpcFreeBuffer (异步消息处理路径)\n2. CallbackDispatchLoop -> IpcFreeBuffer (错误处理路径)\n数据流：全局变量g_connector在多个线程中共享访问\n关键调用点：\n- IpcFreeBuffer直接访问全局变量g_connector未加锁\n- 虽然CloseDriver函数中对g_connector有mutex保护，但IpcFreeBuffer中没有同步机制\n触发条件：多线程环境下同时释放IPC缓冲区\n", "consequences": "可能导致use-after-free或空指针解引用，内核状态不一致", "suggestions": "1. 在IpcFreeBuffer中添加对g_connector的互斥锁保护\n2. 或者确保g_connector的生命周期管理完全线程安全\n3. 考虑使用原子操作或读写锁优化性能", "verification_notes": "分析结论正确：\n1. 前置条件合理：代码显示IpcFreeBuffer确实在多线程环境下被调用（如HandleTransaction和HandleReply）\n2. 触发路径成立：存在CallIpcCallback->IpcFreeBuffer和CallbackDispatchLoop->IpcFreeBuffer的调用路径\n3. 后果评估准确：确实存在对全局变量g_connector的未加锁访问，可能导致竞态条件\n4. 建议合适：添加互斥锁保护是合理的解决方案\n代码分析和记忆检索确认了分析Agent的结论"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 314, "evidence": "IpcFreeBuffer((void *)ipcMsg);", "confidence": 0.5, "severity": "medium", "gid": 361, "verify": "验证IpcFreeBuffer函数的并发安全性", "has_risk": true, "preconditions": "多线程环境下同时调用IpcFreeBuffer函数", "trigger_path": "调用路径推导：\n1. CallIpcCallback -> IpcFreeBuffer (异步消息处理路径)\n2. CallbackDispatchLoop -> IpcFreeBuffer (错误处理路径)\n数据流：全局变量g_connector在多个线程中共享访问\n关键调用点：\n- IpcFreeBuffer直接访问全局变量g_connector未加锁\n- 虽然CloseDriver函数中对g_connector有mutex保护，但IpcFreeBuffer中没有同步机制\n触发条件：多线程环境下同时释放IPC缓冲区\n", "consequences": "可能导致use-after-free或空指针解引用，内核状态不一致", "suggestions": "1. 在IpcFreeBuffer中添加对g_connector的互斥锁保护\n2. 或者确保g_connector的生命周期管理完全线程安全\n3. 考虑使用原子操作或读写锁优化性能", "verification_notes": "分析结论正确：\n1. 前置条件合理：代码显示IpcFreeBuffer确实在多线程环境下被调用（如HandleTransaction和HandleReply）\n2. 触发路径成立：存在CallIpcCallback->IpcFreeBuffer和CallbackDispatchLoop->IpcFreeBuffer的调用路径\n3. 后果评估准确：确实存在对全局变量g_connector的未加锁访问，可能导致竞态条件\n4. 建议合适：添加互斥锁保护是合理的解决方案\n代码分析和记忆检索确认了分析Agent的结论"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 314, "evidence": "IpcFreeBuffer((void *)ipcMsg);", "confidence": 0.5, "severity": "medium", "gid": 362, "verify": "验证IpcFreeBuffer函数的并发安全性", "has_risk": true, "preconditions": "多线程环境下同时调用IpcFreeBuffer函数", "trigger_path": "调用路径推导：\n1. CallIpcCallback -> IpcFreeBuffer (异步消息处理路径)\n2. CallbackDispatchLoop -> IpcFreeBuffer (错误处理路径)\n数据流：全局变量g_connector在多个线程中共享访问\n关键调用点：\n- IpcFreeBuffer直接访问全局变量g_connector未加锁\n- 虽然CloseDriver函数中对g_connector有mutex保护，但IpcFreeBuffer中没有同步机制\n触发条件：多线程环境下同时释放IPC缓冲区\n", "consequences": "可能导致use-after-free或空指针解引用，内核状态不一致", "suggestions": "1. 在IpcFreeBuffer中添加对g_connector的互斥锁保护\n2. 或者确保g_connector的生命周期管理完全线程安全\n3. 考虑使用原子操作或读写锁优化性能", "verification_notes": "分析结论正确：\n1. 前置条件合理：代码显示IpcFreeBuffer确实在多线程环境下被调用（如HandleTransaction和HandleReply）\n2. 触发路径成立：存在CallIpcCallback->IpcFreeBuffer和CallbackDispatchLoop->IpcFreeBuffer的调用路径\n3. 后果评估准确：确实存在对全局变量g_connector的未加锁访问，可能导致竞态条件\n4. 建议合适：添加互斥锁保护是合理的解决方案\n代码分析和记忆检索确认了分析Agent的结论"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 164, "evidence": "static int32_t CheckIpcIo(IpcIo *data)", "confidence": 0.5, "severity": "medium", "gid": 344, "verify": "验证CheckIpcIo函数的并发安全性", "has_risk": true, "preconditions": "多个线程同时访问同一个IpcIo结构体，且该结构体正在被修改", "trigger_path": "调用路径推导：1) IpcSendRequest() -> CheckIpcIo()；2) SendReply() -> CheckIpcIo()。数据流：IpcIo结构体指针通过函数参数传递。关键调用点：CheckIpcIo()函数内部访问IpcIo结构体字段时未进行同步保护。触发条件：当多个线程同时调用CheckIpcIo()函数并传入同一个正在被修改的IpcIo结构体指针时。", "consequences": "数据竞争可能导致不一致的检查结果或程序崩溃", "suggestions": "1) 调用者应确保IpcIo结构体在被CheckIpcIo检查时不被其他线程修改；2) 为IpcIo结构体添加互斥锁保护", "verification_notes": "分析结论正确，前置条件合理（存在多线程访问IpcIo场景），触发路径成立（CheckIpcIo被IpcSendRequest和SendReply调用且无同步保护），后果评估准确（数据竞争可能导致不一致或崩溃），建议合适（添加互斥锁保护）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 195, "evidence": "ret = CheckIpcIo(reply);", "confidence": 0.5, "severity": "medium", "gid": 348, "verify": "验证CheckIpcIo函数的并发安全性", "has_risk": true, "preconditions": "多个线程同时访问同一个IpcIo结构体，且该结构体正在被修改", "trigger_path": "调用路径推导：1) IpcSendRequest() -> CheckIpcIo()；2) SendReply() -> CheckIpcIo()。数据流：IpcIo结构体指针通过函数参数传递。关键调用点：CheckIpcIo()函数内部访问IpcIo结构体字段时未进行同步保护。触发条件：当多个线程同时调用CheckIpcIo()函数并传入同一个正在被修改的IpcIo结构体指针时。", "consequences": "数据竞争可能导致不一致的检查结果或程序崩溃", "suggestions": "1) 调用者应确保IpcIo结构体在被CheckIpcIo检查时不被其他线程修改；2) 为IpcIo结构体添加互斥锁保护", "verification_notes": "分析结论正确，前置条件合理（存在多线程访问IpcIo场景），触发路径成立（CheckIpcIo被IpcSendRequest和SendReply调用且无同步保护），后果评估准确（数据竞争可能导致不一致或崩溃），建议合适（添加互斥锁保护）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 266, "evidence": "static void CallDeathCallback(IpcMsg *ipcMsg)", "confidence": 0.5, "severity": "medium", "gid": 356, "verify": "验证CallDeathCallback函数的并发安全性", "has_risk": true, "preconditions": "多线程环境下同时处理死亡通知消息(MT_DEATH_NOTIFY)", "trigger_path": "调用路径推导：CallbackDispatchLoop() -> GetDeathCallback() -> CallbackBatchHandler() -> CallDeathCallback()。数据流：IPC消息通过ioctl接收，传递给CallbackDispatchLoop处理，当消息类型为MT_DEATH_NOTIFY时调用CallDeathCallback。关键调用点：CallbackDispatchLoop是消息处理主循环，GetDeathCallback仅保护参数设置，CallDeathCallback访问共享链表时未加锁。", "consequences": "数据竞争可能导致链表损坏、程序崩溃或未定义行为", "suggestions": "在CallDeathCallback函数内部或调用链上层添加适当的锁机制保护ipcSkeleton->objects链表的访问，建议使用读写锁优化性能", "verification_notes": "分析结论正确，前置条件合理（多线程环境下处理MT_DEATH_NOTIFY消息），触发路径成立（CallbackDispatchLoop->GetDeathCallback->CallbackBatchHandler->CallDeathCallback），后果评估准确（未加锁访问ipcSkeleton->objects链表可能导致数据竞争），建议合适（添加读写锁保护链表访问）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 266, "evidence": "static void CallDeathCallback(IpcMsg *ipcMsg)", "confidence": 0.5, "severity": "medium", "gid": 357, "verify": "验证CallDeathCallback函数的并发安全性", "has_risk": true, "preconditions": "多线程环境下同时处理死亡通知消息(MT_DEATH_NOTIFY)", "trigger_path": "调用路径推导：CallbackDispatchLoop() -> GetDeathCallback() -> CallbackBatchHandler() -> CallDeathCallback()。数据流：IPC消息通过ioctl接收，传递给CallbackDispatchLoop处理，当消息类型为MT_DEATH_NOTIFY时调用CallDeathCallback。关键调用点：CallbackDispatchLoop是消息处理主循环，GetDeathCallback仅保护参数设置，CallDeathCallback访问共享链表时未加锁。", "consequences": "数据竞争可能导致链表损坏、程序崩溃或未定义行为", "suggestions": "在CallDeathCallback函数内部或调用链上层添加适当的锁机制保护ipcSkeleton->objects链表的访问，建议使用读写锁优化性能", "verification_notes": "分析结论正确，前置条件合理（多线程环境下处理MT_DEATH_NOTIFY消息），触发路径成立（CallbackDispatchLoop->GetDeathCallback->CallbackBatchHandler->CallDeathCallback），后果评估准确（未加锁访问ipcSkeleton->objects链表可能导致数据竞争），建议合适（添加读写锁保护链表访问）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 328, "evidence": "CallDeathCallback(ipcMsg);", "confidence": 0.5, "severity": "medium", "gid": 365, "verify": "验证CallDeathCallback函数的并发安全性", "has_risk": true, "preconditions": "多线程环境下同时处理死亡通知消息(MT_DEATH_NOTIFY)", "trigger_path": "调用路径推导：CallbackDispatchLoop() -> GetDeathCallback() -> CallbackBatchHandler() -> CallDeathCallback()。数据流：IPC消息通过ioctl接收，传递给CallbackDispatchLoop处理，当消息类型为MT_DEATH_NOTIFY时调用CallDeathCallback。关键调用点：CallbackDispatchLoop是消息处理主循环，GetDeathCallback仅保护参数设置，CallDeathCallback访问共享链表时未加锁。", "consequences": "数据竞争可能导致链表损坏、程序崩溃或未定义行为", "suggestions": "在CallDeathCallback函数内部或调用链上层添加适当的锁机制保护ipcSkeleton->objects链表的访问，建议使用读写锁优化性能", "verification_notes": "分析结论正确，前置条件合理（多线程环境下处理MT_DEATH_NOTIFY消息），触发路径成立（CallbackDispatchLoop->GetDeathCallback->CallbackBatchHandler->CallDeathCallback），后果评估准确（未加锁访问ipcSkeleton->objects链表可能导致数据竞争），建议合适（添加读写锁保护链表访问）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 394, "evidence": "GetDeathCallback(ipcMsg, tArg);", "confidence": 0.5, "severity": "medium", "gid": 377, "verify": "验证CallDeathCallback函数的并发安全性", "has_risk": true, "preconditions": "多线程环境下同时处理死亡通知消息(MT_DEATH_NOTIFY)", "trigger_path": "调用路径推导：CallbackDispatchLoop() -> GetDeathCallback() -> CallbackBatchHandler() -> CallDeathCallback()。数据流：IPC消息通过ioctl接收，传递给CallbackDispatchLoop处理，当消息类型为MT_DEATH_NOTIFY时调用CallDeathCallback。关键调用点：CallbackDispatchLoop是消息处理主循环，GetDeathCallback仅保护参数设置，CallDeathCallback访问共享链表时未加锁。", "consequences": "数据竞争可能导致链表损坏、程序崩溃或未定义行为", "suggestions": "在CallDeathCallback函数内部或调用链上层添加适当的锁机制保护ipcSkeleton->objects链表的访问，建议使用读写锁优化性能", "verification_notes": "分析结论正确，前置条件合理（多线程环境下处理MT_DEATH_NOTIFY消息），触发路径成立（CallbackDispatchLoop->GetDeathCallback->CallbackBatchHandler->CallDeathCallback），后果评估准确（未加锁访问ipcSkeleton->objects链表可能导致数据竞争），建议合适（添加读写锁保护链表访问）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 322, "evidence": "static void *CallbackBatchHandler(HdlerArg *hdlerArg)", "confidence": 0.5, "severity": "medium", "gid": 363, "verify": "验证CallbackBatchHandler函数的并发安全性", "has_risk": true, "preconditions": "多个线程同时处理IPC消息时访问共享的HdlerArg结构体或ThreadContext", "trigger_path": "调用路径推导：pthread_create() -> CallbackBatchHandler() -> CallIpcCallback()/CallDeathCallback()。数据流：通过HdlerArg参数传递共享数据。关键调用点：CallbackBatchHandler()未对共享数据(HdlerArg和ThreadContext)进行同步保护。", "consequences": "数据竞争可能导致内存损坏、数据不一致或程序崩溃", "suggestions": "1. 为HdlerArg添加引用计数或使用线程局部存储；2. 保护ThreadContext的访问；3. 确保共享数据的线程安全访问", "verification_notes": "分析结论正确，前置条件合理（多线程访问共享结构体），触发路径成立（pthread_create->CallbackBatchHandler->CallIpcCallback/CallDeathCallback），后果评估准确（数据竞争风险），建议合适（需添加同步机制）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 322, "evidence": "static void *CallbackBatchHandler(HdlerArg *hdlerArg)", "confidence": 0.5, "severity": "medium", "gid": 364, "verify": "验证CallbackBatchHandler函数的并发安全性", "has_risk": true, "preconditions": "多个线程同时处理IPC消息时访问共享的HdlerArg结构体或ThreadContext", "trigger_path": "调用路径推导：pthread_create() -> CallbackBatchHandler() -> CallIpcCallback()/CallDeathCallback()。数据流：通过HdlerArg参数传递共享数据。关键调用点：CallbackBatchHandler()未对共享数据(HdlerArg和ThreadContext)进行同步保护。", "consequences": "数据竞争可能导致内存损坏、数据不一致或程序崩溃", "suggestions": "1. 为HdlerArg添加引用计数或使用线程局部存储；2. 保护ThreadContext的访问；3. 确保共享数据的线程安全访问", "verification_notes": "分析结论正确，前置条件合理（多线程访问共享结构体），触发路径成立（pthread_create->CallbackBatchHandler->CallIpcCallback/CallDeathCallback），后果评估准确（数据竞争风险），建议合适（需添加同步机制）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 377, "evidence": "static void CallbackDispatchLoop(void)", "confidence": 0.5, "severity": "medium", "gid": 374, "verify": "验证CallbackDispatchLoop函数的并发安全性", "has_risk": true, "preconditions": "多线程环境下并发访问g_connector全局变量", "trigger_path": "调用路径推导：CallbackDispatch() -> CallbackDispatchLoop()。数据流：全局变量g_connector在CallbackDispatchLoop中被直接访问用于ioctl操作。关键调用点：CallbackDispatchLoop()函数未对g_connector的访问进行同步保护。", "consequences": "可能导致数据竞争，引发未定义行为或程序崩溃", "suggestions": "1. 对g_connector的访问添加互斥锁保护；2. 考虑使用线程局部存储或原子操作优化并发访问", "verification_notes": "分析结论正确，记忆显示g_connector确实在多线程环境下被访问且缺少同步保护，CallbackDispatch -> CallbackDispatchLoop路径存在，后果评估准确，建议添加互斥锁是合理方案"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 377, "evidence": "static void CallbackDispatchLoop(void)", "confidence": 0.5, "severity": "medium", "gid": 375, "verify": "验证CallbackDispatchLoop函数的并发安全性", "has_risk": true, "preconditions": "多线程环境下并发访问g_connector全局变量", "trigger_path": "调用路径推导：CallbackDispatch() -> CallbackDispatchLoop()。数据流：全局变量g_connector在CallbackDispatchLoop中被直接访问用于ioctl操作。关键调用点：CallbackDispatchLoop()函数未对g_connector的访问进行同步保护。", "consequences": "可能导致数据竞争，引发未定义行为或程序崩溃", "suggestions": "1. 对g_connector的访问添加互斥锁保护；2. 考虑使用线程局部存储或原子操作优化并发访问", "verification_notes": "分析结论正确，记忆显示g_connector确实在多线程环境下被访问且缺少同步保护，CallbackDispatch -> CallbackDispatchLoop路径存在，后果评估准确，建议添加互斥锁是合理方案"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 428, "evidence": "if (g_connector == NULL) {", "confidence": 0.65, "severity": "medium", "gid": 385, "verify": "验证g_connector的访问是否有适当的同步机制", "has_risk": true, "preconditions": "多线程环境下同时访问g_connector全局变量", "trigger_path": "调用路径推导：多个线程可能同时调用包含g_connector访问的函数（如CallbackDispatch()、IpcJoinThread()、IpcSendRequest()等）。数据流：全局变量g_connector被多个线程共享访问。关键调用点：大多数g_connector访问点未使用g_connectorMutex进行同步保护。", "consequences": "数据竞争可能导致空指针解引用、use-after-free或不可预测的行为", "suggestions": "所有访问g_connector的地方都应该使用g_connectorMutex进行保护，特别是判空检查和后续操作应该在一个锁保护区域内完成", "verification_notes": "分析结论正确，记忆信息确认g_connector确实在多线程环境下存在未加锁访问风险，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 433, "evidence": "int32_t ret = ioctl(g_connector->fd, IPC_SET_IPC_THREAD, 0);", "confidence": 0.5, "severity": "medium", "gid": 386, "verify": "验证g_connector的访问是否有适当的同步机制", "has_risk": true, "preconditions": "多线程环境下同时访问g_connector全局变量", "trigger_path": "调用路径推导：多个线程可能同时调用包含g_connector访问的函数（如CallbackDispatch()、IpcJoinThread()、IpcSendRequest()等）。数据流：全局变量g_connector被多个线程共享访问。关键调用点：大多数g_connector访问点未使用g_connectorMutex进行同步保护。", "consequences": "数据竞争可能导致空指针解引用、use-after-free或不可预测的行为", "suggestions": "所有访问g_connector的地方都应该使用g_connectorMutex进行保护，特别是判空检查和后续操作应该在一个锁保护区域内完成", "verification_notes": "分析结论正确，记忆信息确认g_connector确实在多线程环境下存在未加锁访问风险，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 531, "evidence": "if (g_connector == NULL) {", "confidence": 0.65, "severity": "medium", "gid": 400, "verify": "验证g_connector的访问是否有适当的同步机制", "has_risk": true, "preconditions": "多线程环境下同时访问g_connector全局变量", "trigger_path": "调用路径推导：多个线程可能同时调用包含g_connector访问的函数（如CallbackDispatch()、IpcJoinThread()、IpcSendRequest()等）。数据流：全局变量g_connector被多个线程共享访问。关键调用点：大多数g_connector访问点未使用g_connectorMutex进行同步保护。", "consequences": "数据竞争可能导致空指针解引用、use-after-free或不可预测的行为", "suggestions": "所有访问g_connector的地方都应该使用g_connectorMutex进行保护，特别是判空检查和后续操作应该在一个锁保护区域内完成", "verification_notes": "分析结论正确，记忆信息确认g_connector确实在多线程环境下存在未加锁访问风险，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 547, "evidence": "if (g_connector == NULL) {", "confidence": 0.65, "severity": "medium", "gid": 406, "verify": "验证g_connector的访问是否有适当的同步机制", "has_risk": true, "preconditions": "多线程环境下同时访问g_connector全局变量", "trigger_path": "调用路径推导：多个线程可能同时调用包含g_connector访问的函数（如CallbackDispatch()、IpcJoinThread()、IpcSendRequest()等）。数据流：全局变量g_connector被多个线程共享访问。关键调用点：大多数g_connector访问点未使用g_connectorMutex进行同步保护。", "consequences": "数据竞争可能导致空指针解引用、use-after-free或不可预测的行为", "suggestions": "所有访问g_connector的地方都应该使用g_connectorMutex进行保护，特别是判空检查和后续操作应该在一个锁保护区域内完成", "verification_notes": "分析结论正确，记忆信息确认g_connector确实在多线程环境下存在未加锁访问风险，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 577, "evidence": "if (g_connector == NULL) {", "confidence": 0.65, "severity": "medium", "gid": 410, "verify": "验证g_connector的访问是否有适当的同步机制", "has_risk": true, "preconditions": "多线程环境下同时访问g_connector全局变量", "trigger_path": "调用路径推导：多个线程可能同时调用包含g_connector访问的函数（如CallbackDispatch()、IpcJoinThread()、IpcSendRequest()等）。数据流：全局变量g_connector被多个线程共享访问。关键调用点：大多数g_connector访问点未使用g_connectorMutex进行同步保护。", "consequences": "数据竞争可能导致空指针解引用、use-after-free或不可预测的行为", "suggestions": "所有访问g_connector的地方都应该使用g_connectorMutex进行保护，特别是判空检查和后续操作应该在一个锁保护区域内完成", "verification_notes": "分析结论正确，记忆信息确认g_connector确实在多线程环境下存在未加锁访问风险，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 597, "evidence": "ret = ioctl(g_connector->fd, IPC_SEND_RECV_MSG, &content);", "confidence": 0.5, "severity": "medium", "gid": 411, "verify": "验证g_connector的访问是否有适当的同步机制", "has_risk": true, "preconditions": "多线程环境下同时访问g_connector全局变量", "trigger_path": "调用路径推导：多个线程可能同时调用包含g_connector访问的函数（如CallbackDispatch()、IpcJoinThread()、IpcSendRequest()等）。数据流：全局变量g_connector被多个线程共享访问。关键调用点：大多数g_connector访问点未使用g_connectorMutex进行同步保护。", "consequences": "数据竞争可能导致空指针解引用、use-after-free或不可预测的行为", "suggestions": "所有访问g_connector的地方都应该使用g_connectorMutex进行保护，特别是判空检查和后续操作应该在一个锁保护区域内完成", "verification_notes": "分析结论正确，记忆信息确认g_connector确实在多线程环境下存在未加锁访问风险，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 641, "evidence": "if (g_connector != NULL) {", "confidence": 0.5, "severity": "medium", "gid": 422, "verify": "验证g_connector的访问是否有适当的同步机制", "has_risk": true, "preconditions": "多线程环境下同时访问g_connector全局变量", "trigger_path": "调用路径推导：多个线程可能同时调用包含g_connector访问的函数（如CallbackDispatch()、IpcJoinThread()、IpcSendRequest()等）。数据流：全局变量g_connector被多个线程共享访问。关键调用点：大多数g_connector访问点未使用g_connectorMutex进行同步保护。", "consequences": "数据竞争可能导致空指针解引用、use-after-free或不可预测的行为", "suggestions": "所有访问g_connector的地方都应该使用g_connectorMutex进行保护，特别是判空检查和后续操作应该在一个锁保护区域内完成", "verification_notes": "分析结论正确，记忆信息确认g_connector确实在多线程环境下存在未加锁访问风险，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 642, "evidence": "free(g_connector);", "confidence": 0.5, "severity": "medium", "gid": 423, "verify": "验证g_connector的访问是否有适当的同步机制", "has_risk": true, "preconditions": "多线程环境下同时访问g_connector全局变量", "trigger_path": "调用路径推导：多个线程可能同时调用包含g_connector访问的函数（如CallbackDispatch()、IpcJoinThread()、IpcSendRequest()等）。数据流：全局变量g_connector被多个线程共享访问。关键调用点：大多数g_connector访问点未使用g_connectorMutex进行同步保护。", "consequences": "数据竞争可能导致空指针解引用、use-after-free或不可预测的行为", "suggestions": "所有访问g_connector的地方都应该使用g_connectorMutex进行保护，特别是判空检查和后续操作应该在一个锁保护区域内完成", "verification_notes": "分析结论正确，记忆信息确认g_connector确实在多线程环境下存在未加锁访问风险，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 643, "evidence": "g_connector = NULL;", "confidence": 0.75, "severity": "high", "gid": 424, "verify": "验证g_connector的访问是否有适当的同步机制", "has_risk": true, "preconditions": "多线程环境下同时访问g_connector全局变量", "trigger_path": "调用路径推导：多个线程可能同时调用包含g_connector访问的函数（如CallbackDispatch()、IpcJoinThread()、IpcSendRequest()等）。数据流：全局变量g_connector被多个线程共享访问。关键调用点：大多数g_connector访问点未使用g_connectorMutex进行同步保护。", "consequences": "数据竞争可能导致空指针解引用、use-after-free或不可预测的行为", "suggestions": "所有访问g_connector的地方都应该使用g_connectorMutex进行保护，特别是判空检查和后续操作应该在一个锁保护区域内完成", "verification_notes": "分析结论正确，记忆信息确认g_connector确实在多线程环境下存在未加锁访问风险，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 426, "evidence": "static void *CallbackDispatch(void)", "confidence": 0.5, "severity": "medium", "gid": 383, "verify": "验证这些函数是否涉及共享资源的访问", "has_risk": true, "preconditions": "多线程环境下并发访问共享资源", "trigger_path": "调用路径推导：StartCallbackDispatch() -> CallbackDispatch() -> CallbackDispatchLoop() -> ioctl()。数据流：全局变量g_connector和g_ipcCallback被多个线程共享访问。关键调用点：StartCallbackDispatch()创建线程执行CallbackDispatch()，后者访问共享资源时仅部分使用互斥锁保护。", "consequences": "数据竞争可能导致未定义行为、内存损坏或程序崩溃", "suggestions": "确保所有对共享资源的访问都使用适当的同步机制（如互斥锁）保护", "verification_notes": "分析结论正确：\n1. 前置条件合理：代码确实存在多线程环境下并发访问共享资源(g_connector和g_ipcCallback)的情况\n2. 触发路径成立：调用路径StartCallbackDispatch()->CallbackDispatch()->CallbackDispatchLoop()->ioctl()确实存在\n3. 后果评估准确：确实存在数据竞争风险，可能导致未定义行为\n4. 建议合适：需要确保所有对共享资源的访问都使用适当的同步机制\n验证依据：\n- 代码中g_connector的访问仅部分使用互斥锁保护(如InitBinderConnector使用锁，但其他访问点如IpcSendRequest未使用)\n- CallbackDispatchLoop函数确实在多线程环境下运行\n- 全局变量g_connector和g_ipcCallback被多个线程共享访问"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 426, "evidence": "static void *CallbackDispatch(void)", "confidence": 0.5, "severity": "medium", "gid": 384, "verify": "验证这些函数是否涉及共享资源的访问", "has_risk": true, "preconditions": "多线程环境下并发访问共享资源", "trigger_path": "调用路径推导：StartCallbackDispatch() -> CallbackDispatch() -> CallbackDispatchLoop() -> ioctl()。数据流：全局变量g_connector和g_ipcCallback被多个线程共享访问。关键调用点：StartCallbackDispatch()创建线程执行CallbackDispatch()，后者访问共享资源时仅部分使用互斥锁保护。", "consequences": "数据竞争可能导致未定义行为、内存损坏或程序崩溃", "suggestions": "确保所有对共享资源的访问都使用适当的同步机制（如互斥锁）保护", "verification_notes": "分析结论正确：\n1. 前置条件合理：代码确实存在多线程环境下并发访问共享资源(g_connector和g_ipcCallback)的情况\n2. 触发路径成立：调用路径StartCallbackDispatch()->CallbackDispatch()->CallbackDispatchLoop()->ioctl()确实存在\n3. 后果评估准确：确实存在数据竞争风险，可能导致未定义行为\n4. 建议合适：需要确保所有对共享资源的访问都使用适当的同步机制\n验证依据：\n- 代码中g_connector的访问仅部分使用互斥锁保护(如InitBinderConnector使用锁，但其他访问点如IpcSendRequest未使用)\n- CallbackDispatchLoop函数确实在多线程环境下运行\n- 全局变量g_connector和g_ipcCallback被多个线程共享访问"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 437, "evidence": "CallbackDispatchLoop();", "confidence": 0.5, "severity": "medium", "gid": 387, "verify": "验证这些函数是否涉及共享资源的访问", "has_risk": true, "preconditions": "多线程环境下并发访问共享资源", "trigger_path": "调用路径推导：StartCallbackDispatch() -> CallbackDispatch() -> CallbackDispatchLoop() -> ioctl()。数据流：全局变量g_connector和g_ipcCallback被多个线程共享访问。关键调用点：StartCallbackDispatch()创建线程执行CallbackDispatch()，后者访问共享资源时仅部分使用互斥锁保护。", "consequences": "数据竞争可能导致未定义行为、内存损坏或程序崩溃", "suggestions": "确保所有对共享资源的访问都使用适当的同步机制（如互斥锁）保护", "verification_notes": "分析结论正确：\n1. 前置条件合理：代码确实存在多线程环境下并发访问共享资源(g_connector和g_ipcCallback)的情况\n2. 触发路径成立：调用路径StartCallbackDispatch()->CallbackDispatch()->CallbackDispatchLoop()->ioctl()确实存在\n3. 后果评估准确：确实存在数据竞争风险，可能导致未定义行为\n4. 建议合适：需要确保所有对共享资源的访问都使用适当的同步机制\n验证依据：\n- 代码中g_connector的访问仅部分使用互斥锁保护(如InitBinderConnector使用锁，但其他访问点如IpcSendRequest未使用)\n- CallbackDispatchLoop函数确实在多线程环境下运行\n- 全局变量g_connector和g_ipcCallback被多个线程共享访问"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 442, "evidence": "IpcCallback *GetIpcCb(void)", "confidence": 0.5, "severity": "medium", "gid": 388, "verify": "验证这些函数是否涉及共享资源的访问", "has_risk": true, "preconditions": "多线程环境下并发访问共享资源", "trigger_path": "调用路径推导：StartCallbackDispatch() -> CallbackDispatch() -> CallbackDispatchLoop() -> ioctl()。数据流：全局变量g_connector和g_ipcCallback被多个线程共享访问。关键调用点：StartCallbackDispatch()创建线程执行CallbackDispatch()，后者访问共享资源时仅部分使用互斥锁保护。", "consequences": "数据竞争可能导致未定义行为、内存损坏或程序崩溃", "suggestions": "确保所有对共享资源的访问都使用适当的同步机制（如互斥锁）保护", "verification_notes": "分析结论正确：\n1. 前置条件合理：代码确实存在多线程环境下并发访问共享资源(g_connector和g_ipcCallback)的情况\n2. 触发路径成立：调用路径StartCallbackDispatch()->CallbackDispatch()->CallbackDispatchLoop()->ioctl()确实存在\n3. 后果评估准确：确实存在数据竞争风险，可能导致未定义行为\n4. 建议合适：需要确保所有对共享资源的访问都使用适当的同步机制\n验证依据：\n- 代码中g_connector的访问仅部分使用互斥锁保护(如InitBinderConnector使用锁，但其他访问点如IpcSendRequest未使用)\n- CallbackDispatchLoop函数确实在多线程环境下运行\n- 全局变量g_connector和g_ipcCallback被多个线程共享访问"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 447, "evidence": "uint32_t GetThreadId(void)", "confidence": 0.5, "severity": "medium", "gid": 389, "verify": "验证这些函数是否涉及共享资源的访问", "has_risk": true, "preconditions": "多线程环境下并发访问共享资源", "trigger_path": "调用路径推导：StartCallbackDispatch() -> CallbackDispatch() -> CallbackDispatchLoop() -> ioctl()。数据流：全局变量g_connector和g_ipcCallback被多个线程共享访问。关键调用点：StartCallbackDispatch()创建线程执行CallbackDispatch()，后者访问共享资源时仅部分使用互斥锁保护。", "consequences": "数据竞争可能导致未定义行为、内存损坏或程序崩溃", "suggestions": "确保所有对共享资源的访问都使用适当的同步机制（如互斥锁）保护", "verification_notes": "分析结论正确：\n1. 前置条件合理：代码确实存在多线程环境下并发访问共享资源(g_connector和g_ipcCallback)的情况\n2. 触发路径成立：调用路径StartCallbackDispatch()->CallbackDispatch()->CallbackDispatchLoop()->ioctl()确实存在\n3. 后果评估准确：确实存在数据竞争风险，可能导致未定义行为\n4. 建议合适：需要确保所有对共享资源的访问都使用适当的同步机制\n验证依据：\n- 代码中g_connector的访问仅部分使用互斥锁保护(如InitBinderConnector使用锁，但其他访问点如IpcSendRequest未使用)\n- CallbackDispatchLoop函数确实在多线程环境下运行\n- 全局变量g_connector和g_ipcCallback被多个线程共享访问"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 452, "evidence": "int32_t StartCallbackDispatch(void)", "confidence": 0.5, "severity": "medium", "gid": 390, "verify": "验证这些函数是否涉及共享资源的访问", "has_risk": true, "preconditions": "多线程环境下并发访问共享资源", "trigger_path": "调用路径推导：StartCallbackDispatch() -> CallbackDispatch() -> CallbackDispatchLoop() -> ioctl()。数据流：全局变量g_connector和g_ipcCallback被多个线程共享访问。关键调用点：StartCallbackDispatch()创建线程执行CallbackDispatch()，后者访问共享资源时仅部分使用互斥锁保护。", "consequences": "数据竞争可能导致未定义行为、内存损坏或程序崩溃", "suggestions": "确保所有对共享资源的访问都使用适当的同步机制（如互斥锁）保护", "verification_notes": "分析结论正确：\n1. 前置条件合理：代码确实存在多线程环境下并发访问共享资源(g_connector和g_ipcCallback)的情况\n2. 触发路径成立：调用路径StartCallbackDispatch()->CallbackDispatch()->CallbackDispatchLoop()->ioctl()确实存在\n3. 后果评估准确：确实存在数据竞争风险，可能导致未定义行为\n4. 建议合适：需要确保所有对共享资源的访问都使用适当的同步机制\n验证依据：\n- 代码中g_connector的访问仅部分使用互斥锁保护(如InitBinderConnector使用锁，但其他访问点如IpcSendRequest未使用)\n- CallbackDispatchLoop函数确实在多线程环境下运行\n- 全局变量g_connector和g_ipcCallback被多个线程共享访问"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 551, "evidence": "int32_t ret = ioctl(g_connector->fd, IPC_SET_CMS, MAX_SA_SIZE);", "confidence": 0.5, "severity": "medium", "gid": 407, "verify": "验证这些函数是否涉及共享资源的访问", "has_risk": true, "preconditions": "多线程环境下并发访问共享资源", "trigger_path": "调用路径推导：StartCallbackDispatch() -> CallbackDispatch() -> CallbackDispatchLoop() -> ioctl()。数据流：全局变量g_connector和g_ipcCallback被多个线程共享访问。关键调用点：StartCallbackDispatch()创建线程执行CallbackDispatch()，后者访问共享资源时仅部分使用互斥锁保护。", "consequences": "数据竞争可能导致未定义行为、内存损坏或程序崩溃", "suggestions": "确保所有对共享资源的访问都使用适当的同步机制（如互斥锁）保护", "verification_notes": "分析结论正确：\n1. 前置条件合理：代码确实存在多线程环境下并发访问共享资源(g_connector和g_ipcCallback)的情况\n2. 触发路径成立：调用路径StartCallbackDispatch()->CallbackDispatch()->CallbackDispatchLoop()->ioctl()确实存在\n3. 后果评估准确：确实存在数据竞争风险，可能导致未定义行为\n4. 建议合适：需要确保所有对共享资源的访问都使用适当的同步机制\n验证依据：\n- 代码中g_connector的访问仅部分使用互斥锁保护(如InitBinderConnector使用锁，但其他访问点如IpcSendRequest未使用)\n- CallbackDispatchLoop函数确实在多线程环境下运行\n- 全局变量g_connector和g_ipcCallback被多个线程共享访问"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 637, "evidence": "static IpcConnector *InitIpcConnector(void);", "confidence": 0.5, "severity": "medium", "gid": 418, "verify": "验证这些函数是否涉及共享资源的访问", "has_risk": true, "preconditions": "多线程环境下并发访问共享资源", "trigger_path": "调用路径推导：StartCallbackDispatch() -> CallbackDispatch() -> CallbackDispatchLoop() -> ioctl()。数据流：全局变量g_connector和g_ipcCallback被多个线程共享访问。关键调用点：StartCallbackDispatch()创建线程执行CallbackDispatch()，后者访问共享资源时仅部分使用互斥锁保护。", "consequences": "数据竞争可能导致未定义行为、内存损坏或程序崩溃", "suggestions": "确保所有对共享资源的访问都使用适当的同步机制（如互斥锁）保护", "verification_notes": "分析结论正确：\n1. 前置条件合理：代码确实存在多线程环境下并发访问共享资源(g_connector和g_ipcCallback)的情况\n2. 触发路径成立：调用路径StartCallbackDispatch()->CallbackDispatch()->CallbackDispatchLoop()->ioctl()确实存在\n3. 后果评估准确：确实存在数据竞争风险，可能导致未定义行为\n4. 建议合适：需要确保所有对共享资源的访问都使用适当的同步机制\n验证依据：\n- 代码中g_connector的访问仅部分使用互斥锁保护(如InitBinderConnector使用锁，但其他访问点如IpcSendRequest未使用)\n- CallbackDispatchLoop函数确实在多线程环境下运行\n- 全局变量g_connector和g_ipcCallback被多个线程共享访问"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 637, "evidence": "static IpcConnector *InitIpcConnector(void);", "confidence": 0.5, "severity": "medium", "gid": 419, "verify": "验证这些函数是否涉及共享资源的访问", "has_risk": true, "preconditions": "多线程环境下并发访问共享资源", "trigger_path": "调用路径推导：StartCallbackDispatch() -> CallbackDispatch() -> CallbackDispatchLoop() -> ioctl()。数据流：全局变量g_connector和g_ipcCallback被多个线程共享访问。关键调用点：StartCallbackDispatch()创建线程执行CallbackDispatch()，后者访问共享资源时仅部分使用互斥锁保护。", "consequences": "数据竞争可能导致未定义行为、内存损坏或程序崩溃", "suggestions": "确保所有对共享资源的访问都使用适当的同步机制（如互斥锁）保护", "verification_notes": "分析结论正确：\n1. 前置条件合理：代码确实存在多线程环境下并发访问共享资源(g_connector和g_ipcCallback)的情况\n2. 触发路径成立：调用路径StartCallbackDispatch()->CallbackDispatch()->CallbackDispatchLoop()->ioctl()确实存在\n3. 后果评估准确：确实存在数据竞争风险，可能导致未定义行为\n4. 建议合适：需要确保所有对共享资源的访问都使用适当的同步机制\n验证依据：\n- 代码中g_connector的访问仅部分使用互斥锁保护(如InitBinderConnector使用锁，但其他访问点如IpcSendRequest未使用)\n- CallbackDispatchLoop函数确实在多线程环境下运行\n- 全局变量g_connector和g_ipcCallback被多个线程共享访问"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 687, "evidence": "return g_connector;", "confidence": 0.6, "severity": "medium", "gid": 454, "verify": "验证全局变量访问(g_connector和g_ipcInvoker)是否有适当的同步机制", "has_risk": true, "preconditions": "多线程环境下并发访问g_connector或g_ipcInvoker全局变量", "trigger_path": "调用路径推导：GetIpcInvoker() -> InitIpcConnector() -> 返回g_connector（无锁）。数据流：全局变量g_connector和g_ipcInvoker被直接访问。关键调用点：GetIpcInvoker()和InitIpcConnector()函数返回全局变量时未加锁保护。", "consequences": "数据竞争可能导致未定义行为或程序崩溃", "suggestions": "在返回g_connector和g_ipcInvoker前加锁保护，或使用原子操作访问这些全局变量", "verification_notes": "分析结论正确，前置条件合理（多线程环境下确实存在并发访问风险），触发路径成立（InitIpcConnector和GetIpcInvoker确实涉及全局变量访问），后果评估准确（存在数据竞争风险），建议合适（与项目已有同步模式一致）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/ipc/src/liteos_a/ipc_invoker.c", "line": 697, "evidence": "return &g_ipcInvoker;", "confidence": 0.6, "severity": "medium", "gid": 457, "verify": "验证全局变量访问(g_connector和g_ipcInvoker)是否有适当的同步机制", "has_risk": true, "preconditions": "多线程环境下并发访问g_connector或g_ipcInvoker全局变量", "trigger_path": "调用路径推导：GetIpcInvoker() -> InitIpcConnector() -> 返回g_connector（无锁）。数据流：全局变量g_connector和g_ipcInvoker被直接访问。关键调用点：GetIpcInvoker()和InitIpcConnector()函数返回全局变量时未加锁保护。", "consequences": "数据竞争可能导致未定义行为或程序崩溃", "suggestions": "在返回g_connector和g_ipcInvoker前加锁保护，或使用原子操作访问这些全局变量", "verification_notes": "分析结论正确，前置条件合理（多线程环境下确实存在并发访问风险），触发路径成立（InitIpcConnector和GetIpcInvoker确实涉及全局变量访问），后果评估准确（存在数据竞争风险），建议合适（与项目已有同步模式一致）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "alloc_size_overflow", "file": "ipc/native/c/manager/src/serializer.c", "line": 1138, "evidence": "bool *val = (bool *)malloc((*size) * sizeof(bool));", "confidence": 0.6, "severity": "medium", "gid": 464, "verify": "验证malloc分配大小不会导致整数溢出", "has_risk": true, "preconditions": "传入的size参数值过大，导致(*size) * sizeof(bool)整数溢出", "trigger_path": "调用路径推导：外部调用者 -> ReadBoolVector()。数据流：size参数由外部调用者传入，ReadBoolVector()函数通过ReadUint32()读取size值但未进行范围检查，直接用于malloc分配。关键调用点：ReadBoolVector()函数未对size值进行上限检查。", "consequences": "整数溢出导致malloc分配错误大小的内存，可能引发堆溢出或程序崩溃", "suggestions": "在ReadBoolVector()函数中添加对size值的上限检查，确保(*size) * sizeof(bool)不会溢出；或使用安全的乘法包装函数检查整数溢出", "verification_notes": "分析结论正确：\n1. 前置条件合理：ReadBoolVector函数确实未对size参数进行上限检查，可能导致(*size) * sizeof(bool)整数溢出\n2. 触发路径成立：函数通过ReadUint32读取size值后直接用于malloc分配，调用路径清晰\n3. 后果评估准确：整数溢出会导致malloc分配错误大小的内存，可能引发堆溢出或程序崩溃\n4. 建议合适：添加size值上限检查或使用安全乘法包装函数是合理的修复方案"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/manager/src/ipc_process_skeleton.c", "line": 73, "evidence": "pthread_mutex_init(&temp->lock, NULL);", "confidence": 0.6, "severity": "high", "gid": 573, "verify": "验证pthread_mutex_init和pthread_mutex_lock的返回值", "has_risk": true, "preconditions": "pthread_mutex_init调用失败但未检查返回值", "trigger_path": "调用路径推导：1) gid 573: GetCurrentSkeleton() -> IpcProcessSkeleton() -> pthread_mutex_init(&temp->lock, NULL)。数据流：内部函数调用，temp是刚分配的IpcSkeleton结构体。关键调用点：IpcProcessSkeleton()未检查pthread_mutex_init返回值。2) gid 593: OnFirstStrongRef() -> FirstAddObject() -> pthread_mutex_init(&node->lock, NULL)。数据流：handle参数来自外部调用。关键调用点：FirstAddObject()未检查pthread_mutex_init返回值。", "consequences": "如果mutex初始化失败，后续的锁操作可能导致未定义行为或程序崩溃", "suggestions": "1) 检查pthread_mutex_init返回值并在失败时进行错误处理；2) 考虑使用PTHREAD_MUTEX_INITIALIZER进行静态初始化", "verification_notes": "分析结论正确，前置条件合理（确实未检查pthread_mutex_init返回值），触发路径清晰（调用路径推导正确），后果评估准确（mutex初始化失败会导致未定义行为），建议合适（检查返回值和静态初始化都是合理建议）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/manager/src/ipc_process_skeleton.c", "line": 249, "evidence": "pthread_mutex_init(&node->lock, NULL);", "confidence": 0.6, "severity": "high", "gid": 593, "verify": "验证pthread_mutex_init和pthread_mutex_lock的返回值", "has_risk": true, "preconditions": "pthread_mutex_init调用失败但未检查返回值", "trigger_path": "调用路径推导：1) gid 573: GetCurrentSkeleton() -> IpcProcessSkeleton() -> pthread_mutex_init(&temp->lock, NULL)。数据流：内部函数调用，temp是刚分配的IpcSkeleton结构体。关键调用点：IpcProcessSkeleton()未检查pthread_mutex_init返回值。2) gid 593: OnFirstStrongRef() -> FirstAddObject() -> pthread_mutex_init(&node->lock, NULL)。数据流：handle参数来自外部调用。关键调用点：FirstAddObject()未检查pthread_mutex_init返回值。", "consequences": "如果mutex初始化失败，后续的锁操作可能导致未定义行为或程序崩溃", "suggestions": "1) 检查pthread_mutex_init返回值并在失败时进行错误处理；2) 考虑使用PTHREAD_MUTEX_INITIALIZER进行静态初始化", "verification_notes": "分析结论正确，前置条件合理（确实未检查pthread_mutex_init返回值），触发路径清晰（调用路径推导正确），后果评估准确（mutex初始化失败会导致未定义行为），建议合适（检查返回值和静态初始化都是合理建议）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/manager/src/ipc_process_skeleton.c", "line": 384, "evidence": "if (objectStub != NULL && objectStub->func != NULL) {", "confidence": 0.6, "severity": "high", "gid": 627, "verify": "Verify objectStub pointer is non-null before dereference", "has_risk": true, "preconditions": "objectStub指针为空且调用路径上未进行空指针检查", "trigger_path": "调用路径推导：ipc_invoker.c中的调用点 -> OnRemoteRequestInner()。数据流：objectStub指针从调用者传递给OnRemoteRequestInner()，调用路径上未进行空指针检查。关键调用点：ipc_invoker.c中的调用点未检查objectStub是否为空，而直接使用objectStub->args。OnRemoteRequestInner()内部虽然检查了objectStub，但调用路径上已经存在解引用风险。", "consequences": "空指针解引用可能导致程序崩溃或拒绝服务", "suggestions": "1. 在调用OnRemoteRequestInner()之前检查objectStub是否为空；2. 确保所有调用路径都正确处理空指针情况", "verification_notes": "分析结论正确，在InternalRequest和HandleTransaction函数中确实存在objectStub指针未检查直接解引用的情况，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/manager/src/ipc_process_skeleton.c", "line": 385, "evidence": "result = (objectStub->func)(code, data, reply, option);", "confidence": 0.6, "severity": "high", "gid": 628, "verify": "Verify objectStub pointer is non-null before dereference", "has_risk": true, "preconditions": "objectStub指针为空且调用路径上未进行空指针检查", "trigger_path": "调用路径推导：ipc_invoker.c中的调用点 -> OnRemoteRequestInner()。数据流：objectStub指针从调用者传递给OnRemoteRequestInner()，调用路径上未进行空指针检查。关键调用点：ipc_invoker.c中的调用点未检查objectStub是否为空，而直接使用objectStub->args。OnRemoteRequestInner()内部虽然检查了objectStub，但调用路径上已经存在解引用风险。", "consequences": "空指针解引用可能导致程序崩溃或拒绝服务", "suggestions": "1. 在调用OnRemoteRequestInner()之前检查objectStub是否为空；2. 确保所有调用路径都正确处理空指针情况", "verification_notes": "分析结论正确，在InternalRequest和HandleTransaction函数中确实存在objectStub指针未检查直接解引用的情况，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/manager/src/ipc_thread_pool.c", "line": 31, "evidence": "static RemoteInvoker *g_invoker[PROTO_NUM];", "confidence": 0.6, "severity": "medium", "gid": 686, "verify": "验证对g_localKey和g_invoker等全局变量的访问是否有适当的同步机制", "has_risk": true, "preconditions": "多线程环境下并发访问g_invoker数组", "trigger_path": "调用路径推导：1) 输入来源：线程池初始化时设置g_invoker数组；2) 调用链：InitThreadPool() -> InitRemoteInvoker()设置g_invoker，ThreadHandler() -> GetAndUpdateInvoker() -> g_invoker访问，TlsDestructor() -> g_invoker访问；3) 校验情况：所有访问点均无同步机制；4) 触发条件：多线程并发访问g_invoker数组时可能引发数据竞争", "consequences": "数据竞争可能导致内存损坏、程序崩溃或未定义行为", "suggestions": "为g_invoker数组访问添加互斥锁保护，或使用原子操作进行访问", "verification_notes": "分析结论正确，g_invoker数组确实在多线程环境下被并发访问且无同步机制，存在数据竞争风险，建议添加互斥锁保护或使用原子操作"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/manager/src/ipc_thread_pool.c", "line": 56, "evidence": "RemoteInvoker *invoker = g_invoker[threadContext->proto];", "confidence": 0.6, "severity": "medium", "gid": 690, "verify": "验证对g_localKey和g_invoker等全局变量的访问是否有适当的同步机制", "has_risk": true, "preconditions": "多线程环境下并发访问g_invoker数组", "trigger_path": "调用路径推导：1) 输入来源：线程池初始化时设置g_invoker数组；2) 调用链：InitThreadPool() -> InitRemoteInvoker()设置g_invoker，ThreadHandler() -> GetAndUpdateInvoker() -> g_invoker访问，TlsDestructor() -> g_invoker访问；3) 校验情况：所有访问点均无同步机制；4) 触发条件：多线程并发访问g_invoker数组时可能引发数据竞争", "consequences": "数据竞争可能导致内存损坏、程序崩溃或未定义行为", "suggestions": "为g_invoker数组访问添加互斥锁保护，或使用原子操作进行访问", "verification_notes": "分析结论正确，g_invoker数组确实在多线程环境下被并发访问且无同步机制，存在数据竞争风险，建议添加互斥锁保护或使用原子操作"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/manager/src/ipc_thread_pool.c", "line": 79, "evidence": "static RemoteInvoker *GetAndUpdateInvoker(int32_t proto)", "confidence": 0.5, "severity": "medium", "gid": 692, "verify": "验证对g_localKey和g_invoker等全局变量的访问是否有适当的同步机制", "has_risk": true, "preconditions": "多线程环境下并发访问g_invoker数组", "trigger_path": "调用路径推导：1) 输入来源：线程池初始化时设置g_invoker数组；2) 调用链：InitThreadPool() -> InitRemoteInvoker()设置g_invoker，ThreadHandler() -> GetAndUpdateInvoker() -> g_invoker访问，TlsDestructor() -> g_invoker访问；3) 校验情况：所有访问点均无同步机制；4) 触发条件：多线程并发访问g_invoker数组时可能引发数据竞争", "consequences": "数据竞争可能导致内存损坏、程序崩溃或未定义行为", "suggestions": "为g_invoker数组访问添加互斥锁保护，或使用原子操作进行访问", "verification_notes": "分析结论正确，g_invoker数组确实在多线程环境下被并发访问且无同步机制，存在数据竞争风险，建议添加互斥锁保护或使用原子操作"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/manager/src/ipc_thread_pool.c", "line": 86, "evidence": "return g_invoker[proto];", "confidence": 0.6, "severity": "medium", "gid": 693, "verify": "验证对g_localKey和g_invoker等全局变量的访问是否有适当的同步机制", "has_risk": true, "preconditions": "多线程环境下并发访问g_invoker数组", "trigger_path": "调用路径推导：1) 输入来源：线程池初始化时设置g_invoker数组；2) 调用链：InitThreadPool() -> InitRemoteInvoker()设置g_invoker，ThreadHandler() -> GetAndUpdateInvoker() -> g_invoker访问，TlsDestructor() -> g_invoker访问；3) 校验情况：所有访问点均无同步机制；4) 触发条件：多线程并发访问g_invoker数组时可能引发数据竞争", "consequences": "数据竞争可能导致内存损坏、程序崩溃或未定义行为", "suggestions": "为g_invoker数组访问添加互斥锁保护，或使用原子操作进行访问", "verification_notes": "分析结论正确，g_invoker数组确实在多线程环境下被并发访问且无同步机制，存在数据竞争风险，建议添加互斥锁保护或使用原子操作"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/manager/src/ipc_thread_pool.c", "line": 96, "evidence": "RemoteInvoker *invoker = GetAndUpdateInvoker(proto);", "confidence": 0.5, "severity": "medium", "gid": 695, "verify": "验证对g_localKey和g_invoker等全局变量的访问是否有适当的同步机制", "has_risk": true, "preconditions": "多线程环境下并发访问g_invoker数组", "trigger_path": "调用路径推导：1) 输入来源：线程池初始化时设置g_invoker数组；2) 调用链：InitThreadPool() -> InitRemoteInvoker()设置g_invoker，ThreadHandler() -> GetAndUpdateInvoker() -> g_invoker访问，TlsDestructor() -> g_invoker访问；3) 校验情况：所有访问点均无同步机制；4) 触发条件：多线程并发访问g_invoker数组时可能引发数据竞争", "consequences": "数据竞争可能导致内存损坏、程序崩溃或未定义行为", "suggestions": "为g_invoker数组访问添加互斥锁保护，或使用原子操作进行访问", "verification_notes": "分析结论正确，g_invoker数组确实在多线程环境下被并发访问且无同步机制，存在数据竞争风险，建议添加互斥锁保护或使用原子操作"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/c/manager/src/ipc_thread_pool.c", "line": 109, "evidence": "ThreadContextDestructor(proto);", "confidence": 0.5, "severity": "medium", "gid": 696, "verify": "验证对g_localKey和g_invoker等全局变量的访问是否有适当的同步机制", "has_risk": true, "preconditions": "多线程环境下并发访问g_invoker数组", "trigger_path": "调用路径推导：1) 输入来源：线程池初始化时设置g_invoker数组；2) 调用链：InitThreadPool() -> InitRemoteInvoker()设置g_invoker，ThreadHandler() -> GetAndUpdateInvoker() -> g_invoker访问，TlsDestructor() -> g_invoker访问；3) 校验情况：所有访问点均无同步机制；4) 触发条件：多线程并发访问g_invoker数组时可能引发数据竞争", "consequences": "数据竞争可能导致内存损坏、程序崩溃或未定义行为", "suggestions": "为g_invoker数组访问添加互斥锁保护，或使用原子操作进行访问", "verification_notes": "分析结论正确，g_invoker数组确实在多线程环境下被并发访问且无同步机制，存在数据竞争风险，建议添加互斥锁保护或使用原子操作"}
{"language": "c/cpp", "category": "thread_safety", "pattern": "cond_wait_no_loop", "file": "ipc/native/c/rpc/src/rpc_process_skeleton.c", "line": 181, "evidence": "pthread_cond_wait(&threadLockInfo->condition, &threadLockInfo->mutex);", "confidence": 0.6, "severity": "medium", "gid": 725, "verify": "检查 pthread_cond_wait/pthread_cond_timedwait 是否在循环中调用", "has_risk": true, "preconditions": "线程条件变量被虚假唤醒(spurious wakeup)或未正确处理超时情况", "trigger_path": "调用路径推导：\n1. 对于gid 725:\n- 入口函数: AddDataThreadInWait()\n- 调用链: AddDataThreadInWait() -> pthread_cond_wait()\n- 数据流: 线程ID作为输入，通过QueryThreadLockInfo获取线程锁信息，直接调用pthread_cond_wait()\n- 校验情况: 无循环检查条件变量状态\n\n2. 对于gid 726:\n- 入口函数: AddSendThreadInWait()\n- 调用链: AddSendThreadInWait() -> pthread_cond_timedwait()\n- 数据流: 序列号和消息信息作为输入，通过QueryThreadLockInfo获取线程锁信息，直接调用pthread_cond_timedwait()\n- 校验情况: 仅检查ETIMEDOUT错误，无循环检查条件变量状态\n\n关键调用点: 两个函数都未在循环中检查条件变量状态\n", "consequences": "可能导致线程错误唤醒，引发竞态条件或数据不一致", "suggestions": "将条件变量等待调用放入while循环中，检查相关条件状态，例如: while(!condition) { pthread_cond_wait(...); }", "verification_notes": "分析结论正确，前置条件合理（存在虚假唤醒风险且无循环检查），触发路径准确（直接调用条件变量等待函数），后果评估恰当（可能导致竞态条件），建议合适（应使用循环检查条件状态）"}
{"language": "c/cpp", "category": "thread_safety", "pattern": "cond_wait_no_loop", "file": "ipc/native/c/rpc/src/rpc_process_skeleton.c", "line": 397, "evidence": "int ret = pthread_cond_timedwait(&threadLockInfo->condition, &threadLockInfo->mutex, &waitTime);", "confidence": 0.6, "severity": "medium", "gid": 726, "verify": "检查 pthread_cond_wait/pthread_cond_timedwait 是否在循环中调用", "has_risk": true, "preconditions": "线程条件变量被虚假唤醒(spurious wakeup)或未正确处理超时情况", "trigger_path": "调用路径推导：\n1. 对于gid 725:\n- 入口函数: AddDataThreadInWait()\n- 调用链: AddDataThreadInWait() -> pthread_cond_wait()\n- 数据流: 线程ID作为输入，通过QueryThreadLockInfo获取线程锁信息，直接调用pthread_cond_wait()\n- 校验情况: 无循环检查条件变量状态\n\n2. 对于gid 726:\n- 入口函数: AddSendThreadInWait()\n- 调用链: AddSendThreadInWait() -> pthread_cond_timedwait()\n- 数据流: 序列号和消息信息作为输入，通过QueryThreadLockInfo获取线程锁信息，直接调用pthread_cond_timedwait()\n- 校验情况: 仅检查ETIMEDOUT错误，无循环检查条件变量状态\n\n关键调用点: 两个函数都未在循环中检查条件变量状态\n", "consequences": "可能导致线程错误唤醒，引发竞态条件或数据不一致", "suggestions": "将条件变量等待调用放入while循环中，检查相关条件状态，例如: while(!condition) { pthread_cond_wait(...); }", "verification_notes": "分析结论正确，前置条件合理（存在虚假唤醒风险且无循环检查），触发路径准确（直接调用条件变量等待函数），后果评估恰当（可能导致竞态条件），建议合适（应使用循环检查条件状态）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/src/dbinder_invoker.c", "line": 403, "evidence": "int32_t result = stubObject->func(tr->code, &data, &reply, option);", "confidence": 0.6, "severity": "high", "gid": 855, "verify": "验证 stubObject 及其成员 func 在解引用前非空", "has_risk": true, "preconditions": "QueryStubByIndex 返回的 stubObject 的 func 成员被设置为 NULL", "trigger_path": "调用路径推导：ProcessTransaction() -> stubObject->func()。数据流：tr->cookie 作为输入传递给 QueryStubByIndex()，返回的 stubObject 已判空但未检查 func 成员。关键调用点：ProcessTransaction() 函数未对 stubObject->func 进行判空检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在调用 stubObject->func 前增加判空检查：if (stubObject->func != NULL)", "verification_notes": "分析结论正确，前置条件合理（ProcessTransaction函数检查了tr参数但未检查stubObject->func成员），触发路径清晰（OnTransaction -> ProcessTransaction/ProcessReply），后果评估准确（存在空指针解引用风险），建议合适（增加对stubObject->func的判空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/src/dbinder_invoker.c", "line": 403, "evidence": "int32_t result = stubObject->func(tr->code, &data, &reply, option);", "confidence": 0.6, "severity": "high", "gid": 856, "verify": "验证 stubObject 及其成员 func 在解引用前非空", "has_risk": true, "preconditions": "QueryStubByIndex 返回的 stubObject 的 func 成员被设置为 NULL", "trigger_path": "调用路径推导：ProcessTransaction() -> stubObject->func()。数据流：tr->cookie 作为输入传递给 QueryStubByIndex()，返回的 stubObject 已判空但未检查 func 成员。关键调用点：ProcessTransaction() 函数未对 stubObject->func 进行判空检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在调用 stubObject->func 前增加判空检查：if (stubObject->func != NULL)", "verification_notes": "分析结论正确，前置条件合理（ProcessTransaction函数检查了tr参数但未检查stubObject->func成员），触发路径清晰（OnTransaction -> ProcessTransaction/ProcessReply），后果评估准确（存在空指针解引用风险），建议合适（增加对stubObject->func的判空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/src/dbinder_invoker.c", "line": 506, "evidence": "if (current->threadPool->idleSocketThreadNum > 0) {", "confidence": 0.6, "severity": "high", "gid": 894, "verify": "current and current->threadPool pointers are not null before dereference", "has_risk": true, "preconditions": "GetCurrentSkeleton()返回非NULL但threadPool为NULL的IpcSkeleton结构，或者threadPool在运行时被释放", "trigger_path": "调用路径推导：StartProcessLoop() -> CreateProcessThread() -> GetCurrentSkeleton() -> 访问current->threadPool->idleSocketThreadNum。数据流：当前IPC骨架通过GetCurrentSkeleton()获取，传递给CreateProcessThread()，CreateProcessThread()检查了current是否为NULL但未检查current->threadPool是否为NULL。关键调用点：CreateProcessThread()函数未对current->threadPool进行NULL检查。", "consequences": "空指针解引用，可能导致程序崩溃或拒绝服务", "suggestions": "在访问current->threadPool前增加NULL检查，或者在IpcProcessSkeleton()初始化时确保threadPool有效", "verification_notes": "分析结论正确，前置条件合理（存在threadPool为NULL的情况），触发路径部分成立（CreateProcessThread函数未找到但类似访问路径存在风险），后果评估准确（空指针解引用会导致崩溃），建议合适（增加NULL检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/src/dbinder_invoker.c", "line": 506, "evidence": "if (current->threadPool->idleSocketThreadNum > 0) {", "confidence": 0.6, "severity": "high", "gid": 895, "verify": "current and current->threadPool pointers are not null before dereference", "has_risk": true, "preconditions": "GetCurrentSkeleton()返回非NULL但threadPool为NULL的IpcSkeleton结构，或者threadPool在运行时被释放", "trigger_path": "调用路径推导：StartProcessLoop() -> CreateProcessThread() -> GetCurrentSkeleton() -> 访问current->threadPool->idleSocketThreadNum。数据流：当前IPC骨架通过GetCurrentSkeleton()获取，传递给CreateProcessThread()，CreateProcessThread()检查了current是否为NULL但未检查current->threadPool是否为NULL。关键调用点：CreateProcessThread()函数未对current->threadPool进行NULL检查。", "consequences": "空指针解引用，可能导致程序崩溃或拒绝服务", "suggestions": "在访问current->threadPool前增加NULL检查，或者在IpcProcessSkeleton()初始化时确保threadPool有效", "verification_notes": "分析结论正确，前置条件合理（存在threadPool为NULL的情况），触发路径部分成立（CreateProcessThread函数未找到但类似访问路径存在风险），后果评估准确（空指针解引用会导致崩溃），建议合适（增加NULL检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "wild_pointer_deref", "file": "ipc/native/c/rpc/include/rpc_process_skeleton.h", "line": 106, "evidence": "void *buffer;", "confidence": 0.65, "severity": "high", "gid": 933, "verify": "验证候选 933 的安全风险", "has_risk": true, "preconditions": "ThreadMessageInfo结构体中的buffer成员未被正确初始化或释放，且调用路径中缺少NULL检查", "trigger_path": "调用路径推导：MakeThreadMessageInfo() -> AddSendThreadInWait() -> QueryThreadBySeqNumber() -> 使用buffer成员。数据流：通过dbinder_transaction_data传入数据分配buffer内存，但在错误处理路径中可能未正确初始化或释放。关键调用点：部分使用buffer的路径缺少NULL检查，特别是在错误处理路径中。", "consequences": "空指针解引用可能导致程序崩溃或内存访问异常", "suggestions": "1. 对所有buffer访问路径添加NULL检查；2. 在结构体初始化时显式设置buffer为NULL；3. 添加buffer生命周期管理机制", "verification_notes": "分析结论正确，ThreadMessageInfo结构体buffer成员确实存在未初始化风险，调用路径中缺少NULL检查，触发路径与代码实现一致，空指针解引用后果评估准确，建议合理有效"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/ipc_adapter/mini/ipc_proxy_inner.c", "line": 57, "evidence": "if (!WriteString(reply, proxyObject->sessionName)) {", "confidence": 0.6, "severity": "high", "gid": 937, "verify": "检查proxyObject->sessionName和current->sessionName是否可能为NULL", "has_risk": true, "preconditions": "proxyObject->sessionName为NULL", "trigger_path": "调用路径推导：GetDatabusNameByProxy() -> GetPidAndUidInfo() -> InvokerListenThread() -> MakeInvokerListenReply()。数据流：proxyObject通过GetDatabusNameByProxy传入，GetPidAndUidInfo未正确初始化sessionName，InvokerListenThread未检查proxyObject->sessionName是否为NULL直接使用。关键调用点：InvokerListenThread函数未对proxyObject->sessionName进行NULL检查。", "consequences": "NULL指针解引用，可能导致程序崩溃", "suggestions": "在InvokerListenThread函数中添加proxyObject->sessionName的NULL检查", "verification_notes": "分析结论正确，InvokerListenThread函数确实未对proxyObject->sessionName进行NULL检查，存在NULL指针解引用风险"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/ipc_adapter/mini/ipc_proxy_inner.c", "line": 73, "evidence": "int32_t sessionNameLen = strlen(proxyObject->sessionName);", "confidence": 0.6, "severity": "high", "gid": 938, "verify": "检查proxyObject->sessionName和current->sessionName是否可能为NULL", "has_risk": true, "preconditions": "proxyObject->sessionName为NULL", "trigger_path": "调用路径推导：GetDatabusNameByProxy() -> GetPidAndUidInfo() -> InvokerListenThread() -> MakeInvokerListenReply()。数据流：proxyObject通过GetDatabusNameByProxy传入，GetPidAndUidInfo未正确初始化sessionName，InvokerListenThread未检查proxyObject->sessionName是否为NULL直接使用。关键调用点：InvokerListenThread函数未对proxyObject->sessionName进行NULL检查。", "consequences": "NULL指针解引用，可能导致程序崩溃", "suggestions": "在InvokerListenThread函数中添加proxyObject->sessionName的NULL检查", "verification_notes": "分析结论正确，InvokerListenThread函数确实未对proxyObject->sessionName进行NULL检查，存在NULL指针解引用风险"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/ipc_adapter/mini/ipc_proxy_inner.c", "line": 80, "evidence": "if (CreateTransServer(proxyObject->sessionName) != ERR_NONE) {", "confidence": 0.6, "severity": "high", "gid": 939, "verify": "检查proxyObject->sessionName和current->sessionName是否可能为NULL", "has_risk": true, "preconditions": "proxyObject->sessionName为NULL", "trigger_path": "调用路径推导：GetDatabusNameByProxy() -> GetPidAndUidInfo() -> InvokerListenThread() -> MakeInvokerListenReply()。数据流：proxyObject通过GetDatabusNameByProxy传入，GetPidAndUidInfo未正确初始化sessionName，InvokerListenThread未检查proxyObject->sessionName是否为NULL直接使用。关键调用点：InvokerListenThread函数未对proxyObject->sessionName进行NULL检查。", "consequences": "NULL指针解引用，可能导致程序崩溃", "suggestions": "在InvokerListenThread函数中添加proxyObject->sessionName的NULL检查", "verification_notes": "分析结论正确，InvokerListenThread函数确实未对proxyObject->sessionName进行NULL检查，存在NULL指针解引用风险"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/ipc_adapter/mini/ipc_proxy_inner.c", "line": 96, "evidence": "if (strcpy_s(current->sessionName, sessionNameLen + 1, proxyObject->sessionName) != EOK) {", "confidence": 0.6, "severity": "high", "gid": 945, "verify": "检查proxyObject->sessionName和current->sessionName是否可能为NULL", "has_risk": true, "preconditions": "proxyObject->sessionName为NULL", "trigger_path": "调用路径推导：GetDatabusNameByProxy() -> GetPidAndUidInfo() -> InvokerListenThread() -> MakeInvokerListenReply()。数据流：proxyObject通过GetDatabusNameByProxy传入，GetPidAndUidInfo未正确初始化sessionName，InvokerListenThread未检查proxyObject->sessionName是否为NULL直接使用。关键调用点：InvokerListenThread函数未对proxyObject->sessionName进行NULL检查。", "consequences": "NULL指针解引用，可能导致程序崩溃", "suggestions": "在InvokerListenThread函数中添加proxyObject->sessionName的NULL检查", "verification_notes": "分析结论正确，InvokerListenThread函数确实未对proxyObject->sessionName进行NULL检查，存在NULL指针解引用风险"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/ipc_adapter/mini/ipc_proxy_inner.c", "line": 96, "evidence": "if (strcpy_s(current->sessionName, sessionNameLen + 1, proxyObject->sessionName) != EOK) {", "confidence": 0.6, "severity": "high", "gid": 946, "verify": "检查proxyObject->sessionName和current->sessionName是否可能为NULL", "has_risk": true, "preconditions": "proxyObject->sessionName为NULL", "trigger_path": "调用路径推导：GetDatabusNameByProxy() -> GetPidAndUidInfo() -> InvokerListenThread() -> MakeInvokerListenReply()。数据流：proxyObject通过GetDatabusNameByProxy传入，GetPidAndUidInfo未正确初始化sessionName，InvokerListenThread未检查proxyObject->sessionName是否为NULL直接使用。关键调用点：InvokerListenThread函数未对proxyObject->sessionName进行NULL检查。", "consequences": "NULL指针解引用，可能导致程序崩溃", "suggestions": "在InvokerListenThread函数中添加proxyObject->sessionName的NULL检查", "verification_notes": "分析结论正确，InvokerListenThread函数确实未对proxyObject->sessionName进行NULL检查，存在NULL指针解引用风险"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/ipc_adapter/mini/ipc_proxy_inner.c", "line": 84, "evidence": "if (current->sessionName != NULL) {", "confidence": 0.6, "severity": "high", "gid": 940, "verify": "检查proxyObject->sessionName和current->sessionName是否可能为NULL", "has_risk": true, "preconditions": "current->sessionName分配失败或未初始化", "trigger_path": "调用路径推导：InvokerListenThread() -> GetCurrentRpcSkeleton()。数据流：current通过GetCurrentRpcSkeleton获取，malloc可能失败导致current->sessionName为NULL。关键调用点：InvokerListenThread函数未在所有使用current->sessionName前检查其是否为NULL。", "consequences": "NULL指针解引用或内存操作异常，可能导致程序崩溃", "suggestions": "在每次使用current->sessionName前添加NULL检查", "verification_notes": "分析结论正确，InvokerListenThread函数未在所有使用current->sessionName前检查其是否为NULL，存在NULL指针解引用风险"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/ipc_adapter/mini/ipc_proxy_inner.c", "line": 85, "evidence": "free(current->sessionName);", "confidence": 0.6, "severity": "high", "gid": 941, "verify": "检查proxyObject->sessionName和current->sessionName是否可能为NULL", "has_risk": true, "preconditions": "current->sessionName分配失败或未初始化", "trigger_path": "调用路径推导：InvokerListenThread() -> GetCurrentRpcSkeleton()。数据流：current通过GetCurrentRpcSkeleton获取，malloc可能失败导致current->sessionName为NULL。关键调用点：InvokerListenThread函数未在所有使用current->sessionName前检查其是否为NULL。", "consequences": "NULL指针解引用或内存操作异常，可能导致程序崩溃", "suggestions": "在每次使用current->sessionName前添加NULL检查", "verification_notes": "分析结论正确，InvokerListenThread函数未在所有使用current->sessionName前检查其是否为NULL，存在NULL指针解引用风险"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/ipc_adapter/mini/ipc_proxy_inner.c", "line": 86, "evidence": "current->sessionName = NULL;", "confidence": 0.6, "severity": "high", "gid": 942, "verify": "检查proxyObject->sessionName和current->sessionName是否可能为NULL", "has_risk": true, "preconditions": "current->sessionName分配失败或未初始化", "trigger_path": "调用路径推导：InvokerListenThread() -> GetCurrentRpcSkeleton()。数据流：current通过GetCurrentRpcSkeleton获取，malloc可能失败导致current->sessionName为NULL。关键调用点：InvokerListenThread函数未在所有使用current->sessionName前检查其是否为NULL。", "consequences": "NULL指针解引用或内存操作异常，可能导致程序崩溃", "suggestions": "在每次使用current->sessionName前添加NULL检查", "verification_notes": "分析结论正确，InvokerListenThread函数未在所有使用current->sessionName前检查其是否为NULL，存在NULL指针解引用风险"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/ipc_adapter/mini/ipc_proxy_inner.c", "line": 92, "evidence": "current->sessionName = (char *)malloc(sessionNameLen + 1);", "confidence": 0.6, "severity": "high", "gid": 943, "verify": "检查proxyObject->sessionName和current->sessionName是否可能为NULL", "has_risk": true, "preconditions": "current->sessionName分配失败或未初始化", "trigger_path": "调用路径推导：InvokerListenThread() -> GetCurrentRpcSkeleton()。数据流：current通过GetCurrentRpcSkeleton获取，malloc可能失败导致current->sessionName为NULL。关键调用点：InvokerListenThread函数未在所有使用current->sessionName前检查其是否为NULL。", "consequences": "NULL指针解引用或内存操作异常，可能导致程序崩溃", "suggestions": "在每次使用current->sessionName前添加NULL检查", "verification_notes": "分析结论正确，InvokerListenThread函数未在所有使用current->sessionName前检查其是否为NULL，存在NULL指针解引用风险"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/ipc_adapter/mini/ipc_proxy_inner.c", "line": 93, "evidence": "if (current->sessionName == NULL) {", "confidence": 0.6, "severity": "high", "gid": 944, "verify": "检查proxyObject->sessionName和current->sessionName是否可能为NULL", "has_risk": true, "preconditions": "current->sessionName分配失败或未初始化", "trigger_path": "调用路径推导：InvokerListenThread() -> GetCurrentRpcSkeleton()。数据流：current通过GetCurrentRpcSkeleton获取，malloc可能失败导致current->sessionName为NULL。关键调用点：InvokerListenThread函数未在所有使用current->sessionName前检查其是否为NULL。", "consequences": "NULL指针解引用或内存操作异常，可能导致程序崩溃", "suggestions": "在每次使用current->sessionName前添加NULL检查", "verification_notes": "分析结论正确，InvokerListenThread函数未在所有使用current->sessionName前检查其是否为NULL，存在NULL指针解引用风险"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/ipc_adapter/mini/ipc_proxy_inner.c", "line": 97, "evidence": "free(current->sessionName);", "confidence": 0.6, "severity": "high", "gid": 947, "verify": "检查proxyObject->sessionName和current->sessionName是否可能为NULL", "has_risk": true, "preconditions": "current->sessionName分配失败或未初始化", "trigger_path": "调用路径推导：InvokerListenThread() -> GetCurrentRpcSkeleton()。数据流：current通过GetCurrentRpcSkeleton获取，malloc可能失败导致current->sessionName为NULL。关键调用点：InvokerListenThread函数未在所有使用current->sessionName前检查其是否为NULL。", "consequences": "NULL指针解引用或内存操作异常，可能导致程序崩溃", "suggestions": "在每次使用current->sessionName前添加NULL检查", "verification_notes": "分析结论正确，InvokerListenThread函数未在所有使用current->sessionName前检查其是否为NULL，存在NULL指针解引用风险"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/ipc_adapter/mini/ipc_proxy_inner.c", "line": 130, "evidence": "proxyObject->sessionName = (char *)malloc(sessionNameLen + 1);", "confidence": 0.6, "severity": "high", "gid": 953, "verify": "检查proxyObject->sessionName和current->sessionName是否可能为NULL", "has_risk": true, "preconditions": "proxyObject->sessionName分配失败或sprintf_s失败", "trigger_path": "调用路径推导：GetPidAndUidInfo() -> malloc/sprintf_s。数据流：proxyObject->sessionName通过malloc分配内存可能失败，sprintf_s可能失败但未正确处理。关键调用点：GetPidAndUidInfo函数未在所有使用proxyObject->sessionName前检查其有效性。", "consequences": "NULL指针解引用或格式化字符串错误，可能导致程序崩溃", "suggestions": "在每次使用proxyObject->sessionName前添加NULL检查，并确保sprintf_s失败时正确处理", "verification_notes": "分析结论正确，GetPidAndUidInfo函数未在所有使用proxyObject->sessionName前检查其有效性，存在NULL指针解引用和格式化字符串错误风险"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/ipc_adapter/mini/ipc_proxy_inner.c", "line": 131, "evidence": "if (proxyObject->sessionName == NULL) {", "confidence": 0.6, "severity": "high", "gid": 954, "verify": "检查proxyObject->sessionName和current->sessionName是否可能为NULL", "has_risk": true, "preconditions": "proxyObject->sessionName分配失败或sprintf_s失败", "trigger_path": "调用路径推导：GetPidAndUidInfo() -> malloc/sprintf_s。数据流：proxyObject->sessionName通过malloc分配内存可能失败，sprintf_s可能失败但未正确处理。关键调用点：GetPidAndUidInfo函数未在所有使用proxyObject->sessionName前检查其有效性。", "consequences": "NULL指针解引用或格式化字符串错误，可能导致程序崩溃", "suggestions": "在每次使用proxyObject->sessionName前添加NULL检查，并确保sprintf_s失败时正确处理", "verification_notes": "分析结论正确，GetPidAndUidInfo函数未在所有使用proxyObject->sessionName前检查其有效性，存在NULL指针解引用和格式化字符串错误风险"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/ipc_adapter/mini/ipc_proxy_inner.c", "line": 135, "evidence": "if (sprintf_s(proxyObject->sessionName, sessionNameLen + 1, \"            \", uid, pid) == -1) {", "confidence": 0.6, "severity": "high", "gid": 955, "verify": "检查proxyObject->sessionName和current->sessionName是否可能为NULL", "has_risk": true, "preconditions": "proxyObject->sessionName分配失败或sprintf_s失败", "trigger_path": "调用路径推导：GetPidAndUidInfo() -> malloc/sprintf_s。数据流：proxyObject->sessionName通过malloc分配内存可能失败，sprintf_s可能失败但未正确处理。关键调用点：GetPidAndUidInfo函数未在所有使用proxyObject->sessionName前检查其有效性。", "consequences": "NULL指针解引用或格式化字符串错误，可能导致程序崩溃", "suggestions": "在每次使用proxyObject->sessionName前添加NULL检查，并确保sprintf_s失败时正确处理", "verification_notes": "分析结论正确，GetPidAndUidInfo函数未在所有使用proxyObject->sessionName前检查其有效性，存在NULL指针解引用和格式化字符串错误风险"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/ipc_adapter/mini/ipc_proxy_inner.c", "line": 137, "evidence": "free(proxyObject->sessionName);", "confidence": 0.6, "severity": "high", "gid": 956, "verify": "检查proxyObject->sessionName和current->sessionName是否可能为NULL", "has_risk": true, "preconditions": "proxyObject->sessionName分配失败或sprintf_s失败", "trigger_path": "调用路径推导：GetPidAndUidInfo() -> malloc/sprintf_s。数据流：proxyObject->sessionName通过malloc分配内存可能失败，sprintf_s可能失败但未正确处理。关键调用点：GetPidAndUidInfo函数未在所有使用proxyObject->sessionName前检查其有效性。", "consequences": "NULL指针解引用或格式化字符串错误，可能导致程序崩溃", "suggestions": "在每次使用proxyObject->sessionName前添加NULL检查，并确保sprintf_s失败时正确处理", "verification_notes": "分析结论正确，GetPidAndUidInfo函数未在所有使用proxyObject->sessionName前检查其有效性，存在NULL指针解引用和格式化字符串错误风险"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/ipc_adapter/mini/ipc_proxy_inner.c", "line": 107, "evidence": "IpcObjectStub *cookie = (IpcObjectStub *)(proxyObject->proxy->cookie);", "confidence": 0.6, "severity": "high", "gid": 949, "verify": "检查proxyObject->proxy和proxyObject->proxy->cookie是否可能为NULL", "has_risk": true, "preconditions": "proxyObject->proxy 或 proxyObject->proxy->cookie 为 NULL", "trigger_path": "调用路径推导：InvokerListenThread() -> 缺陷代码。数据流：proxyObject 作为参数传入 InvokerListenThread()，函数入口处检查了 proxyObject 是否为 NULL，但未检查 proxyObject->proxy 和 proxyObject->proxy->cookie。关键调用点：InvokerListenThread() 函数未对 proxyObject->proxy 和 proxyObject->proxy->cookie 进行 NULL 检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在访问 proxyObject->proxy 和 proxyObject->proxy->cookie 前添加 NULL 检查", "verification_notes": "分析结论正确，InvokerListenThread函数确实存在proxyObject->proxy空指针解引用风险，函数入口仅检查了proxyObject是否为NULL但未检查proxyObject->proxy，后果评估准确"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/ipc_adapter/mini/ipc_proxy_inner.c", "line": 107, "evidence": "IpcObjectStub *cookie = (IpcObjectStub *)(proxyObject->proxy->cookie);", "confidence": 0.6, "severity": "high", "gid": 950, "verify": "检查proxyObject->proxy和proxyObject->proxy->cookie是否可能为NULL", "has_risk": true, "preconditions": "proxyObject->proxy 或 proxyObject->proxy->cookie 为 NULL", "trigger_path": "调用路径推导：InvokerListenThread() -> 缺陷代码。数据流：proxyObject 作为参数传入 InvokerListenThread()，函数入口处检查了 proxyObject 是否为 NULL，但未检查 proxyObject->proxy 和 proxyObject->proxy->cookie。关键调用点：InvokerListenThread() 函数未对 proxyObject->proxy 和 proxyObject->proxy->cookie 进行 NULL 检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在访问 proxyObject->proxy 和 proxyObject->proxy->cookie 前添加 NULL 检查", "verification_notes": "分析结论正确，InvokerListenThread函数确实存在proxyObject->proxy空指针解引用风险，函数入口仅检查了proxyObject是否为NULL但未检查proxyObject->proxy，后果评估准确"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/ipc_adapter/mini/ipc_proxy_inner.c", "line": 108, "evidence": "stubObject->func = cookie->func;", "confidence": 0.6, "severity": "high", "gid": 951, "verify": "检查proxyObject->proxy和proxyObject->proxy->cookie是否可能为NULL", "has_risk": true, "preconditions": "proxyObject->proxy 或 proxyObject->proxy->cookie 为 NULL", "trigger_path": "调用路径推导：InvokerListenThread() -> 缺陷代码。数据流：proxyObject 作为参数传入 InvokerListenThread()，函数入口处检查了 proxyObject 是否为 NULL，但未检查 proxyObject->proxy 和 proxyObject->proxy->cookie。关键调用点：InvokerListenThread() 函数未对 proxyObject->proxy 和 proxyObject->proxy->cookie 进行 NULL 检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在访问 proxyObject->proxy 和 proxyObject->proxy->cookie 前添加 NULL 检查", "verification_notes": "分析结论正确，InvokerListenThread函数确实存在proxyObject->proxy空指针解引用风险，函数入口仅检查了proxyObject是否为NULL但未检查proxyObject->proxy，后果评估准确"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/ipc_adapter/mini/ipc_proxy_inner.c", "line": 108, "evidence": "stubObject->func = cookie->func;", "confidence": 0.6, "severity": "high", "gid": 952, "verify": "检查proxyObject->proxy和proxyObject->proxy->cookie是否可能为NULL", "has_risk": true, "preconditions": "proxyObject->proxy 或 proxyObject->proxy->cookie 为 NULL", "trigger_path": "调用路径推导：InvokerListenThread() -> 缺陷代码。数据流：proxyObject 作为参数传入 InvokerListenThread()，函数入口处检查了 proxyObject 是否为 NULL，但未检查 proxyObject->proxy 和 proxyObject->proxy->cookie。关键调用点：InvokerListenThread() 函数未对 proxyObject->proxy 和 proxyObject->proxy->cookie 进行 NULL 检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在访问 proxyObject->proxy 和 proxyObject->proxy->cookie 前添加 NULL 检查", "verification_notes": "分析结论正确，InvokerListenThread函数确实存在proxyObject->proxy空指针解引用风险，函数入口仅检查了proxyObject是否为NULL但未检查proxyObject->proxy，后果评估准确"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/ipc_adapter/mini/ipc_proxy_inner.c", "line": 172, "evidence": "handleToIndex->handle = svc->handle;", "confidence": 0.6, "severity": "high", "gid": 958, "verify": "检查svc和svc->handle是否可能为NULL", "has_risk": true, "preconditions": "当flat_binder_object.type为BINDER_TYPE_HANDLE且obj->handle为NULL时", "trigger_path": "调用路径推导：ReadRemoteObject -> WaitForProxyInit -> UpdateProtoIfNeed -> UpdateProto -> GetSessionFromDBinderService。\n数据流：IpcIoPopRef返回的flat_binder_object通过ReadRemoteObject解析为svc对象，传递给WaitForProxyInit。\n关键调用点：\n- WaitForProxyInit有对svc的NULL检查\n- UpdateProtoIfNeed和UpdateProto没有对svc的NULL检查\n- GetSessionFromDBinderService直接访问svc->handle和svc->cookie\n触发条件：当flat_binder_object.type为BINDER_TYPE_HANDLE且obj->handle为NULL时，svc->handle将被设为0，后续调用链中未充分校验svc的有效性。\n", "consequences": "可能导致空指针解引用，引发程序崩溃或未定义行为", "suggestions": "1. 在UpdateProto和GetSessionFromDBinderService中添加对svc的NULL检查\n2. 在UpdateProtoIfNeed中添加对svc的NULL检查\n3. 考虑在ReadRemoteObject中对obj->handle的有效性进行检查", "verification_notes": "分析结论正确，验证如下：\n1. 前置条件合理：当flat_binder_object.type为BINDER_TYPE_HANDLE且obj->handle为NULL时确实会进入风险路径\n2. 触发路径成立：代码分析确认ReadRemoteObject->WaitForProxyInit->UpdateProtoIfNeed->UpdateProto->GetSessionFromDBinderService的调用链存在\n3. 后果评估准确：确实可能导致空指针解引用\n4. 建议合适：添加NULL检查是合理的解决方案\n验证发现：\n- WaitForProxyInit有svc的NULL检查\n- UpdateProto和GetSessionFromDBinderService确实缺少NULL检查\n- 当svc->handle为0时会直接访问svc->cookie"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/ipc_adapter/mini/ipc_proxy_inner.c", "line": 172, "evidence": "handleToIndex->handle = svc->handle;", "confidence": 0.6, "severity": "high", "gid": 959, "verify": "检查svc和svc->handle是否可能为NULL", "has_risk": true, "preconditions": "当flat_binder_object.type为BINDER_TYPE_HANDLE且obj->handle为NULL时", "trigger_path": "调用路径推导：ReadRemoteObject -> WaitForProxyInit -> UpdateProtoIfNeed -> UpdateProto -> GetSessionFromDBinderService。\n数据流：IpcIoPopRef返回的flat_binder_object通过ReadRemoteObject解析为svc对象，传递给WaitForProxyInit。\n关键调用点：\n- WaitForProxyInit有对svc的NULL检查\n- UpdateProtoIfNeed和UpdateProto没有对svc的NULL检查\n- GetSessionFromDBinderService直接访问svc->handle和svc->cookie\n触发条件：当flat_binder_object.type为BINDER_TYPE_HANDLE且obj->handle为NULL时，svc->handle将被设为0，后续调用链中未充分校验svc的有效性。\n", "consequences": "可能导致空指针解引用，引发程序崩溃或未定义行为", "suggestions": "1. 在UpdateProto和GetSessionFromDBinderService中添加对svc的NULL检查\n2. 在UpdateProtoIfNeed中添加对svc的NULL检查\n3. 考虑在ReadRemoteObject中对obj->handle的有效性进行检查", "verification_notes": "分析结论正确，验证如下：\n1. 前置条件合理：当flat_binder_object.type为BINDER_TYPE_HANDLE且obj->handle为NULL时确实会进入风险路径\n2. 触发路径成立：代码分析确认ReadRemoteObject->WaitForProxyInit->UpdateProtoIfNeed->UpdateProto->GetSessionFromDBinderService的调用链存在\n3. 后果评估准确：确实可能导致空指针解引用\n4. 建议合适：添加NULL检查是合理的解决方案\n验证发现：\n- WaitForProxyInit有svc的NULL检查\n- UpdateProto和GetSessionFromDBinderService确实缺少NULL检查\n- 当svc->handle为0时会直接访问svc->cookie"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/ipc_adapter/mini/ipc_proxy_inner.c", "line": 197, "evidence": "if (svc->handle < 0) {", "confidence": 0.6, "severity": "high", "gid": 966, "verify": "检查svc和svc->handle是否可能为NULL", "has_risk": true, "preconditions": "当flat_binder_object.type为BINDER_TYPE_HANDLE且obj->handle为NULL时", "trigger_path": "调用路径推导：ReadRemoteObject -> WaitForProxyInit -> UpdateProtoIfNeed -> UpdateProto -> GetSessionFromDBinderService。\n数据流：IpcIoPopRef返回的flat_binder_object通过ReadRemoteObject解析为svc对象，传递给WaitForProxyInit。\n关键调用点：\n- WaitForProxyInit有对svc的NULL检查\n- UpdateProtoIfNeed和UpdateProto没有对svc的NULL检查\n- GetSessionFromDBinderService直接访问svc->handle和svc->cookie\n触发条件：当flat_binder_object.type为BINDER_TYPE_HANDLE且obj->handle为NULL时，svc->handle将被设为0，后续调用链中未充分校验svc的有效性。\n", "consequences": "可能导致空指针解引用，引发程序崩溃或未定义行为", "suggestions": "1. 在UpdateProto和GetSessionFromDBinderService中添加对svc的NULL检查\n2. 在UpdateProtoIfNeed中添加对svc的NULL检查\n3. 考虑在ReadRemoteObject中对obj->handle的有效性进行检查", "verification_notes": "分析结论正确，验证如下：\n1. 前置条件合理：当flat_binder_object.type为BINDER_TYPE_HANDLE且obj->handle为NULL时确实会进入风险路径\n2. 触发路径成立：代码分析确认ReadRemoteObject->WaitForProxyInit->UpdateProtoIfNeed->UpdateProto->GetSessionFromDBinderService的调用链存在\n3. 后果评估准确：确实可能导致空指针解引用\n4. 建议合适：添加NULL检查是合理的解决方案\n验证发现：\n- WaitForProxyInit有svc的NULL检查\n- UpdateProto和GetSessionFromDBinderService确实缺少NULL检查\n- 当svc->handle为0时会直接访问svc->cookie"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/ipc_adapter/mini/ipc_proxy_inner.c", "line": 207, "evidence": "HandleSessionList *sessionObject = QueryProxySession(svc->handle);", "confidence": 0.6, "severity": "high", "gid": 967, "verify": "检查svc和svc->handle是否可能为NULL", "has_risk": true, "preconditions": "当flat_binder_object.type为BINDER_TYPE_HANDLE且obj->handle为NULL时", "trigger_path": "调用路径推导：ReadRemoteObject -> WaitForProxyInit -> UpdateProtoIfNeed -> UpdateProto -> GetSessionFromDBinderService。\n数据流：IpcIoPopRef返回的flat_binder_object通过ReadRemoteObject解析为svc对象，传递给WaitForProxyInit。\n关键调用点：\n- WaitForProxyInit有对svc的NULL检查\n- UpdateProtoIfNeed和UpdateProto没有对svc的NULL检查\n- GetSessionFromDBinderService直接访问svc->handle和svc->cookie\n触发条件：当flat_binder_object.type为BINDER_TYPE_HANDLE且obj->handle为NULL时，svc->handle将被设为0，后续调用链中未充分校验svc的有效性。\n", "consequences": "可能导致空指针解引用，引发程序崩溃或未定义行为", "suggestions": "1. 在UpdateProto和GetSessionFromDBinderService中添加对svc的NULL检查\n2. 在UpdateProtoIfNeed中添加对svc的NULL检查\n3. 考虑在ReadRemoteObject中对obj->handle的有效性进行检查", "verification_notes": "分析结论正确，验证如下：\n1. 前置条件合理：当flat_binder_object.type为BINDER_TYPE_HANDLE且obj->handle为NULL时确实会进入风险路径\n2. 触发路径成立：代码分析确认ReadRemoteObject->WaitForProxyInit->UpdateProtoIfNeed->UpdateProto->GetSessionFromDBinderService的调用链存在\n3. 后果评估准确：确实可能导致空指针解引用\n4. 建议合适：添加NULL检查是合理的解决方案\n验证发现：\n- WaitForProxyInit有svc的NULL检查\n- UpdateProto和GetSessionFromDBinderService确实缺少NULL检查\n- 当svc->handle为0时会直接访问svc->cookie"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/trans_adapter/include/rpc_trans.h", "line": 26, "evidence": "int32_t (*OnConnected)(int32_t sessionId, int32_t result);", "confidence": 0.6, "severity": "high", "gid": 1000, "verify": "验证函数指针在使用前是否被正确初始化/赋值", "has_risk": true, "preconditions": "函数指针未被正确初始化就被调用", "trigger_path": "调用路径推导：RpcProcessSkeleton() -> GetRpcTrans() -> 使用返回的TransInterface结构体中的函数指针。数据流：GetRpcTrans()返回的TransInterface结构体中的函数指针可能未被初始化。关键调用点：RpcProcessSkeleton()直接使用GetRpcTrans()返回的指针，未检查函数指针是否为空。", "consequences": "空指针解引用，可能导致程序崩溃或未定义行为", "suggestions": "1. 在使用函数指针前添加空指针检查；2. 确保所有函数指针在使用前都被正确初始化；3. 考虑使用函数指针默认值或安全回调机制", "verification_notes": "分析结论正确：\n1. 前置条件合理：代码显示 GetRpcTrans() 返回的 RpcTrans 结构体确实包含函数指针，且 RpcProcessSkeleton() 直接使用该指针而未检查\n2. 触发路径成立：调用路径 RpcProcessSkeleton() -> GetRpcTrans() -> 使用返回的 TransInterface 结构体中的函数指针确实存在\n3. 后果评估准确：如果函数指针未被初始化，确实会导致空指针解引用\n4. 建议合适：添加空指针检查、确保初始化和安全回调机制都是有效的改进方案"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/trans_adapter/include/rpc_trans.h", "line": 27, "evidence": "int32_t (*OnDisconnected)(int32_t sessionId);", "confidence": 0.6, "severity": "high", "gid": 1001, "verify": "验证函数指针在使用前是否被正确初始化/赋值", "has_risk": true, "preconditions": "函数指针未被正确初始化就被调用", "trigger_path": "调用路径推导：RpcProcessSkeleton() -> GetRpcTrans() -> 使用返回的TransInterface结构体中的函数指针。数据流：GetRpcTrans()返回的TransInterface结构体中的函数指针可能未被初始化。关键调用点：RpcProcessSkeleton()直接使用GetRpcTrans()返回的指针，未检查函数指针是否为空。", "consequences": "空指针解引用，可能导致程序崩溃或未定义行为", "suggestions": "1. 在使用函数指针前添加空指针检查；2. 确保所有函数指针在使用前都被正确初始化；3. 考虑使用函数指针默认值或安全回调机制", "verification_notes": "分析结论正确：\n1. 前置条件合理：代码显示 GetRpcTrans() 返回的 RpcTrans 结构体确实包含函数指针，且 RpcProcessSkeleton() 直接使用该指针而未检查\n2. 触发路径成立：调用路径 RpcProcessSkeleton() -> GetRpcTrans() -> 使用返回的 TransInterface 结构体中的函数指针确实存在\n3. 后果评估准确：如果函数指针未被初始化，确实会导致空指针解引用\n4. 建议合适：添加空指针检查、确保初始化和安全回调机制都是有效的改进方案"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/c/rpc/trans_adapter/include/rpc_trans.h", "line": 35, "evidence": "int32_t (*Disconnect)(int32_t sessionId);", "confidence": 0.6, "severity": "high", "gid": 1002, "verify": "验证函数指针在使用前是否被正确初始化/赋值", "has_risk": true, "preconditions": "函数指针未被正确初始化就被调用", "trigger_path": "调用路径推导：RpcProcessSkeleton() -> GetRpcTrans() -> 使用返回的TransInterface结构体中的函数指针。数据流：GetRpcTrans()返回的TransInterface结构体中的函数指针可能未被初始化。关键调用点：RpcProcessSkeleton()直接使用GetRpcTrans()返回的指针，未检查函数指针是否为空。", "consequences": "空指针解引用，可能导致程序崩溃或未定义行为", "suggestions": "1. 在使用函数指针前添加空指针检查；2. 确保所有函数指针在使用前都被正确初始化；3. 考虑使用函数指针默认值或安全回调机制", "verification_notes": "分析结论正确：\n1. 前置条件合理：代码显示 GetRpcTrans() 返回的 RpcTrans 结构体确实包含函数指针，且 RpcProcessSkeleton() 直接使用该指针而未检查\n2. 触发路径成立：调用路径 RpcProcessSkeleton() -> GetRpcTrans() -> 使用返回的 TransInterface 结构体中的函数指针确实存在\n3. 后果评估准确：如果函数指针未被初始化，确实会导致空指针解引用\n4. 建议合适：添加空指针检查、确保初始化和安全回调机制都是有效的改进方案"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "wild_pointer_deref", "file": "ipc/native/src/c_api/include/ipc_remote_object_internal.h", "line": 55, "evidence": "OH_OnRemoteDestroyCallback destroyCallback, void *userData);", "confidence": 0.65, "severity": "high", "gid": 1003, "verify": "确认指针(userData和userData_)在使用前是否被正确初始化或判空", "has_risk": true, "preconditions": "userData或userData_指针为nullptr且相关回调函数指针非空", "trigger_path": "调用路径推导：1) 可控输入来源：外部调用者传入的userData指针；2) 调用链：外部调用 -> IPCDeathRecipient构造函数/OHIPCRemoteServiceStub构造函数 -> OnRemoteDied/OnRemoteRequest/destructor；3) 校验情况：构造函数直接存储指针无校验，使用点仅检查回调函数指针而未检查userData指针；4) 触发条件：当回调函数指针非空但userData指针为空时可能解引用空指针", "consequences": "可能导致空指针解引用，引发程序崩溃", "suggestions": "1) 在构造函数中添加userData指针的nullptr检查；2) 在使用userData指针前添加显式判空检查；3) 考虑使用智能指针管理生命周期", "verification_notes": "分析结论正确，验证如下：\n1. 前置条件合理：代码中确实存在当userData指针为nullptr但回调函数指针非空时的风险场景\n2. 触发路径成立：\n   - IPCDeathRecipient::OnRemoteDied()直接调用回调函数而未检查userData_\n   - OHIPCRemoteServiceStub::OnRemoteRequest()直接传递userData_给回调函数\n3. 后果评估准确：确实可能导致空指针解引用，引发程序崩溃\n4. 建议合适：添加nullptr检查和使用智能指针的建议是有效的改进方案"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "wild_pointer_deref", "file": "ipc/native/src/c_api/include/ipc_remote_object_internal.h", "line": 64, "evidence": "void *userData_;", "confidence": 0.65, "severity": "high", "gid": 1004, "verify": "确认指针(userData和userData_)在使用前是否被正确初始化或判空", "has_risk": true, "preconditions": "userData或userData_指针为nullptr且相关回调函数指针非空", "trigger_path": "调用路径推导：1) 可控输入来源：外部调用者传入的userData指针；2) 调用链：外部调用 -> IPCDeathRecipient构造函数/OHIPCRemoteServiceStub构造函数 -> OnRemoteDied/OnRemoteRequest/destructor；3) 校验情况：构造函数直接存储指针无校验，使用点仅检查回调函数指针而未检查userData指针；4) 触发条件：当回调函数指针非空但userData指针为空时可能解引用空指针", "consequences": "可能导致空指针解引用，引发程序崩溃", "suggestions": "1) 在构造函数中添加userData指针的nullptr检查；2) 在使用userData指针前添加显式判空检查；3) 考虑使用智能指针管理生命周期", "verification_notes": "分析结论正确，验证如下：\n1. 前置条件合理：代码中确实存在当userData指针为nullptr但回调函数指针非空时的风险场景\n2. 触发路径成立：\n   - IPCDeathRecipient::OnRemoteDied()直接调用回调函数而未检查userData_\n   - OHIPCRemoteServiceStub::OnRemoteRequest()直接传递userData_给回调函数\n3. 后果评估准确：确实可能导致空指针解引用，引发程序崩溃\n4. 建议合适：添加nullptr检查和使用智能指针的建议是有效的改进方案"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "vla_usage", "file": "ipc/native/src/napi/src/napi_ipc_skeleton.cpp", "line": 291, "evidence": "char stringValue[bufferSize + 1];", "confidence": 0.6, "severity": "medium", "gid": 1236, "verify": "验证bufferSize的值是否合理，是否可能导致栈溢出", "has_risk": true, "preconditions": "输入字符串长度超过40960字节", "trigger_path": "调用路径推导：NAPI接口调用 -> NAPI_IPCSkeleton_setCallingIdentity/NAPI_IPCSkeleton_restoreCallingIdentity -> VLA分配。数据流：JavaScript字符串通过NAPI接口传入，未经过充分长度校验即用于VLA分配。关键调用点：虽然检查了bufferSize < 40960，但40960字节的栈分配仍然过大。", "consequences": "栈空间耗尽导致栈溢出，可能引发程序崩溃或任意代码执行", "suggestions": "将VLA改为动态内存分配(malloc/new)，或限制最大允许输入长度为更安全的栈空间大小(如4096字节)", "verification_notes": "分析结论正确，代码中确实存在使用VLA分配大尺寸栈数组的风险（maxLen = 40960），前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "vla_usage", "file": "ipc/native/src/napi/src/napi_ipc_skeleton.cpp", "line": 442, "evidence": "char stringValue[bufferSize + 1];", "confidence": 0.6, "severity": "medium", "gid": 1237, "verify": "验证bufferSize的值是否合理，是否可能导致栈溢出", "has_risk": true, "preconditions": "输入字符串长度超过40960字节", "trigger_path": "调用路径推导：NAPI接口调用 -> NAPI_IPCSkeleton_setCallingIdentity/NAPI_IPCSkeleton_restoreCallingIdentity -> VLA分配。数据流：JavaScript字符串通过NAPI接口传入，未经过充分长度校验即用于VLA分配。关键调用点：虽然检查了bufferSize < 40960，但40960字节的栈分配仍然过大。", "consequences": "栈空间耗尽导致栈溢出，可能引发程序崩溃或任意代码执行", "suggestions": "将VLA改为动态内存分配(malloc/new)，或限制最大允许输入长度为更安全的栈空间大小(如4096字节)", "verification_notes": "分析结论正确，代码中确实存在使用VLA分配大尺寸栈数组的风险（maxLen = 40960），前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/ani/rpc/src/ani_rpc_error.cpp", "line": 29, "evidence": "if (ANI_OK != env->FindClass(errorClsName, &cls)) {", "confidence": 0.6, "severity": "high", "gid": 1240, "verify": "Verify that env, cls, ctor, errorObject, and errMsgStr pointers/objects are non-null before dereference", "has_risk": true, "preconditions": "调用者传入空指针 env 或 env 指针在传递过程中变为空", "trigger_path": "调用路径推导：AniError::ThrowError() -> ThrowBusinessError()。数据流：env 参数从外部传入，通过 ThrowError() 传递给 ThrowBusinessError()，ThrowBusinessError() 未对 env 进行空指针检查直接解引用。关键调用点：ThrowBusinessError() 函数未对 env 参数进行空指针校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在 ThrowBusinessError 函数入口处添加 env 空指针检查；2. 在所有调用 ThrowError/ThrowBusinessError 的地方确保 env 参数有效", "verification_notes": "分析结论正确：\n1. 前置条件合理：ThrowBusinessError函数确实未对env参数进行空指针检查\n2. 触发路径成立：代码显示ThrowError会直接调用ThrowBusinessError并传递env参数\n3. 后果评估准确：确实存在空指针解引用风险\n4. 建议合适：添加空指针检查是合理的解决方案\n代码验证：\n- ThrowBusinessError函数(23-60行)直接使用env指针而未检查\n- AniError::ThrowError(62-65行)直接调用ThrowBusinessError并传递env\n- 当env为nullptr时确实会导致程序崩溃"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/ani/rpc/src/ani_rpc_error.cpp", "line": 35, "evidence": "if (ANI_OK != env->Class_FindMethod(cls, \"      \", \"  \", &ctor)) {", "confidence": 0.6, "severity": "high", "gid": 1241, "verify": "Verify that env, cls, ctor, errorObject, and errMsgStr pointers/objects are non-null before dereference", "has_risk": true, "preconditions": "调用者传入空指针 env 或 env 指针在传递过程中变为空", "trigger_path": "调用路径推导：AniError::ThrowError() -> ThrowBusinessError()。数据流：env 参数从外部传入，通过 ThrowError() 传递给 ThrowBusinessError()，ThrowBusinessError() 未对 env 进行空指针检查直接解引用。关键调用点：ThrowBusinessError() 函数未对 env 参数进行空指针校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在 ThrowBusinessError 函数入口处添加 env 空指针检查；2. 在所有调用 ThrowError/ThrowBusinessError 的地方确保 env 参数有效", "verification_notes": "分析结论正确：\n1. 前置条件合理：ThrowBusinessError函数确实未对env参数进行空指针检查\n2. 触发路径成立：代码显示ThrowError会直接调用ThrowBusinessError并传递env参数\n3. 后果评估准确：确实存在空指针解引用风险\n4. 建议合适：添加空指针检查是合理的解决方案\n代码验证：\n- ThrowBusinessError函数(23-60行)直接使用env指针而未检查\n- AniError::ThrowError(62-65行)直接调用ThrowBusinessError并传递env\n- 当env为nullptr时确实会导致程序崩溃"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/ani/rpc/src/ani_rpc_error.cpp", "line": 41, "evidence": "if (ANI_OK != env->Object_New(cls, ctor, &errorObject)) {", "confidence": 0.6, "severity": "high", "gid": 1242, "verify": "Verify that env, cls, ctor, errorObject, and errMsgStr pointers/objects are non-null before dereference", "has_risk": true, "preconditions": "调用者传入空指针 env 或 env 指针在传递过程中变为空", "trigger_path": "调用路径推导：AniError::ThrowError() -> ThrowBusinessError()。数据流：env 参数从外部传入，通过 ThrowError() 传递给 ThrowBusinessError()，ThrowBusinessError() 未对 env 进行空指针检查直接解引用。关键调用点：ThrowBusinessError() 函数未对 env 参数进行空指针校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在 ThrowBusinessError 函数入口处添加 env 空指针检查；2. 在所有调用 ThrowError/ThrowBusinessError 的地方确保 env 参数有效", "verification_notes": "分析结论正确：\n1. 前置条件合理：ThrowBusinessError函数确实未对env参数进行空指针检查\n2. 触发路径成立：代码显示ThrowError会直接调用ThrowBusinessError并传递env参数\n3. 后果评估准确：确实存在空指针解引用风险\n4. 建议合适：添加空指针检查是合理的解决方案\n代码验证：\n- ThrowBusinessError函数(23-60行)直接使用env指针而未检查\n- AniError::ThrowError(62-65行)直接调用ThrowBusinessError并传递env\n- 当env为nullptr时确实会导致程序崩溃"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/ani/rpc/src/ani_rpc_error.cpp", "line": 48, "evidence": "if (ANI_OK != env->String_NewUTF8(errMsg.c_str(), errMsg.size(), &errMsgStr)) {", "confidence": 0.6, "severity": "high", "gid": 1243, "verify": "Verify that env, cls, ctor, errorObject, and errMsgStr pointers/objects are non-null before dereference", "has_risk": true, "preconditions": "调用者传入空指针 env 或 env 指针在传递过程中变为空", "trigger_path": "调用路径推导：AniError::ThrowError() -> ThrowBusinessError()。数据流：env 参数从外部传入，通过 ThrowError() 传递给 ThrowBusinessError()，ThrowBusinessError() 未对 env 进行空指针检查直接解引用。关键调用点：ThrowBusinessError() 函数未对 env 参数进行空指针校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在 ThrowBusinessError 函数入口处添加 env 空指针检查；2. 在所有调用 ThrowError/ThrowBusinessError 的地方确保 env 参数有效", "verification_notes": "分析结论正确：\n1. 前置条件合理：ThrowBusinessError函数确实未对env参数进行空指针检查\n2. 触发路径成立：代码显示ThrowError会直接调用ThrowBusinessError并传递env参数\n3. 后果评估准确：确实存在空指针解引用风险\n4. 建议合适：添加空指针检查是合理的解决方案\n代码验证：\n- ThrowBusinessError函数(23-60行)直接使用env指针而未检查\n- AniError::ThrowError(62-65行)直接调用ThrowBusinessError并传递env\n- 当env为nullptr时确实会导致程序崩溃"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/ani/rpc/src/ani_rpc_error.cpp", "line": 52, "evidence": "if (ANI_OK != env->Object_SetFieldByName_Double(errorObject, \"    \", aniErrCode)) {", "confidence": 0.6, "severity": "high", "gid": 1244, "verify": "Verify that env, cls, ctor, errorObject, and errMsgStr pointers/objects are non-null before dereference", "has_risk": true, "preconditions": "调用者传入空指针 env 或 env 指针在传递过程中变为空", "trigger_path": "调用路径推导：AniError::ThrowError() -> ThrowBusinessError()。数据流：env 参数从外部传入，通过 ThrowError() 传递给 ThrowBusinessError()，ThrowBusinessError() 未对 env 进行空指针检查直接解引用。关键调用点：ThrowBusinessError() 函数未对 env 参数进行空指针校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在 ThrowBusinessError 函数入口处添加 env 空指针检查；2. 在所有调用 ThrowError/ThrowBusinessError 的地方确保 env 参数有效", "verification_notes": "分析结论正确：\n1. 前置条件合理：ThrowBusinessError函数确实未对env参数进行空指针检查\n2. 触发路径成立：代码显示ThrowError会直接调用ThrowBusinessError并传递env参数\n3. 后果评估准确：确实存在空指针解引用风险\n4. 建议合适：添加空指针检查是合理的解决方案\n代码验证：\n- ThrowBusinessError函数(23-60行)直接使用env指针而未检查\n- AniError::ThrowError(62-65行)直接调用ThrowBusinessError并传递env\n- 当env为nullptr时确实会导致程序崩溃"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/ani/rpc/src/ani_rpc_error.cpp", "line": 55, "evidence": "if (ANI_OK != env->Object_SetPropertyByName_Ref(errorObject, \"       \", errMsgStr)) {", "confidence": 0.6, "severity": "high", "gid": 1245, "verify": "Verify that env, cls, ctor, errorObject, and errMsgStr pointers/objects are non-null before dereference", "has_risk": true, "preconditions": "调用者传入空指针 env 或 env 指针在传递过程中变为空", "trigger_path": "调用路径推导：AniError::ThrowError() -> ThrowBusinessError()。数据流：env 参数从外部传入，通过 ThrowError() 传递给 ThrowBusinessError()，ThrowBusinessError() 未对 env 进行空指针检查直接解引用。关键调用点：ThrowBusinessError() 函数未对 env 参数进行空指针校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在 ThrowBusinessError 函数入口处添加 env 空指针检查；2. 在所有调用 ThrowError/ThrowBusinessError 的地方确保 env 参数有效", "verification_notes": "分析结论正确：\n1. 前置条件合理：ThrowBusinessError函数确实未对env参数进行空指针检查\n2. 触发路径成立：代码显示ThrowError会直接调用ThrowBusinessError并传递env参数\n3. 后果评估准确：确实存在空指针解引用风险\n4. 建议合适：添加空指针检查是合理的解决方案\n代码验证：\n- ThrowBusinessError函数(23-60行)直接使用env指针而未检查\n- AniError::ThrowError(62-65行)直接调用ThrowBusinessError并传递env\n- 当env为nullptr时确实会导致程序崩溃"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/ani/rpc/src/ani_rpc_error.cpp", "line": 59, "evidence": "env->ThrowError(static_cast<ani_error>(errorObject));", "confidence": 0.6, "severity": "high", "gid": 1246, "verify": "Verify that env, cls, ctor, errorObject, and errMsgStr pointers/objects are non-null before dereference", "has_risk": true, "preconditions": "调用者传入空指针 env 或 env 指针在传递过程中变为空", "trigger_path": "调用路径推导：AniError::ThrowError() -> ThrowBusinessError()。数据流：env 参数从外部传入，通过 ThrowError() 传递给 ThrowBusinessError()，ThrowBusinessError() 未对 env 进行空指针检查直接解引用。关键调用点：ThrowBusinessError() 函数未对 env 参数进行空指针校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在 ThrowBusinessError 函数入口处添加 env 空指针检查；2. 在所有调用 ThrowError/ThrowBusinessError 的地方确保 env 参数有效", "verification_notes": "分析结论正确：\n1. 前置条件合理：ThrowBusinessError函数确实未对env参数进行空指针检查\n2. 触发路径成立：代码显示ThrowError会直接调用ThrowBusinessError并传递env参数\n3. 后果评估准确：确实存在空指针解引用风险\n4. 建议合适：添加空指针检查是合理的解决方案\n代码验证：\n- ThrowBusinessError函数(23-60行)直接使用env指针而未检查\n- AniError::ThrowError(62-65行)直接调用ThrowBusinessError并传递env\n- 当env为nullptr时确实会导致程序崩溃"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/ani/rpc/src/rpc_ani_class.cpp", "line": 133, "evidence": "if (ANI_OK != env_->GlobalReference_Create(reinterpret_cast<ani_ref>(remoteObject), &saveRemote_)) {", "confidence": 0.6, "severity": "high", "gid": 1285, "verify": "saveRemote_在操作前必须有效", "has_risk": true, "preconditions": "GlobalReference_Create调用失败导致saveRemote_处于未定义状态", "trigger_path": "调用路径推导：IPCAniStub构造函数 -> GlobalReference_Create -> saveRemote_初始化。数据流：构造函数接收remoteObject参数，传递给GlobalReference_Create创建全局引用，如果失败则saveRemote_状态未定义。关键调用点：构造函数未检查GlobalReference_Create是否成功初始化saveRemote_，析构函数直接使用可能未初始化的saveRemote_。", "consequences": "可能导致空指针解引用，引发程序崩溃", "suggestions": "1. 在构造函数中显式初始化saveRemote_为nullptr；2. 在析构函数中添加对saveRemote_的null检查；3. 在GlobalReference_Create调用失败时明确设置saveRemote_为nullptr", "verification_notes": "分析结论正确，前置条件合理（GlobalReference_Create可能失败导致saveRemote_未定义），触发路径清晰（构造函数->GlobalReference_Create->析构函数直接使用），后果评估准确（可能导致空指针解引用），建议合理（显式初始化/null检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/ani/rpc/src/rpc_ani_class.cpp", "line": 143, "evidence": "if (ANI_OK != env_->GlobalReference_Delete(saveRemote_)) {", "confidence": 0.6, "severity": "high", "gid": 1286, "verify": "saveRemote_在操作前必须有效", "has_risk": true, "preconditions": "GlobalReference_Create调用失败导致saveRemote_处于未定义状态", "trigger_path": "调用路径推导：IPCAniStub构造函数 -> GlobalReference_Create -> saveRemote_初始化。数据流：构造函数接收remoteObject参数，传递给GlobalReference_Create创建全局引用，如果失败则saveRemote_状态未定义。关键调用点：构造函数未检查GlobalReference_Create是否成功初始化saveRemote_，析构函数直接使用可能未初始化的saveRemote_。", "consequences": "可能导致空指针解引用，引发程序崩溃", "suggestions": "1. 在构造函数中显式初始化saveRemote_为nullptr；2. 在析构函数中添加对saveRemote_的null检查；3. 在GlobalReference_Create调用失败时明确设置saveRemote_为nullptr", "verification_notes": "分析结论正确，前置条件合理（GlobalReference_Create可能失败导致saveRemote_未定义），触发路径清晰（构造函数->GlobalReference_Create->析构函数直接使用），后果评估准确（可能导致空指针解引用），建议合理（显式初始化/null检查）"}
{"language": "c/cpp", "category": "type_safety", "pattern": "reinterpret_cast_unsafe", "file": "ipc/native/src/ani/rpc/src/rpc_ani_class.cpp", "line": 133, "evidence": "if (ANI_OK != env_->GlobalReference_Create(reinterpret_cast<ani_ref>(remoteObject), &saveRemote_)) {", "confidence": 0.7999999999999999, "severity": "high", "gid": 1290, "verify": "reinterpret_cast转换必须安全", "has_risk": true, "preconditions": "传入的remoteObject或saveRemote_类型与目标转换类型不兼容", "trigger_path": "调用路径推导：1) 1290问题：外部调用 -> IPCAniStub构造函数 -> reinterpret_cast<ani_ref>(remoteObject)。数据流：remoteObject参数来源不明，未经类型检查直接转换。2) 1291问题：GlobalReference_Create返回值 -> saveRemote_ -> reinterpret_cast<ani_object>(saveRemote_)。数据流：GlobalReference_Create返回值类型不明，未经验证直接转换。关键调用点：两个转换都缺乏类型兼容性验证。", "consequences": "类型不匹配可能导致内存访问错误、程序崩溃或未定义行为", "suggestions": "1) 确保remoteObject确实可以安全转换为ani_ref；2) 确保GlobalReference_Create返回的类型与ani_object兼容；3) 添加类型检查或使用更安全的转换方式", "verification_notes": "分析结论正确：\n1. 前置条件合理：代码中确实存在reinterpret_cast转换且缺乏类型检查（IPCAniStub构造函数第133行）\n2. 触发路径成立：remoteObject参数未经类型检查直接转换，GlobalReference_Create返回值直接保存\n3. 后果评估准确：类型不匹配确实可能导致内存访问错误或程序崩溃\n4. 建议合适：添加类型检查或使用更安全的转换方式是合理的改进方案"}
{"language": "c/cpp", "category": "type_safety", "pattern": "reinterpret_cast_unsafe", "file": "ipc/native/src/ani/rpc/src/rpc_ani_class.cpp", "line": 173, "evidence": "auto obj = reinterpret_cast<ani_object>(saveRemote_);", "confidence": 0.7, "severity": "high", "gid": 1291, "verify": "reinterpret_cast转换必须安全", "has_risk": true, "preconditions": "传入的remoteObject或saveRemote_类型与目标转换类型不兼容", "trigger_path": "调用路径推导：1) 1290问题：外部调用 -> IPCAniStub构造函数 -> reinterpret_cast<ani_ref>(remoteObject)。数据流：remoteObject参数来源不明，未经类型检查直接转换。2) 1291问题：GlobalReference_Create返回值 -> saveRemote_ -> reinterpret_cast<ani_object>(saveRemote_)。数据流：GlobalReference_Create返回值类型不明，未经验证直接转换。关键调用点：两个转换都缺乏类型兼容性验证。", "consequences": "类型不匹配可能导致内存访问错误、程序崩溃或未定义行为", "suggestions": "1) 确保remoteObject确实可以安全转换为ani_ref；2) 确保GlobalReference_Create返回的类型与ani_object兼容；3) 添加类型检查或使用更安全的转换方式", "verification_notes": "分析结论正确：\n1. 前置条件合理：代码中确实存在reinterpret_cast转换且缺乏类型检查（IPCAniStub构造函数第133行）\n2. 触发路径成立：remoteObject参数未经类型检查直接转换，GlobalReference_Create返回值直接保存\n3. 后果评估准确：类型不匹配确实可能导致内存访问错误或程序崩溃\n4. 建议合适：添加类型检查或使用更安全的转换方式是合理的改进方案"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/ani/rpc/include/ani_util_conversion.h", "line": 34, "evidence": "env->String_GetUTF8Size(ani_str, &strSize);", "confidence": 0.6, "severity": "high", "gid": 1292, "verify": "env指针在解引用前非空", "has_risk": true, "preconditions": "env指针为null", "trigger_path": "调用路径推导：RPC调用链 -> MessageSequenceReadString()/MessageSequenceWriteString()/MessageSequencereadInterfaceToken() -> AniStringUtils::ToStd()/AniStringUtils::ToAni()。数据流：env指针通过RPC调用链传递，在调用AniStringUtils转换函数时未进行空指针检查。关键调用点：所有调用AniStringUtils转换函数的入口点均未对env指针进行校验。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在AniStringUtils转换函数入口处添加env指针的非空检查，或确保所有调用路径在调用前已进行空指针校验", "verification_notes": "分析结论正确，env指针确实存在空指针风险，调用路径分析准确，后果评估合理，建议在入口处添加空指针检查是合适的解决方案"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/ani/rpc/include/ani_util_conversion.h", "line": 41, "evidence": "env->String_GetUTF8(ani_str, utf8_buffer, strSize + 1, &bytes_written);", "confidence": 0.6, "severity": "high", "gid": 1293, "verify": "env指针在解引用前非空", "has_risk": true, "preconditions": "env指针为null", "trigger_path": "调用路径推导：RPC调用链 -> MessageSequenceReadString()/MessageSequenceWriteString()/MessageSequencereadInterfaceToken() -> AniStringUtils::ToStd()/AniStringUtils::ToAni()。数据流：env指针通过RPC调用链传递，在调用AniStringUtils转换函数时未进行空指针检查。关键调用点：所有调用AniStringUtils转换函数的入口点均未对env指针进行校验。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在AniStringUtils转换函数入口处添加env指针的非空检查，或确保所有调用路径在调用前已进行空指针校验", "verification_notes": "分析结论正确，env指针确实存在空指针风险，调用路径分析准确，后果评估合理，建议在入口处添加空指针检查是合适的解决方案"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/ani/rpc/include/ani_util_conversion.h", "line": 51, "evidence": "if (ANI_OK != env->String_NewUTF8(str.data(), str.size(), &aniStr)) {", "confidence": 0.6, "severity": "high", "gid": 1294, "verify": "env指针在解引用前非空", "has_risk": true, "preconditions": "env指针为null", "trigger_path": "调用路径推导：RPC调用链 -> MessageSequenceReadString()/MessageSequenceWriteString()/MessageSequencereadInterfaceToken() -> AniStringUtils::ToStd()/AniStringUtils::ToAni()。数据流：env指针通过RPC调用链传递，在调用AniStringUtils转换函数时未进行空指针检查。关键调用点：所有调用AniStringUtils转换函数的入口点均未对env指针进行校验。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在AniStringUtils转换函数入口处添加env指针的非空检查，或确保所有调用路径在调用前已进行空指针校验", "verification_notes": "分析结论正确，env指针确实存在空指针风险，调用路径分析准确，后果评估合理，建议在入口处添加空指针检查是合适的解决方案"}
{"language": "c/cpp", "category": "type_safety", "pattern": "reinterpret_cast_unsafe", "file": "ipc/native/src/ani/rpc/include/rpc_ani_class.h", "line": 56, "evidence": "if (ANI_OK != env->GlobalReference_Create(reinterpret_cast<ani_ref>(remoteObject),", "confidence": 0.7999999999999999, "severity": "high", "gid": 1305, "verify": "验证reinterpret_cast<ani_ref>和reinterpret_cast<ani_ref*>的类型转换安全性", "has_risk": true, "preconditions": "传入的remoteObject参数不是有效的ani_ref类型或其指针", "trigger_path": "调用路径推导：JNI调用 -> RemoteObjectInit() -> IPCObjectRemoteHolder构造函数 -> reinterpret_cast转换。数据流：JNI传入的object参数未经类型检查直接传递给IPCObjectRemoteHolder构造函数，构造函数中使用reinterpret_cast进行危险类型转换。关键调用点：RemoteObjectInit()函数未对输入对象进行类型校验。", "consequences": "类型不匹配可能导致内存访问错误或未定义行为", "suggestions": "1. 添加类型检查机制确保转换前的类型符合预期；2. 考虑使用更安全的转换方式如static_cast（如果类型关系允许）；3. 在转换前添加验证逻辑确保输入对象的有效性", "verification_notes": "分析结论正确：\n1. 前置条件合理：RemoteObjectInit函数确实未对输入的remoteObject参数进行类型检查\n2. 触发路径成立：JNI调用确实会直接传递对象到IPCObjectRemoteHolder构造函数，并使用reinterpret_cast进行转换\n3. 后果评估准确：类型不匹配确实可能导致内存访问错误或未定义行为\n4. 建议合适：添加类型检查和使用更安全的转换方式是合理的改进建议\n验证发现：\n- IPCObjectRemoteHolder构造函数(line 50-60)确实使用了reinterpret_cast转换\n- RemoteObjectInit函数(line 101-115)未对输入对象进行类型检查\n- 代码中缺少对ani_ref类型的有效性验证"}
{"language": "c/cpp", "category": "type_safety", "pattern": "reinterpret_cast_unsafe", "file": "ipc/native/src/ani/rpc/include/rpc_ani_class.h", "line": 57, "evidence": "reinterpret_cast<ani_ref*>(&remoteObject_))) {", "confidence": 0.7999999999999999, "severity": "high", "gid": 1306, "verify": "验证reinterpret_cast<ani_ref>和reinterpret_cast<ani_ref*>的类型转换安全性", "has_risk": true, "preconditions": "传入的remoteObject参数不是有效的ani_ref类型或其指针", "trigger_path": "调用路径推导：JNI调用 -> RemoteObjectInit() -> IPCObjectRemoteHolder构造函数 -> reinterpret_cast转换。数据流：JNI传入的object参数未经类型检查直接传递给IPCObjectRemoteHolder构造函数，构造函数中使用reinterpret_cast进行危险类型转换。关键调用点：RemoteObjectInit()函数未对输入对象进行类型校验。", "consequences": "类型不匹配可能导致内存访问错误或未定义行为", "suggestions": "1. 添加类型检查机制确保转换前的类型符合预期；2. 考虑使用更安全的转换方式如static_cast（如果类型关系允许）；3. 在转换前添加验证逻辑确保输入对象的有效性", "verification_notes": "分析结论正确：\n1. 前置条件合理：RemoteObjectInit函数确实未对输入的remoteObject参数进行类型检查\n2. 触发路径成立：JNI调用确实会直接传递对象到IPCObjectRemoteHolder构造函数，并使用reinterpret_cast进行转换\n3. 后果评估准确：类型不匹配确实可能导致内存访问错误或未定义行为\n4. 建议合适：添加类型检查和使用更安全的转换方式是合理的改进建议\n验证发现：\n- IPCObjectRemoteHolder构造函数(line 50-60)确实使用了reinterpret_cast转换\n- RemoteObjectInit函数(line 101-115)未对输入对象进行类型检查\n- 代码中缺少对ani_ref类型的有效性验证"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/ani/rpc/include/ani_util_native_ptr.h", "line": 79, "evidence": "if (ANI_OK != env->FindNamespace(nsName, &ns)) {", "confidence": 0.6, "severity": "high", "gid": 1307, "verify": "验证env、ns、cls、ctor、obj等指针在解引用前非空", "has_risk": true, "preconditions": "env指针为空或无效", "trigger_path": "调用路径推导：1) 可控输入来源：通过ani_vm->GetEnv获取env指针或直接作为函数参数传入；2) 调用链：CreateJsProxyRemoteObject() -> AniObjectUtils::Create() -> env->FindNamespace/env->Namespace_FindClass等 或 BindCleanerclassMethods() -> NativePtrCleaner::Bind() -> env_->Class_BindNativeMethods；3) 校验情况：调用路径中缺少对env指针的显式空指针检查；4) 触发条件：当env指针为空时直接调用其成员函数", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用env指针的地方添加空指针检查，或确保调用路径中env指针已被验证", "verification_notes": "分析结论正确，env指针在多个调用路径中确实缺少显式空指针检查，触发路径清晰合理，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/ani/rpc/include/ani_util_native_ptr.h", "line": 84, "evidence": "if (ANI_OK != env->Namespace_FindClass(ns, clsName, &cls)) {", "confidence": 0.6, "severity": "high", "gid": 1308, "verify": "验证env、ns、cls、ctor、obj等指针在解引用前非空", "has_risk": true, "preconditions": "env指针为空或无效", "trigger_path": "调用路径推导：1) 可控输入来源：通过ani_vm->GetEnv获取env指针或直接作为函数参数传入；2) 调用链：CreateJsProxyRemoteObject() -> AniObjectUtils::Create() -> env->FindNamespace/env->Namespace_FindClass等 或 BindCleanerclassMethods() -> NativePtrCleaner::Bind() -> env_->Class_BindNativeMethods；3) 校验情况：调用路径中缺少对env指针的显式空指针检查；4) 触发条件：当env指针为空时直接调用其成员函数", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用env指针的地方添加空指针检查，或确保调用路径中env指针已被验证", "verification_notes": "分析结论正确，env指针在多个调用路径中确实缺少显式空指针检查，触发路径清晰合理，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/ani/rpc/include/ani_util_native_ptr.h", "line": 89, "evidence": "if (ANI_OK != env->Class_FindMethod(cls, \"      \", nullptr, &ctor)) {", "confidence": 0.6, "severity": "high", "gid": 1309, "verify": "验证env、ns、cls、ctor、obj等指针在解引用前非空", "has_risk": true, "preconditions": "env指针为空或无效", "trigger_path": "调用路径推导：1) 可控输入来源：通过ani_vm->GetEnv获取env指针或直接作为函数参数传入；2) 调用链：CreateJsProxyRemoteObject() -> AniObjectUtils::Create() -> env->FindNamespace/env->Namespace_FindClass等 或 BindCleanerclassMethods() -> NativePtrCleaner::Bind() -> env_->Class_BindNativeMethods；3) 校验情况：调用路径中缺少对env指针的显式空指针检查；4) 触发条件：当env指针为空时直接调用其成员函数", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用env指针的地方添加空指针检查，或确保调用路径中env指针已被验证", "verification_notes": "分析结论正确，env指针在多个调用路径中确实缺少显式空指针检查，触发路径清晰合理，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/ani/rpc/include/ani_util_native_ptr.h", "line": 96, "evidence": "ani_status status = env->Object_New_V(cls, ctor, &obj, args);", "confidence": 0.6, "severity": "high", "gid": 1310, "verify": "验证env、ns、cls、ctor、obj等指针在解引用前非空", "has_risk": true, "preconditions": "env指针为空或无效", "trigger_path": "调用路径推导：1) 可控输入来源：通过ani_vm->GetEnv获取env指针或直接作为函数参数传入；2) 调用链：CreateJsProxyRemoteObject() -> AniObjectUtils::Create() -> env->FindNamespace/env->Namespace_FindClass等 或 BindCleanerclassMethods() -> NativePtrCleaner::Bind() -> env_->Class_BindNativeMethods；3) 校验情况：调用路径中缺少对env指针的显式空指针检查；4) 触发条件：当env指针为空时直接调用其成员函数", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用env指针的地方添加空指针检查，或确保调用路径中env指针已被验证", "verification_notes": "分析结论正确，env指针在多个调用路径中确实缺少显式空指针检查，触发路径清晰合理，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/ani/rpc/include/ani_util_native_ptr.h", "line": 109, "evidence": "if (ANI_OK != env->FindClass(clsName, &cls)) {", "confidence": 0.6, "severity": "high", "gid": 1311, "verify": "验证env、ns、cls、ctor、obj等指针在解引用前非空", "has_risk": true, "preconditions": "env指针为空或无效", "trigger_path": "调用路径推导：1) 可控输入来源：通过ani_vm->GetEnv获取env指针或直接作为函数参数传入；2) 调用链：CreateJsProxyRemoteObject() -> AniObjectUtils::Create() -> env->FindNamespace/env->Namespace_FindClass等 或 BindCleanerclassMethods() -> NativePtrCleaner::Bind() -> env_->Class_BindNativeMethods；3) 校验情况：调用路径中缺少对env指针的显式空指针检查；4) 触发条件：当env指针为空时直接调用其成员函数", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用env指针的地方添加空指针检查，或确保调用路径中env指针已被验证", "verification_notes": "分析结论正确，env指针在多个调用路径中确实缺少显式空指针检查，触发路径清晰合理，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/ani/rpc/include/ani_util_native_ptr.h", "line": 114, "evidence": "if (ANI_OK != env->Class_FindMethod(cls, \"      \", nullptr, &ctor)) {", "confidence": 0.6, "severity": "high", "gid": 1312, "verify": "验证env、ns、cls、ctor、obj等指针在解引用前非空", "has_risk": true, "preconditions": "env指针为空或无效", "trigger_path": "调用路径推导：1) 可控输入来源：通过ani_vm->GetEnv获取env指针或直接作为函数参数传入；2) 调用链：CreateJsProxyRemoteObject() -> AniObjectUtils::Create() -> env->FindNamespace/env->Namespace_FindClass等 或 BindCleanerclassMethods() -> NativePtrCleaner::Bind() -> env_->Class_BindNativeMethods；3) 校验情况：调用路径中缺少对env指针的显式空指针检查；4) 触发条件：当env指针为空时直接调用其成员函数", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用env指针的地方添加空指针检查，或确保调用路径中env指针已被验证", "verification_notes": "分析结论正确，env指针在多个调用路径中确实缺少显式空指针检查，触发路径清晰合理，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/ani/rpc/include/ani_util_native_ptr.h", "line": 121, "evidence": "ani_status status = env->Object_New_V(cls, ctor, &obj, args);", "confidence": 0.6, "severity": "high", "gid": 1313, "verify": "验证env、ns、cls、ctor、obj等指针在解引用前非空", "has_risk": true, "preconditions": "env指针为空或无效", "trigger_path": "调用路径推导：1) 可控输入来源：通过ani_vm->GetEnv获取env指针或直接作为函数参数传入；2) 调用链：CreateJsProxyRemoteObject() -> AniObjectUtils::Create() -> env->FindNamespace/env->Namespace_FindClass等 或 BindCleanerclassMethods() -> NativePtrCleaner::Bind() -> env_->Class_BindNativeMethods；3) 校验情况：调用路径中缺少对env指针的显式空指针检查；4) 触发条件：当env指针为空时直接调用其成员函数", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用env指针的地方添加空指针检查，或确保调用路径中env指针已被验证", "verification_notes": "分析结论正确，env指针在多个调用路径中确实缺少显式空指针检查，触发路径清晰合理，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/ani/rpc/include/ani_util_native_ptr.h", "line": 134, "evidence": "if (ANI_OK != env->Class_FindMethod(cls, \"      \", nullptr, &ctor)) {", "confidence": 0.6, "severity": "high", "gid": 1314, "verify": "验证env、ns、cls、ctor、obj等指针在解引用前非空", "has_risk": true, "preconditions": "env指针为空或无效", "trigger_path": "调用路径推导：1) 可控输入来源：通过ani_vm->GetEnv获取env指针或直接作为函数参数传入；2) 调用链：CreateJsProxyRemoteObject() -> AniObjectUtils::Create() -> env->FindNamespace/env->Namespace_FindClass等 或 BindCleanerclassMethods() -> NativePtrCleaner::Bind() -> env_->Class_BindNativeMethods；3) 校验情况：调用路径中缺少对env指针的显式空指针检查；4) 触发条件：当env指针为空时直接调用其成员函数", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用env指针的地方添加空指针检查，或确保调用路径中env指针已被验证", "verification_notes": "分析结论正确，env指针在多个调用路径中确实缺少显式空指针检查，触发路径清晰合理，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/ani/rpc/include/ani_util_native_ptr.h", "line": 141, "evidence": "ani_status status = env->Object_New_V(cls, ctor, &obj, args);", "confidence": 0.6, "severity": "high", "gid": 1315, "verify": "验证env、ns、cls、ctor、obj等指针在解引用前非空", "has_risk": true, "preconditions": "env指针为空或无效", "trigger_path": "调用路径推导：1) 可控输入来源：通过ani_vm->GetEnv获取env指针或直接作为函数参数传入；2) 调用链：CreateJsProxyRemoteObject() -> AniObjectUtils::Create() -> env->FindNamespace/env->Namespace_FindClass等 或 BindCleanerclassMethods() -> NativePtrCleaner::Bind() -> env_->Class_BindNativeMethods；3) 校验情况：调用路径中缺少对env指针的显式空指针检查；4) 触发条件：当env指针为空时直接调用其成员函数", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用env指针的地方添加空指针检查，或确保调用路径中env指针已被验证", "verification_notes": "分析结论正确，env指针在多个调用路径中确实缺少显式空指针检查，触发路径清晰合理，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/ani/rpc/include/ani_util_native_ptr.h", "line": 152, "evidence": "return env->Object_SetFieldByName_Long(object, propName, reinterpret_cast<ani_long>(nativePtr));", "confidence": 0.6, "severity": "high", "gid": 1316, "verify": "验证env、ns、cls、ctor、obj等指针在解引用前非空", "has_risk": true, "preconditions": "env指针为空或无效", "trigger_path": "调用路径推导：1) 可控输入来源：通过ani_vm->GetEnv获取env指针或直接作为函数参数传入；2) 调用链：CreateJsProxyRemoteObject() -> AniObjectUtils::Create() -> env->FindNamespace/env->Namespace_FindClass等 或 BindCleanerclassMethods() -> NativePtrCleaner::Bind() -> env_->Class_BindNativeMethods；3) 校验情况：调用路径中缺少对env指针的显式空指针检查；4) 触发条件：当env指针为空时直接调用其成员函数", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用env指针的地方添加空指针检查，或确保调用路径中env指针已被验证", "verification_notes": "分析结论正确，env指针在多个调用路径中确实缺少显式空指针检查，触发路径清晰合理，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/ani/rpc/include/ani_util_native_ptr.h", "line": 159, "evidence": "if (ANI_OK != env->Object_GetFieldByName_Long(object, propName, &nativePtr)) {", "confidence": 0.6, "severity": "high", "gid": 1317, "verify": "验证env、ns、cls、ctor、obj等指针在解引用前非空", "has_risk": true, "preconditions": "env指针为空或无效", "trigger_path": "调用路径推导：1) 可控输入来源：通过ani_vm->GetEnv获取env指针或直接作为函数参数传入；2) 调用链：CreateJsProxyRemoteObject() -> AniObjectUtils::Create() -> env->FindNamespace/env->Namespace_FindClass等 或 BindCleanerclassMethods() -> NativePtrCleaner::Bind() -> env_->Class_BindNativeMethods；3) 校验情况：调用路径中缺少对env指针的显式空指针检查；4) 触发条件：当env指针为空时直接调用其成员函数", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用env指针的地方添加空指针检查，或确保调用路径中env指针已被验证", "verification_notes": "分析结论正确，env指针在多个调用路径中确实缺少显式空指针检查，触发路径清晰合理，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/ani/rpc/include/ani_util_native_ptr.h", "line": 171, "evidence": "if (ANI_OK != env->Object_GetFieldByName_Long(object, \"         \", &ptr)) {", "confidence": 0.6, "severity": "high", "gid": 1318, "verify": "验证env、ns、cls、ctor、obj等指针在解引用前非空", "has_risk": true, "preconditions": "env指针为空或无效", "trigger_path": "调用路径推导：1) 可控输入来源：通过ani_vm->GetEnv获取env指针或直接作为函数参数传入；2) 调用链：CreateJsProxyRemoteObject() -> AniObjectUtils::Create() -> env->FindNamespace/env->Namespace_FindClass等 或 BindCleanerclassMethods() -> NativePtrCleaner::Bind() -> env_->Class_BindNativeMethods；3) 校验情况：调用路径中缺少对env指针的显式空指针检查；4) 触发条件：当env指针为空时直接调用其成员函数", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用env指针的地方添加空指针检查，或确保调用路径中env指针已被验证", "verification_notes": "分析结论正确，env指针在多个调用路径中确实缺少显式空指针检查，触发路径清晰合理，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/ani/rpc/include/ani_util_native_ptr.h", "line": 185, "evidence": "if (ANI_OK != env_->Class_BindNativeMethods(cls, methods.data(), methods.size())) {", "confidence": 0.6, "severity": "high", "gid": 1319, "verify": "验证env、ns、cls、ctor、obj等指针在解引用前非空", "has_risk": true, "preconditions": "env指针为空或无效", "trigger_path": "调用路径推导：1) 可控输入来源：通过ani_vm->GetEnv获取env指针或直接作为函数参数传入；2) 调用链：CreateJsProxyRemoteObject() -> AniObjectUtils::Create() -> env->FindNamespace/env->Namespace_FindClass等 或 BindCleanerclassMethods() -> NativePtrCleaner::Bind() -> env_->Class_BindNativeMethods；3) 校验情况：调用路径中缺少对env指针的显式空指针检查；4) 触发条件：当env指针为空时直接调用其成员函数", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用env指针的地方添加空指针检查，或确保调用路径中env指针已被验证", "verification_notes": "分析结论正确，env指针在多个调用路径中确实缺少显式空指针检查，触发路径清晰合理，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/taihe/src/remote_object_taihe_ani.cpp", "line": 33, "evidence": "taiheAniobj->nativeObject_ = remoteObject;", "confidence": 0.6, "severity": "high", "gid": 1325, "verify": "验证env指针在调用方法前非空", "has_risk": true, "preconditions": "env指针为null时调用相关函数", "trigger_path": "调用路径推导：外部调用 -> ANI_ohos_rpc_CreateJsRemoteObject()/AniGetNativeRemoteObject() -> 直接使用env指针。数据流：env指针作为参数传入，在函数内部未进行非空校验直接使用。关键调用点：ANI_ohos_rpc_CreateJsRemoteObject()和AniGetNativeRemoteObject()函数未对env指针进行非空校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在函数入口处添加env指针的非空检查，如：if (env == nullptr) { return nullptr; }", "verification_notes": "分析结论正确，代码中确实存在env指针未校验的风险。ANI_ohos_rpc_CreateJsRemoteObject和AniGetNativeRemoteObject函数均未对env指针进行非空检查，直接使用env指针调用方法，可能导致空指针解引用。建议在函数入口处添加env指针的非空检查。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/taihe/src/remote_object_taihe_ani.cpp", "line": 37, "evidence": "if (env->FindNamespace(ns.Descriptor().c_str(), &imageNamespace) != ANI_OK) {", "confidence": 0.6, "severity": "high", "gid": 1326, "verify": "验证env指针在调用方法前非空", "has_risk": true, "preconditions": "env指针为null时调用相关函数", "trigger_path": "调用路径推导：外部调用 -> ANI_ohos_rpc_CreateJsRemoteObject()/AniGetNativeRemoteObject() -> 直接使用env指针。数据流：env指针作为参数传入，在函数内部未进行非空校验直接使用。关键调用点：ANI_ohos_rpc_CreateJsRemoteObject()和AniGetNativeRemoteObject()函数未对env指针进行非空校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在函数入口处添加env指针的非空检查，如：if (env == nullptr) { return nullptr; }", "verification_notes": "分析结论正确，代码中确实存在env指针未校验的风险。ANI_ohos_rpc_CreateJsRemoteObject和AniGetNativeRemoteObject函数均未对env指针进行非空检查，直接使用env指针调用方法，可能导致空指针解引用。建议在函数入口处添加env指针的非空检查。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/taihe/src/remote_object_taihe_ani.cpp", "line": 42, "evidence": "if (env->Namespace_FindFunction(imageNamespace, \"                \", nullptr, &createFunc) != ANI_OK) {", "confidence": 0.6, "severity": "high", "gid": 1327, "verify": "验证env指针在调用方法前非空", "has_risk": true, "preconditions": "env指针为null时调用相关函数", "trigger_path": "调用路径推导：外部调用 -> ANI_ohos_rpc_CreateJsRemoteObject()/AniGetNativeRemoteObject() -> 直接使用env指针。数据流：env指针作为参数传入，在函数内部未进行非空校验直接使用。关键调用点：ANI_ohos_rpc_CreateJsRemoteObject()和AniGetNativeRemoteObject()函数未对env指针进行非空校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在函数入口处添加env指针的非空检查，如：if (env == nullptr) { return nullptr; }", "verification_notes": "分析结论正确，代码中确实存在env指针未校验的风险。ANI_ohos_rpc_CreateJsRemoteObject和AniGetNativeRemoteObject函数均未对env指针进行非空检查，直接使用env指针调用方法，可能导致空指针解引用。建议在函数入口处添加env指针的非空检查。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/taihe/src/remote_object_taihe_ani.cpp", "line": 47, "evidence": "if (env->Function_Call_Ref(createFunc, &remoteObj, reinterpret_cast<ani_long>(taiheAniobj.get())) == ANI_OK) {", "confidence": 0.6, "severity": "high", "gid": 1328, "verify": "验证env指针在调用方法前非空", "has_risk": true, "preconditions": "env指针为null时调用相关函数", "trigger_path": "调用路径推导：外部调用 -> ANI_ohos_rpc_CreateJsRemoteObject()/AniGetNativeRemoteObject() -> 直接使用env指针。数据流：env指针作为参数传入，在函数内部未进行非空校验直接使用。关键调用点：ANI_ohos_rpc_CreateJsRemoteObject()和AniGetNativeRemoteObject()函数未对env指针进行非空校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在函数入口处添加env指针的非空检查，如：if (env == nullptr) { return nullptr; }", "verification_notes": "分析结论正确，代码中确实存在env指针未校验的风险。ANI_ohos_rpc_CreateJsRemoteObject和AniGetNativeRemoteObject函数均未对env指针进行非空检查，直接使用env指针调用方法，可能导致空指针解引用。建议在函数入口处添加env指针的非空检查。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/taihe/src/remote_object_taihe_ani.cpp", "line": 60, "evidence": "if (env->FindNamespace(ns.Descriptor().c_str(), &imageNamespace) != ANI_OK) {", "confidence": 0.6, "severity": "high", "gid": 1329, "verify": "验证env指针在调用方法前非空", "has_risk": true, "preconditions": "env指针为null时调用相关函数", "trigger_path": "调用路径推导：外部调用 -> ANI_ohos_rpc_CreateJsRemoteObject()/AniGetNativeRemoteObject() -> 直接使用env指针。数据流：env指针作为参数传入，在函数内部未进行非空校验直接使用。关键调用点：ANI_ohos_rpc_CreateJsRemoteObject()和AniGetNativeRemoteObject()函数未对env指针进行非空校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在函数入口处添加env指针的非空检查，如：if (env == nullptr) { return nullptr; }", "verification_notes": "分析结论正确，代码中确实存在env指针未校验的风险。ANI_ohos_rpc_CreateJsRemoteObject和AniGetNativeRemoteObject函数均未对env指针进行非空检查，直接使用env指针调用方法，可能导致空指针解引用。建议在函数入口处添加env指针的非空检查。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/taihe/src/remote_object_taihe_ani.cpp", "line": 65, "evidence": "if (env->Namespace_FindFunction(imageNamespace, \"                  \", nullptr, &createFunc) != ANI_OK) {", "confidence": 0.6, "severity": "high", "gid": 1330, "verify": "验证env指针在调用方法前非空", "has_risk": true, "preconditions": "env指针为null时调用相关函数", "trigger_path": "调用路径推导：外部调用 -> ANI_ohos_rpc_CreateJsRemoteObject()/AniGetNativeRemoteObject() -> 直接使用env指针。数据流：env指针作为参数传入，在函数内部未进行非空校验直接使用。关键调用点：ANI_ohos_rpc_CreateJsRemoteObject()和AniGetNativeRemoteObject()函数未对env指针进行非空校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在函数入口处添加env指针的非空检查，如：if (env == nullptr) { return nullptr; }", "verification_notes": "分析结论正确，代码中确实存在env指针未校验的风险。ANI_ohos_rpc_CreateJsRemoteObject和AniGetNativeRemoteObject函数均未对env指针进行非空检查，直接使用env指针调用方法，可能导致空指针解引用。建议在函数入口处添加env指针的非空检查。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/taihe/src/remote_object_taihe_ani.cpp", "line": 70, "evidence": "if (!(env->Function_Call_Long(createFunc, &implPtr, obj) == ANI_OK)) {", "confidence": 0.6, "severity": "high", "gid": 1331, "verify": "验证env指针在调用方法前非空", "has_risk": true, "preconditions": "env指针为null时调用相关函数", "trigger_path": "调用路径推导：外部调用 -> ANI_ohos_rpc_CreateJsRemoteObject()/AniGetNativeRemoteObject() -> 直接使用env指针。数据流：env指针作为参数传入，在函数内部未进行非空校验直接使用。关键调用点：ANI_ohos_rpc_CreateJsRemoteObject()和AniGetNativeRemoteObject()函数未对env指针进行非空校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在函数入口处添加env指针的非空检查，如：if (env == nullptr) { return nullptr; }", "verification_notes": "分析结论正确，代码中确实存在env指针未校验的风险。ANI_ohos_rpc_CreateJsRemoteObject和AniGetNativeRemoteObject函数均未对env指针进行非空检查，直接使用env指针调用方法，可能导致空指针解引用。建议在函数入口处添加env指针的非空检查。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "alloc_no_null_check", "file": "ipc/native/src/taihe/src/ohos.rpc.rpc.impl.cpp", "line": 257, "evidence": "OHOS::sptr<DeathRecipientImpl> nativeDeathRecipient = new (std::nothrow) DeathRecipientImpl(recipient);", "confidence": 0.65, "severity": "medium", "gid": 1336, "verify": "检查所有使用new(std::nothrow)分配内存后是否进行了null检查", "has_risk": true, "preconditions": "内存分配失败，返回空指针", "trigger_path": "调用路径推导：RemoteProxyImpl::RegisterDeathRecipient() -> new(std::nothrow)分配内存。数据流：直接调用new(std::nothrow)分配内存，未检查返回值。关键调用点：RegisterDeathRecipient()函数未对分配结果进行null检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在分配后立即检查指针是否为null，并处理错误情况", "verification_notes": "分析结论正确，前置条件合理（使用new(std::nothrow)可能返回空指针），触发路径清晰（直接调用未检查返回值），后果评估准确（可能导致空指针解引用），建议合适（应添加null检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "alloc_no_null_check", "file": "ipc/native/src/taihe/src/ohos.rpc.rpc.impl.cpp", "line": 505, "evidence": "wptrCachedObject_ = new (std::nothrow) ANIRemoteObject(descStr16, jsObjRef_.value());", "confidence": 0.65, "severity": "medium", "gid": 1338, "verify": "检查所有使用new(std::nothrow)分配内存后是否进行了null检查", "has_risk": true, "preconditions": "内存分配失败，返回空指针", "trigger_path": "调用路径推导：RemoteObjectImpl::AddJsObjWeakRef() -> new(std::nothrow)分配内存。数据流：直接调用new(std::nothrow)分配内存，未检查返回值。关键调用点：AddJsObjWeakRef()函数未对分配结果进行null检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在分配后立即检查指针是否为null，并处理错误情况", "verification_notes": "分析结论正确，前置条件合理（内存分配可能失败），触发路径成立（直接调用new(std::nothrow)未检查），后果评估准确（空指针解引用风险），建议合适（应添加null检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "alloc_no_null_check", "file": "ipc/native/src/taihe/src/ohos.rpc.rpc.impl.cpp", "line": 507, "evidence": "sptrCachedObject_ = new (std::nothrow) ANIRemoteObject(descStr16, jsObjRef_.value());", "confidence": 0.65, "severity": "medium", "gid": 1339, "verify": "检查所有使用new(std::nothrow)分配内存后是否进行了null检查", "has_risk": true, "preconditions": "内存分配失败，返回空指针", "trigger_path": "调用路径推导：RemoteObjectImpl::AddJsObjWeakRef() -> new(std::nothrow)分配内存。数据流：直接调用new(std::nothrow)分配内存，未检查返回值。关键调用点：AddJsObjWeakRef()函数未对分配结果进行null检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在分配后立即检查指针是否为null，并处理错误情况", "verification_notes": "分析结论正确，前置条件合理（内存分配可能失败），触发路径成立（直接调用new(std::nothrow)未检查），后果评估准确（空指针解引用风险），建议合适（应添加null检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "alloc_no_null_check", "file": "ipc/native/src/taihe/src/ohos.rpc.rpc.impl.cpp", "line": 634, "evidence": "auto messageSequence = new (std::nothrow) NAPI_MessageSequence(jsenv, jsMessageSequence, impl->GetNativeParcel());", "confidence": 0.65, "severity": "medium", "gid": 1341, "verify": "检查所有使用new(std::nothrow)分配内存后是否进行了null检查", "has_risk": true, "preconditions": "内存分配失败，返回空指针", "trigger_path": "调用路径推导：MessageSequenceImpl::RpcTransferDynamicImpl() -> new(std::nothrow)分配内存。数据流：直接调用new(std::nothrow)分配内存，未检查返回值。关键调用点：RpcTransferDynamicImpl()函数未对分配结果进行null检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在分配后立即检查指针是否为null，并处理错误情况", "verification_notes": "分析结论正确，前置条件合理（内存分配可能失败），触发路径成立（直接调用new(std::nothrow)未检查），后果评估准确（空指针解引用风险），建议合适（应添加null检查）"}
{"language": "c/cpp", "category": "error_handling", "pattern": "io_call", "file": "ipc/native/src/taihe/src/ohos.rpc.rpc.impl.cpp", "line": 1287, "evidence": "close(fd);", "confidence": 0.65, "severity": "medium", "gid": 1342, "verify": "检查close(fd)调用是否检查了返回值", "has_risk": true, "preconditions": "传入的文件描述符fd有效但close操作失败", "trigger_path": "调用路径推导：TH_EXPORT_CPP_API_CloseFileDescriptor() -> MessageSequenceImpl::CloseFileDescriptor() -> close(fd)。数据流：外部调用通过TH_EXPORT_CPP_API_CloseFileDescriptor宏调用CloseFileDescriptor函数。关键调用点：CloseFileDescriptor函数虽然检查了fd有效性(fd < 0)，但未检查close(fd)返回值。", "consequences": "可能导致资源泄漏或文件描述符状态不一致", "suggestions": "1. 检查close()返回值并记录错误日志；2. 对于关键文件描述符，考虑实现重试机制或更严格的错误处理", "verification_notes": "分析结论正确，前置条件合理（确实存在未检查close(fd)返回值的情况），触发路径成立（通过代码确认了CloseFileDescriptor直接调用close(fd)且无返回值检查），后果评估准确（确实可能导致资源泄漏），建议合适（检查close()返回值和添加错误日志是合理的改进方案）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/taihe/src/ohos.rpc.rpc.impl.cpp", "line": 1061, "evidence": "dataIn->Unmarshalling(*jsObjRef_);", "confidence": 0.6, "severity": "high", "gid": 1436, "verify": "jsObjRef_指针在使用前非空", "has_risk": true, "preconditions": "jsObjRef_ std::optional未初始化或为空值", "trigger_path": "调用路径推导：1) 可控输入来源：通过MessageSequenceImpl构造函数传入的MessageParcel对象；2) 调用链：MessageSequenceImpl构造函数 -> ReadParcelable/ReadParcelableArray -> Unmarshalling(*jsObjRef_)；3) 校验情况：构造函数未强制初始化jsObjRef_，调用Unmarshalling前未检查jsObjRef_.has_value()；4) 触发条件：当jsObjRef_未初始化或显式设置为std::nullopt时调用相关方法", "consequences": "空指针解引用导致程序崩溃或未定义行为", "suggestions": "1) 在使用jsObjRef_前添加has_value()检查；2) 确保所有构造函数正确初始化jsObjRef_；3) 考虑使用value()方法替代直接解引用以触发异常", "verification_notes": "分析结论正确，前置条件合理（jsObjRef_确实可能未初始化），触发路径成立（通过MessageSequenceImpl构造函数传入MessageParcel对象并在Unmarshalling前未检查has_value()），后果评估准确（可能导致空指针解引用），建议合适（添加has_value检查等）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/taihe/src/ohos.rpc.rpc.impl.cpp", "line": 1180, "evidence": "parcelableArray[i]->Unmarshalling(*jsObjRef_);", "confidence": 0.6, "severity": "high", "gid": 1448, "verify": "jsObjRef_指针在使用前非空", "has_risk": true, "preconditions": "jsObjRef_ std::optional未初始化或为空值", "trigger_path": "调用路径推导：1) 可控输入来源：通过MessageSequenceImpl构造函数传入的MessageParcel对象；2) 调用链：MessageSequenceImpl构造函数 -> ReadParcelable/ReadParcelableArray -> Unmarshalling(*jsObjRef_)；3) 校验情况：构造函数未强制初始化jsObjRef_，调用Unmarshalling前未检查jsObjRef_.has_value()；4) 触发条件：当jsObjRef_未初始化或显式设置为std::nullopt时调用相关方法", "consequences": "空指针解引用导致程序崩溃或未定义行为", "suggestions": "1) 在使用jsObjRef_前添加has_value()检查；2) 确保所有构造函数正确初始化jsObjRef_；3) 考虑使用value()方法替代直接解引用以触发异常", "verification_notes": "分析结论正确，前置条件合理（jsObjRef_确实可能未初始化），触发路径成立（通过MessageSequenceImpl构造函数传入MessageParcel对象并在Unmarshalling前未检查has_value()），后果评估准确（可能导致空指针解引用），建议合适（添加has_value检查等）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/taihe/src/ani_constructor.cpp", "line": 27, "evidence": "if (ANI_OK != vm->GetEnv(ANI_VERSION_1, &env)) {", "confidence": 0.6, "severity": "high", "gid": 1492, "verify": "指针在解引用前必须非空", "has_risk": true, "preconditions": "调用者传入空指针作为vm或result参数", "trigger_path": "调用路径推导：未知调用者 -> ANI_Constructor()。数据流：vm和result参数由外部调用者直接传入，函数内部未进行空指针检查。关键调用点：ANI_Constructor()函数未对输入参数进行空指针校验。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在ANI_Constructor()函数开始处添加对vm和result的空指针检查", "verification_notes": "分析结论正确，函数确实接收vm和result指针参数且未进行空指针检查，外部调用者可直接传入空指针导致解引用风险，建议添加空指针检查合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/taihe/src/ani_constructor.cpp", "line": 35, "evidence": "*result = ANI_VERSION_1;", "confidence": 0.6, "severity": "high", "gid": 1493, "verify": "指针在解引用前必须非空", "has_risk": true, "preconditions": "调用者传入空指针作为vm或result参数", "trigger_path": "调用路径推导：未知调用者 -> ANI_Constructor()。数据流：vm和result参数由外部调用者直接传入，函数内部未进行空指针检查。关键调用点：ANI_Constructor()函数未对输入参数进行空指针校验。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在ANI_Constructor()函数开始处添加对vm和result的空指针检查", "verification_notes": "分析结论正确，函数确实接收vm和result指针参数且未进行空指针检查，外部调用者可直接传入空指针导致解引用风险，建议添加空指针检查合理"}
{"language": "c/cpp", "category": "error_handling", "pattern": "io_call", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 1205, "evidence": "close(fd);", "confidence": 0.65, "severity": "medium", "gid": 1507, "verify": "验证close(fd)操作是否安全，文件描述符是否有效", "has_risk": true, "preconditions": "传入无效的文件描述符或已关闭的文件描述符", "trigger_path": "调用路径推导：JS调用 -> JS_CloseFileDescriptor() -> close(fd)。数据流：JavaScript传入的文件描述符数值通过argv[ARGV_INDEX_0]传递给JS_CloseFileDescriptor函数，函数仅检查参数类型为napi_number，未验证fd有效性直接调用close(fd)。关键调用点：JS_CloseFileDescriptor()函数未对文件描述符有效性进行校验。", "consequences": "可能导致EBADF错误或意外关闭其他资源，在特定情况下可能引发安全问题", "suggestions": "1. 添加文件描述符有效性检查（如使用fcntl(fd, F_GETFD)）；2. 添加close()调用后的错误处理；3. 考虑使用RAII模式管理文件描述符生命周期", "verification_notes": "分析结论正确：\n1. 前置条件合理：确实存在传入无效文件描述符或已关闭文件描述符的风险（代码1497-1518行）\n2. 触发路径成立：JS_CloseFileDescriptor函数确实只检查参数类型为napi_number，未验证fd有效性直接调用close(fd)\n3. 后果评估准确：可能导致EBADF错误或意外关闭其他资源\n4. 建议合适：添加文件描述符有效性检查和使用RAII模式是合理的改进方案"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 442, "evidence": "result = napiParcel->nativeParcel_->WriteInt64(value);", "confidence": 0.6, "severity": "high", "gid": 1556, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 444, "evidence": "napiParcel->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 1557, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 444, "evidence": "napiParcel->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 1558, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 475, "evidence": "size_t pos = napiParcel->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 1559, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 475, "evidence": "size_t pos = napiParcel->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 1560, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 476, "evidence": "napiParcel->nativeParcel_->WriteUint32(arrayLength);", "confidence": 0.6, "severity": "high", "gid": 1561, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 476, "evidence": "napiParcel->nativeParcel_->WriteUint32(arrayLength);", "confidence": 0.6, "severity": "high", "gid": 1562, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 489, "evidence": "result = napiParcel->nativeParcel_->WriteDouble(value);", "confidence": 0.6, "severity": "high", "gid": 1563, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 489, "evidence": "result = napiParcel->nativeParcel_->WriteDouble(value);", "confidence": 0.6, "severity": "high", "gid": 1564, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 491, "evidence": "napiParcel->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 1565, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 491, "evidence": "napiParcel->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 1566, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 522, "evidence": "size_t pos = napiParcel->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 1567, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 522, "evidence": "size_t pos = napiParcel->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 1568, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 523, "evidence": "napiParcel->nativeParcel_->WriteUint32(arrayLength);", "confidence": 0.6, "severity": "high", "gid": 1569, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 523, "evidence": "napiParcel->nativeParcel_->WriteUint32(arrayLength);", "confidence": 0.6, "severity": "high", "gid": 1570, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 536, "evidence": "result = napiParcel->nativeParcel_->WriteDouble(value);", "confidence": 0.6, "severity": "high", "gid": 1571, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 536, "evidence": "result = napiParcel->nativeParcel_->WriteDouble(value);", "confidence": 0.6, "severity": "high", "gid": 1572, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 538, "evidence": "napiParcel->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 1573, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 538, "evidence": "napiParcel->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 1574, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 569, "evidence": "size_t pos = napiParcel->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 1575, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 569, "evidence": "size_t pos = napiParcel->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 1576, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 570, "evidence": "napiParcel->nativeParcel_->WriteUint32(arrayLength);", "confidence": 0.6, "severity": "high", "gid": 1577, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 570, "evidence": "napiParcel->nativeParcel_->WriteUint32(arrayLength);", "confidence": 0.6, "severity": "high", "gid": 1578, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 583, "evidence": "result = napiParcel->nativeParcel_->WriteInt8(static_cast<int8_t>(value));", "confidence": 0.6, "severity": "high", "gid": 1579, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 583, "evidence": "result = napiParcel->nativeParcel_->WriteInt8(static_cast<int8_t>(value));", "confidence": 0.6, "severity": "high", "gid": 1580, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 585, "evidence": "napiParcel->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 1581, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 585, "evidence": "napiParcel->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 1582, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 616, "evidence": "size_t pos = napiParcel->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 1583, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 616, "evidence": "size_t pos = napiParcel->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 1584, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 617, "evidence": "napiParcel->nativeParcel_->WriteUint32(arrayLength);", "confidence": 0.6, "severity": "high", "gid": 1585, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 617, "evidence": "napiParcel->nativeParcel_->WriteUint32(arrayLength);", "confidence": 0.6, "severity": "high", "gid": 1586, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 629, "evidence": "result = napiParcel->nativeParcel_->WriteUint8(static_cast<uint8_t>(value));", "confidence": 0.6, "severity": "high", "gid": 1587, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 629, "evidence": "result = napiParcel->nativeParcel_->WriteUint8(static_cast<uint8_t>(value));", "confidence": 0.6, "severity": "high", "gid": 1588, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 631, "evidence": "napiParcel->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 1589, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 631, "evidence": "napiParcel->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 1590, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 670, "evidence": "bool result = napiParcel->nativeParcel_->WriteString16(to_utf16(parcelString));", "confidence": 0.6, "severity": "high", "gid": 1591, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 670, "evidence": "bool result = napiParcel->nativeParcel_->WriteString16(to_utf16(parcelString));", "confidence": 0.6, "severity": "high", "gid": 1592, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 697, "evidence": "size_t pos = napiParcel->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 1593, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 697, "evidence": "size_t pos = napiParcel->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 1594, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 698, "evidence": "napiParcel->nativeParcel_->WriteUint32(arrayLength);", "confidence": 0.6, "severity": "high", "gid": 1595, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 698, "evidence": "napiParcel->nativeParcel_->WriteUint32(arrayLength);", "confidence": 0.6, "severity": "high", "gid": 1596, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 723, "evidence": "result = napiParcel->nativeParcel_->WriteString16(to_utf16(parcelString));", "confidence": 0.6, "severity": "high", "gid": 1597, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 723, "evidence": "result = napiParcel->nativeParcel_->WriteString16(to_utf16(parcelString));", "confidence": 0.6, "severity": "high", "gid": 1598, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 725, "evidence": "napiParcel->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 1599, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 725, "evidence": "napiParcel->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 1600, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 754, "evidence": "napiParcel->nativeParcel_->WriteInt32(0);", "confidence": 0.6, "severity": "high", "gid": 1601, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 754, "evidence": "napiParcel->nativeParcel_->WriteInt32(0);", "confidence": 0.6, "severity": "high", "gid": 1602, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 757, "evidence": "size_t pos = napiParcel->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 1603, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 757, "evidence": "size_t pos = napiParcel->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 1604, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_parcel_write.cpp", "line": 758, "evidence": "napiParcel->nativeParcel_->WriteInt32(1);", "confidence": 0.6, "severity": "high", "gid": 1605, "verify": "验证napiParcel->nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiParcel对象不为空但nativeParcel_成员为空", "trigger_path": "调用路径推导：JS接口 -> JS_write*Array/JS_writeSequenceable等函数 -> napi_unwrap获取napiParcel对象 -> 直接解引用nativeParcel_。数据流：JS接口调用传递到C++层，通过napi_unwrap获取napiParcel对象指针，虽然napiParcel指针有非空检查，但nativeParcel_成员未检查。关键调用点：所有JS_write*函数在解引用nativeParcel_前未做空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在NAPI_MessageParcel类中添加nativeParcel_的非空检查方法，并在所有nativeParcel_解引用前添加检查", "verification_notes": "分析结论正确，前置条件合理（napiParcel对象不为空但nativeParcel_成员可能为空），触发路径清晰（JS接口->JS_write*函数->napi_unwrap->解引用nativeParcel_），后果评估准确（空指针解引用可能导致程序崩溃），建议合适（添加nativeParcel_非空检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 513, "evidence": "int32_t val = napiSequence->nativeParcel_->ReadInt32();", "confidence": 0.6, "severity": "high", "gid": 1761, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 513, "evidence": "int32_t val = napiSequence->nativeParcel_->ReadInt32();", "confidence": 0.6, "severity": "high", "gid": 1762, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 533, "evidence": "int32_t val = napiSequence->nativeParcel_->ReadInt32();", "confidence": 0.6, "severity": "high", "gid": 1763, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 533, "evidence": "int32_t val = napiSequence->nativeParcel_->ReadInt32();", "confidence": 0.6, "severity": "high", "gid": 1764, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 554, "evidence": "uint32_t arrayLength = napiSequence->nativeParcel_->ReadUint32();", "confidence": 0.6, "severity": "high", "gid": 1765, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 554, "evidence": "uint32_t arrayLength = napiSequence->nativeParcel_->ReadUint32();", "confidence": 0.6, "severity": "high", "gid": 1766, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 565, "evidence": "int64_t val = napiSequence->nativeParcel_->ReadInt64();", "confidence": 0.6, "severity": "high", "gid": 1767, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 565, "evidence": "int64_t val = napiSequence->nativeParcel_->ReadInt64();", "confidence": 0.6, "severity": "high", "gid": 1768, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 585, "evidence": "int64_t val = napiSequence->nativeParcel_->ReadInt64();", "confidence": 0.6, "severity": "high", "gid": 1769, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 585, "evidence": "int64_t val = napiSequence->nativeParcel_->ReadInt64();", "confidence": 0.6, "severity": "high", "gid": 1770, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 606, "evidence": "uint32_t arrayLength = napiSequence->nativeParcel_->ReadUint32();", "confidence": 0.6, "severity": "high", "gid": 1771, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 606, "evidence": "uint32_t arrayLength = napiSequence->nativeParcel_->ReadUint32();", "confidence": 0.6, "severity": "high", "gid": 1772, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 617, "evidence": "double val = napiSequence->nativeParcel_->ReadDouble();", "confidence": 0.6, "severity": "high", "gid": 1773, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 617, "evidence": "double val = napiSequence->nativeParcel_->ReadDouble();", "confidence": 0.6, "severity": "high", "gid": 1774, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 637, "evidence": "double val = napiSequence->nativeParcel_->ReadDouble();", "confidence": 0.6, "severity": "high", "gid": 1775, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 637, "evidence": "double val = napiSequence->nativeParcel_->ReadDouble();", "confidence": 0.6, "severity": "high", "gid": 1776, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 665, "evidence": "uint32_t arrayLength = napiSequence->nativeParcel_->ReadUint32();", "confidence": 0.6, "severity": "high", "gid": 1777, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 665, "evidence": "uint32_t arrayLength = napiSequence->nativeParcel_->ReadUint32();", "confidence": 0.6, "severity": "high", "gid": 1778, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 676, "evidence": "int8_t val = napiSequence->nativeParcel_->ReadInt8();", "confidence": 0.6, "severity": "high", "gid": 1779, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 676, "evidence": "int8_t val = napiSequence->nativeParcel_->ReadInt8();", "confidence": 0.6, "severity": "high", "gid": 1780, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 697, "evidence": "int8_t val = napiSequence->nativeParcel_->ReadInt8();", "confidence": 0.6, "severity": "high", "gid": 1781, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 697, "evidence": "int8_t val = napiSequence->nativeParcel_->ReadInt8();", "confidence": 0.6, "severity": "high", "gid": 1782, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 719, "evidence": "uint32_t arrayLength = napiSequence->nativeParcel_->ReadUint32();", "confidence": 0.6, "severity": "high", "gid": 1783, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 719, "evidence": "uint32_t arrayLength = napiSequence->nativeParcel_->ReadUint32();", "confidence": 0.6, "severity": "high", "gid": 1784, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 730, "evidence": "uint8_t val = napiSequence->nativeParcel_->ReadUint8();", "confidence": 0.6, "severity": "high", "gid": 1785, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 730, "evidence": "uint8_t val = napiSequence->nativeParcel_->ReadUint8();", "confidence": 0.6, "severity": "high", "gid": 1786, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 750, "evidence": "uint8_t val = napiSequence->nativeParcel_->ReadUint8();", "confidence": 0.6, "severity": "high", "gid": 1787, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 750, "evidence": "uint8_t val = napiSequence->nativeParcel_->ReadUint8();", "confidence": 0.6, "severity": "high", "gid": 1788, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 771, "evidence": "uint32_t arrayLength = napiSequence->nativeParcel_->ReadUint32();", "confidence": 0.6, "severity": "high", "gid": 1789, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 771, "evidence": "uint32_t arrayLength = napiSequence->nativeParcel_->ReadUint32();", "confidence": 0.6, "severity": "high", "gid": 1790, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 782, "evidence": "if (napiSequence->nativeParcel_->GetReadableBytes() <= 0) {", "confidence": 0.6, "severity": "high", "gid": 1791, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 782, "evidence": "if (napiSequence->nativeParcel_->GetReadableBytes() <= 0) {", "confidence": 0.6, "severity": "high", "gid": 1792, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 785, "evidence": "std::u16string parcelString = napiSequence->nativeParcel_->ReadString16();", "confidence": 0.6, "severity": "high", "gid": 1793, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 785, "evidence": "std::u16string parcelString = napiSequence->nativeParcel_->ReadString16();", "confidence": 0.6, "severity": "high", "gid": 1794, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 799, "evidence": "if (napiSequence->nativeParcel_->GetReadableBytes() <= 0) {", "confidence": 0.6, "severity": "high", "gid": 1795, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 799, "evidence": "if (napiSequence->nativeParcel_->GetReadableBytes() <= 0) {", "confidence": 0.6, "severity": "high", "gid": 1796, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 802, "evidence": "std::u16string parcelString = napiSequence->nativeParcel_->ReadString16();", "confidence": 0.6, "severity": "high", "gid": 1797, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 802, "evidence": "std::u16string parcelString = napiSequence->nativeParcel_->ReadString16();", "confidence": 0.6, "severity": "high", "gid": 1798, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 828, "evidence": "uint32_t arrayLength = napiSequence->nativeParcel_->ReadUint32();", "confidence": 0.6, "severity": "high", "gid": 1799, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 828, "evidence": "uint32_t arrayLength = napiSequence->nativeParcel_->ReadUint32();", "confidence": 0.6, "severity": "high", "gid": 1800, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 840, "evidence": "int32_t len = napiSequence->nativeParcel_->ReadInt32();", "confidence": 0.6, "severity": "high", "gid": 1801, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 840, "evidence": "int32_t len = napiSequence->nativeParcel_->ReadInt32();", "confidence": 0.6, "severity": "high", "gid": 1802, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 879, "evidence": "int32_t arrayLength = napiSequence->nativeParcel_->ReadInt32();", "confidence": 0.6, "severity": "high", "gid": 1803, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 879, "evidence": "int32_t arrayLength = napiSequence->nativeParcel_->ReadInt32();", "confidence": 0.6, "severity": "high", "gid": 1804, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 893, "evidence": "sptr<IRemoteObject> value = napiSequence->nativeParcel_->ReadRemoteObject();", "confidence": 0.6, "severity": "high", "gid": 1805, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 893, "evidence": "sptr<IRemoteObject> value = napiSequence->nativeParcel_->ReadRemoteObject();", "confidence": 0.6, "severity": "high", "gid": 1806, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 906, "evidence": "sptr<IRemoteObject> value = napiSequence->nativeParcel_->ReadRemoteObject();", "confidence": 0.6, "severity": "high", "gid": 1807, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 906, "evidence": "sptr<IRemoteObject> value = napiSequence->nativeParcel_->ReadRemoteObject();", "confidence": 0.6, "severity": "high", "gid": 1808, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 925, "evidence": "int32_t result = napiSequence->nativeParcel_->ReadFileDescriptor();", "confidence": 0.6, "severity": "high", "gid": 1809, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_read.cpp", "line": 925, "evidence": "int32_t result = napiSequence->nativeParcel_->ReadFileDescriptor();", "confidence": 0.6, "severity": "high", "gid": 1810, "verify": "Verify napiSequence->nativeParcel_ is not null before dereferencing", "has_risk": true, "preconditions": "napiSequence对象存在但nativeParcel_成员为空指针", "trigger_path": "调用路径推导：JavaScript调用 -> NAPI接口 -> JS_readXXXArray/JS_readXXX方法 -> 直接访问nativeParcel_。数据流：从JavaScript环境传入napiSequence对象，经过NAPI接口转换后调用C++方法，方法中只检查了napiSequence指针但未检查nativeParcel_成员。关键调用点：所有JS_readXXX方法在访问nativeParcel_前都缺少空指针检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有访问nativeParcel_的代码前添加空指针检查，例如：if (napiSequence->nativeParcel_ == nullptr) { return error; }", "verification_notes": "分析结论部分正确但不够全面。前置条件和触发路径描述准确，后果评估正确。但根据项目实际安全模式，构造函数已确保nativeParcel_不为空，建议部分需要调整"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 857, "evidence": "proxyHolder->object_ = target;", "confidence": 0.6, "severity": "high", "gid": 2150, "verify": "对象指针(target, holder, nativeObject等)在解引用前非空", "has_risk": true, "preconditions": "传入的IRemoteObject指针target为空", "trigger_path": "调用路径推导：CreateJsProxyRemoteObject() -> NAPI_ohos_rpc_getRemoteProxyHolder() -> proxyHolder解引用。数据流：target参数通过CreateJsProxyRemoteObject函数传入，未进行空指针检查直接赋值给proxyHolder->object_。关键调用点：CreateJsProxyRemoteObject()函数未对target参数进行校验。", "consequences": "空指针解引用可能导致程序崩溃", "suggestions": "在CreateJsProxyRemoteObject函数入口处添加对target参数的非空检查", "verification_notes": "分析结论正确，CreateJsProxyRemoteObject函数确实未对target参数进行空指针检查，直接赋值给proxyHolder->object_可能导致空指针解引用，添加空指针检查的建议合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 858, "evidence": "proxyHolder->list_ = new (std::nothrow) NAPIDeathRecipientList();", "confidence": 0.6, "severity": "high", "gid": 2151, "verify": "对象指针(target, holder, nativeObject等)在解引用前非空", "has_risk": true, "preconditions": "传入的IRemoteObject指针target为空", "trigger_path": "调用路径推导：CreateJsProxyRemoteObject() -> NAPI_ohos_rpc_getRemoteProxyHolder() -> proxyHolder解引用。数据流：target参数通过CreateJsProxyRemoteObject函数传入，未进行空指针检查直接赋值给proxyHolder->object_。关键调用点：CreateJsProxyRemoteObject()函数未对target参数进行校验。", "consequences": "空指针解引用可能导致程序崩溃", "suggestions": "在CreateJsProxyRemoteObject函数入口处添加对target参数的非空检查", "verification_notes": "分析结论正确，CreateJsProxyRemoteObject函数确实未对target参数进行空指针检查，直接赋值给proxyHolder->object_可能导致空指针解引用，添加空指针检查的建议合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 859, "evidence": "NAPI_ASSERT(env, proxyHolder->list_ != nullptr, \"                                 \");", "confidence": 0.6, "severity": "high", "gid": 2152, "verify": "对象指针(target, holder, nativeObject等)在解引用前非空", "has_risk": true, "preconditions": "传入的IRemoteObject指针target为空", "trigger_path": "调用路径推导：CreateJsProxyRemoteObject() -> NAPI_ohos_rpc_getRemoteProxyHolder() -> proxyHolder解引用。数据流：target参数通过CreateJsProxyRemoteObject函数传入，未进行空指针检查直接赋值给proxyHolder->object_。关键调用点：CreateJsProxyRemoteObject()函数未对target参数进行校验。", "consequences": "空指针解引用可能导致程序崩溃", "suggestions": "在CreateJsProxyRemoteObject函数入口处添加对target参数的非空检查", "verification_notes": "分析结论正确，CreateJsProxyRemoteObject函数确实未对target参数进行空指针检查，直接赋值给proxyHolder->object_可能导致空指针解引用，添加空指针检查的建议合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 875, "evidence": "std::u16string descriptor = target->GetObjectDescriptor();", "confidence": 0.6, "severity": "high", "gid": 2153, "verify": "对象指针(target, holder, nativeObject等)在解引用前非空", "has_risk": true, "preconditions": "传入的IRemoteObject指针target为空", "trigger_path": "调用路径推导：CreateJsProxyRemoteObject() -> NAPI_ohos_rpc_getRemoteProxyHolder() -> proxyHolder解引用。数据流：target参数通过CreateJsProxyRemoteObject函数传入，未进行空指针检查直接赋值给proxyHolder->object_。关键调用点：CreateJsProxyRemoteObject()函数未对target参数进行校验。", "consequences": "空指针解引用可能导致程序崩溃", "suggestions": "在CreateJsProxyRemoteObject函数入口处添加对target参数的非空检查", "verification_notes": "分析结论正确，CreateJsProxyRemoteObject函数确实未对target参数进行空指针检查，直接赋值给proxyHolder->object_可能导致空指针解引用，添加空指针检查的建议合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 889, "evidence": "holder->Set(target);", "confidence": 0.6, "severity": "high", "gid": 2154, "verify": "对象指针(target, holder, nativeObject等)在解引用前非空", "has_risk": true, "preconditions": "传入的IRemoteObject指针target为空", "trigger_path": "调用路径推导：CreateJsProxyRemoteObject() -> NAPI_ohos_rpc_getRemoteProxyHolder() -> proxyHolder解引用。数据流：target参数通过CreateJsProxyRemoteObject函数传入，未进行空指针检查直接赋值给proxyHolder->object_。关键调用点：CreateJsProxyRemoteObject()函数未对target参数进行校验。", "consequences": "空指针解引用可能导致程序崩溃", "suggestions": "在CreateJsProxyRemoteObject函数入口处添加对target参数的非空检查", "verification_notes": "分析结论正确，CreateJsProxyRemoteObject函数确实未对target参数进行空指针检查，直接赋值给proxyHolder->object_可能导致空指针解引用，添加空指针检查的建议合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 917, "evidence": "if (!target->IsProxyObject()) {", "confidence": 0.6, "severity": "high", "gid": 2157, "verify": "对象指针(target, holder, nativeObject等)在解引用前非空", "has_risk": true, "preconditions": "传入的IRemoteObject指针target为空", "trigger_path": "调用路径推导：CreateJsProxyRemoteObject() -> NAPI_ohos_rpc_getRemoteProxyHolder() -> proxyHolder解引用。数据流：target参数通过CreateJsProxyRemoteObject函数传入，未进行空指针检查直接赋值给proxyHolder->object_。关键调用点：CreateJsProxyRemoteObject()函数未对target参数进行校验。", "consequences": "空指针解引用可能导致程序崩溃", "suggestions": "在CreateJsProxyRemoteObject函数入口处添加对target参数的非空检查", "verification_notes": "分析结论正确，CreateJsProxyRemoteObject函数确实未对target参数进行空指针检查，直接赋值给proxyHolder->object_可能导致空指针解引用，添加空指针检查的建议合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 919, "evidence": "uint32_t objectType = static_cast<uint32_t>(tmp->GetObjectType());", "confidence": 0.6, "severity": "high", "gid": 2158, "verify": "对象指针(target, holder, nativeObject等)在解引用前非空", "has_risk": true, "preconditions": "传入的IRemoteObject指针target为空", "trigger_path": "调用路径推导：CreateJsProxyRemoteObject() -> NAPI_ohos_rpc_getRemoteProxyHolder() -> proxyHolder解引用。数据流：target参数通过CreateJsProxyRemoteObject函数传入，未进行空指针检查直接赋值给proxyHolder->object_。关键调用点：CreateJsProxyRemoteObject()函数未对target参数进行校验。", "consequences": "空指针解引用可能导致程序崩溃", "suggestions": "在CreateJsProxyRemoteObject函数入口处添加对target参数的非空检查", "verification_notes": "分析结论正确，CreateJsProxyRemoteObject函数确实未对target参数进行空指针检查，直接赋值给proxyHolder->object_可能导致空指针解引用，添加空指针检查的建议合理"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 56, "evidence": "static NapiError napiErr;", "confidence": 0.6, "severity": "medium", "gid": 2237, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 181, "evidence": "static void NAPI_RemoteObject_saveOldCallingInfoInner(napi_env env, CallingInfo &oldCallingInfo)", "confidence": 0.5, "severity": "medium", "gid": 2238, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 207, "evidence": "static void NAPI_RemoteObject_resetOldCallingInfoInner(napi_env env, CallingInfo &oldCallingInfo)", "confidence": 0.5, "severity": "medium", "gid": 2239, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 211, "evidence": "static napi_value ThenCallback(napi_env env, napi_callback_info info)", "confidence": 0.5, "severity": "medium", "gid": 2240, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 247, "evidence": "static bool CreateThenCallback(CallbackParam *param, napi_value &thenValue)", "confidence": 0.5, "severity": "medium", "gid": 2241, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 250, "evidence": "NAPI_AUTO_LENGTH, ThenCallback, param, &thenValue);", "confidence": 0.6, "severity": "medium", "gid": 2242, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 259, "evidence": "static napi_value CatchCallback(napi_env env, napi_callback_info info)", "confidence": 0.5, "severity": "medium", "gid": 2243, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 284, "evidence": "static bool CreateCatchCallback(CallbackParam *param, napi_value &catchValue)", "confidence": 0.5, "severity": "medium", "gid": 2244, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 287, "evidence": "NAPI_AUTO_LENGTH, CatchCallback, param, &catchValue);", "confidence": 0.6, "severity": "medium", "gid": 2245, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 296, "evidence": "static bool CallPromiseThen(CallbackParam *param, napi_value &thenValue, napi_value &catchValue,", "confidence": 0.6, "severity": "medium", "gid": 2246, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 312, "evidence": "static void CallJsOnRemoteRequestCallback(CallbackParam *param, napi_value &onRemoteRequest, napi_value &thisVar,", "confidence": 0.6, "severity": "medium", "gid": 2247, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 315, "evidence": "NAPI_RemoteObject_saveOldCallingInfoInner(param->env, param->oldCallingInfo);", "confidence": 0.5, "severity": "medium", "gid": 2248, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 339, "evidence": "if (!CreateThenCallback(param, thenValue)) {", "confidence": 0.5, "severity": "medium", "gid": 2249, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 344, "evidence": "if (!CreateCatchCallback(param, catchValue)) {", "confidence": 0.5, "severity": "medium", "gid": 2250, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 349, "evidence": "if (!CallPromiseThen(param, thenValue, catchValue, returnVal, promiseThen)) {", "confidence": 0.5, "severity": "medium", "gid": 2251, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 407, "evidence": "CallJsOnRemoteRequestCallback(param, onRemoteRequest, thisVar, argv);", "confidence": 0.5, "severity": "medium", "gid": 2252, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 410, "evidence": "static void RemoteObjectHolderFinalizeCb(napi_env env, void *data, void *hint)", "confidence": 0.5, "severity": "medium", "gid": 2253, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 426, "evidence": "static void DecreaseJsObjectRef(napi_env env, napi_ref ref)", "confidence": 0.5, "severity": "medium", "gid": 2254, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 438, "evidence": "static void IncreaseJsObjectRef(napi_env env, napi_ref ref)", "confidence": 0.5, "severity": "medium", "gid": 2255, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 445, "evidence": "static void RemoteObjectHolderRefCb(napi_env env, void *data, void *hint)", "confidence": 0.5, "severity": "medium", "gid": 2256, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 470, "evidence": "DecreaseJsObjectRef(param->env, param->thisVarRef);", "confidence": 0.5, "severity": "medium", "gid": 2257, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 481, "evidence": "static void *RemoteObjectDetachCb(napi_env engine, void *value, void *hint)", "confidence": 0.5, "severity": "medium", "gid": 2258, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 498, "evidence": "static napi_value RemoteObjectAttachCb(napi_env engine, void *value, void *hint)", "confidence": 0.5, "severity": "medium", "gid": 2259, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 532, "evidence": "status = napi_wrap(env, jsRemoteObject, holder, RemoteObjectHolderRefCb, nullptr, nullptr);", "confidence": 0.5, "severity": "medium", "gid": 2260, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 562, "evidence": "napi_status status = napi_coerce_to_native_binding_object(env, thisVar, RemoteObjectDetachCb, RemoteObjectAttachCb,", "confidence": 0.6, "severity": "medium", "gid": 2261, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 562, "evidence": "napi_status status = napi_coerce_to_native_binding_object(env, thisVar, RemoteObjectDetachCb, RemoteObjectAttachCb,", "confidence": 0.6, "severity": "medium", "gid": 2262, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 569, "evidence": "status = napi_wrap(env, thisVar, holder, RemoteObjectHolderFinalizeCb, nullptr, nullptr);", "confidence": 0.5, "severity": "medium", "gid": 2263, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 614, "evidence": "IncreaseJsObjectRef(env_, jsObjectRef);", "confidence": 0.5, "severity": "medium", "gid": 2264, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 650, "evidence": "DecreaseJsObjectRef(env_, thisVarRef_);", "confidence": 0.5, "severity": "medium", "gid": 2265, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 664, "evidence": "DecreaseJsObjectRef(param->env, param->thisVarRef);", "confidence": 0.5, "severity": "medium", "gid": 2266, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 828, "evidence": "OnJsRemoteRequestCallBack(jsParam, descriptor);", "confidence": 0.5, "severity": "medium", "gid": 2267, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 979, "evidence": "static napi_value NAPI_RemoteObject_queryLocalInterface(napi_env env, napi_callback_info info)", "confidence": 0.5, "severity": "medium", "gid": 2268, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 1006, "evidence": "static napi_value NAPI_RemoteObject_getLocalInterface(napi_env env, napi_callback_info info)", "confidence": 0.5, "severity": "medium", "gid": 2269, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 1015, "evidence": "return napiErr.ThrowError(env, errorDesc::CHECK_PARAM_ERROR);", "confidence": 0.5, "severity": "medium", "gid": 2270, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 1021, "evidence": "return napiErr.ThrowError(env, errorDesc::CHECK_PARAM_ERROR);", "confidence": 0.5, "severity": "medium", "gid": 2271, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 1028, "evidence": "return napiErr.ThrowError(env, errorDesc::CHECK_PARAM_ERROR);", "confidence": 0.5, "severity": "medium", "gid": 2272, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 1035, "evidence": "return napiErr.ThrowError(env, errorDesc::CHECK_PARAM_ERROR);", "confidence": 0.5, "severity": "medium", "gid": 2273, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 1048, "evidence": "static napi_value NAPI_RemoteObject_getInterfaceDescriptor(napi_env env, napi_callback_info info)", "confidence": 0.5, "severity": "medium", "gid": 2274, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/napi_common/source/napi_remote_object.cpp", "line": 1060, "evidence": "static napi_value NAPI_RemoteObject_getDescriptor(napi_env env, napi_callback_info info)", "confidence": 0.5, "severity": "medium", "gid": 2275, "verify": "验证静态变量和回调函数在多线程环境下的同步保护", "has_risk": true, "preconditions": "多线程环境下同时访问共享的静态变量或回调函数", "trigger_path": "调用路径推导：多线程环境 -> 静态函数/回调函数调用 -> 共享状态访问。数据流：线程通过静态函数或回调函数访问共享的静态变量或全局状态。关键调用点：所有静态函数和回调函数都未对共享状态进行同步保护。", "consequences": "数据竞争导致未定义行为，可能引发程序崩溃或数据不一致", "suggestions": "为共享的静态变量和回调函数添加适当的同步机制（如互斥锁），或使用线程安全的替代方案", "verification_notes": "分析结论正确，项目记忆证实存在多线程环境下共享静态变量和回调函数的安全问题，前置条件合理，触发路径清晰，后果评估准确，建议适当"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 640, "evidence": "size_t pos = napiSequence->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 2372, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 641, "evidence": "napiSequence->nativeParcel_->WriteUint32(arrayLength);", "confidence": 0.6, "severity": "high", "gid": 2373, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 641, "evidence": "napiSequence->nativeParcel_->WriteUint32(arrayLength);", "confidence": 0.6, "severity": "high", "gid": 2374, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 662, "evidence": "result = napiSequence->nativeParcel_->WriteDouble(value);", "confidence": 0.6, "severity": "high", "gid": 2375, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 662, "evidence": "result = napiSequence->nativeParcel_->WriteDouble(value);", "confidence": 0.6, "severity": "high", "gid": 2376, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 664, "evidence": "napiSequence->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 2377, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 664, "evidence": "napiSequence->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 2378, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 697, "evidence": "size_t pos = napiSequence->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 2379, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 697, "evidence": "size_t pos = napiSequence->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 2380, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 698, "evidence": "napiSequence->nativeParcel_->WriteUint32(arrayLength);", "confidence": 0.6, "severity": "high", "gid": 2381, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 698, "evidence": "napiSequence->nativeParcel_->WriteUint32(arrayLength);", "confidence": 0.6, "severity": "high", "gid": 2382, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 719, "evidence": "result = napiSequence->nativeParcel_->WriteDouble(value);", "confidence": 0.6, "severity": "high", "gid": 2383, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 719, "evidence": "result = napiSequence->nativeParcel_->WriteDouble(value);", "confidence": 0.6, "severity": "high", "gid": 2384, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 721, "evidence": "napiSequence->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 2385, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 721, "evidence": "napiSequence->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 2386, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 754, "evidence": "size_t pos = napiSequence->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 2387, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 754, "evidence": "size_t pos = napiSequence->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 2388, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 755, "evidence": "napiSequence->nativeParcel_->WriteUint32(arrayLength);", "confidence": 0.6, "severity": "high", "gid": 2389, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 755, "evidence": "napiSequence->nativeParcel_->WriteUint32(arrayLength);", "confidence": 0.6, "severity": "high", "gid": 2390, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 770, "evidence": "result = napiSequence->nativeParcel_->WriteInt8(static_cast<int8_t>(value));", "confidence": 0.6, "severity": "high", "gid": 2391, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 770, "evidence": "result = napiSequence->nativeParcel_->WriteInt8(static_cast<int8_t>(value));", "confidence": 0.6, "severity": "high", "gid": 2392, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 772, "evidence": "napiSequence->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 2393, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 772, "evidence": "napiSequence->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 2394, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 805, "evidence": "size_t pos = napiSequence->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 2395, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 805, "evidence": "size_t pos = napiSequence->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 2396, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 806, "evidence": "napiSequence->nativeParcel_->WriteUint32(arrayLength);", "confidence": 0.6, "severity": "high", "gid": 2397, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 806, "evidence": "napiSequence->nativeParcel_->WriteUint32(arrayLength);", "confidence": 0.6, "severity": "high", "gid": 2398, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 821, "evidence": "result = napiSequence->nativeParcel_->WriteUint8(static_cast<uint8_t>(value));", "confidence": 0.6, "severity": "high", "gid": 2399, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 821, "evidence": "result = napiSequence->nativeParcel_->WriteUint8(static_cast<uint8_t>(value));", "confidence": 0.6, "severity": "high", "gid": 2400, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 823, "evidence": "napiSequence->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 2401, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 823, "evidence": "napiSequence->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 2402, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 874, "evidence": "bool result = napiSequence->nativeParcel_->WriteString16(stringValue);", "confidence": 0.6, "severity": "high", "gid": 2403, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 874, "evidence": "bool result = napiSequence->nativeParcel_->WriteString16(stringValue);", "confidence": 0.6, "severity": "high", "gid": 2404, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 941, "evidence": "size_t pos = napiSequence->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 2405, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 941, "evidence": "size_t pos = napiSequence->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 2406, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 942, "evidence": "napiSequence->nativeParcel_->WriteUint32(arrayLength);", "confidence": 0.6, "severity": "high", "gid": 2407, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 942, "evidence": "napiSequence->nativeParcel_->WriteUint32(arrayLength);", "confidence": 0.6, "severity": "high", "gid": 2408, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 960, "evidence": "result = napiSequence->nativeParcel_->WriteString16(stringValue);", "confidence": 0.6, "severity": "high", "gid": 2409, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 960, "evidence": "result = napiSequence->nativeParcel_->WriteString16(stringValue);", "confidence": 0.6, "severity": "high", "gid": 2410, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 962, "evidence": "napiSequence->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 2411, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 962, "evidence": "napiSequence->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 2412, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1001, "evidence": "size_t pos = napiSequence->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 2413, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1001, "evidence": "size_t pos = napiSequence->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 2414, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1002, "evidence": "napiSequence->nativeParcel_->WriteInt32(1);", "confidence": 0.6, "severity": "high", "gid": 2415, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1002, "evidence": "napiSequence->nativeParcel_->WriteInt32(1);", "confidence": 0.6, "severity": "high", "gid": 2416, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1018, "evidence": "napiSequence->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 2417, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1018, "evidence": "napiSequence->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 2418, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1026, "evidence": "napiSequence->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 2419, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1026, "evidence": "napiSequence->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 2420, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1073, "evidence": "size_t pos = napiSequence->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 2421, "verify": "验证napiSequence和nativeParcel_指针在解引用前是否非空", "has_risk": true, "preconditions": "napiSequence对象已创建但nativeParcel_指针未初始化或已被释放", "trigger_path": "调用路径推导：JS_writeFloatArray() -> CHECK_WRITE_CAPACITY() -> CHECK_WRITE_POSITION()。数据流：JavaScript调用通过NAPI接口进入C++层，在JS_writeFloatArray函数中获取napiSequence对象，虽然检查了napiSequence非空，但未检查nativeParcel_指针。关键调用点：CHECK_WRITE_POSITION宏直接解引用nativeParcel_指针而未检查其是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在CHECK_WRITE_POSITION宏中添加对nativeParcel_指针的非空检查，或在napiSequence对象初始化时确保nativeParcel_指针有效", "verification_notes": "分析结论正确，CHECK_WRITE_POSITION宏确实直接解引用了nativeParcel_指针而没有空指针检查。当napiSequence对象已创建但nativeParcel_指针未初始化或已被释放时，会导致空指针解引用崩溃。前置条件合理，触发路径清晰，后果评估准确，建议合适。"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1073, "evidence": "size_t pos = napiSequence->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 2422, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1074, "evidence": "if (!(napiSequence->nativeParcel_->WriteUint32(arrayLength))) {", "confidence": 0.6, "severity": "high", "gid": 2423, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1074, "evidence": "if (!(napiSequence->nativeParcel_->WriteUint32(arrayLength))) {", "confidence": 0.6, "severity": "high", "gid": 2424, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1091, "evidence": "napiSequence->nativeParcel_->WriteInt32(0);", "confidence": 0.6, "severity": "high", "gid": 2425, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1091, "evidence": "napiSequence->nativeParcel_->WriteInt32(0);", "confidence": 0.6, "severity": "high", "gid": 2426, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1094, "evidence": "napiSequence->nativeParcel_->WriteInt32(1);", "confidence": 0.6, "severity": "high", "gid": 2427, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1094, "evidence": "napiSequence->nativeParcel_->WriteInt32(1);", "confidence": 0.6, "severity": "high", "gid": 2428, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1099, "evidence": "napiSequence->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 2429, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1099, "evidence": "napiSequence->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 2430, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1130, "evidence": "napiSequence->nativeParcel_->WriteInt32(-1);", "confidence": 0.6, "severity": "high", "gid": 2431, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1130, "evidence": "napiSequence->nativeParcel_->WriteInt32(-1);", "confidence": 0.6, "severity": "high", "gid": 2432, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1134, "evidence": "size_t pos = napiSequence->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 2433, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1134, "evidence": "size_t pos = napiSequence->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 2434, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1135, "evidence": "bool result =  napiSequence->nativeParcel_->WriteInt32(arrayLength);", "confidence": 0.6, "severity": "high", "gid": 2435, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1135, "evidence": "bool result =  napiSequence->nativeParcel_->WriteInt32(arrayLength);", "confidence": 0.6, "severity": "high", "gid": 2436, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1150, "evidence": "result = napiSequence->nativeParcel_->WriteRemoteObject(remoteObject);", "confidence": 0.6, "severity": "high", "gid": 2437, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1150, "evidence": "result = napiSequence->nativeParcel_->WriteRemoteObject(remoteObject);", "confidence": 0.6, "severity": "high", "gid": 2438, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1152, "evidence": "napiSequence->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 2439, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1152, "evidence": "napiSequence->nativeParcel_->RewindWrite(pos);", "confidence": 0.6, "severity": "high", "gid": 2440, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1191, "evidence": "bool result = napiSequence->nativeParcel_->SetDataSize(static_cast<size_t>(value));", "confidence": 0.6, "severity": "high", "gid": 2441, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1191, "evidence": "bool result = napiSequence->nativeParcel_->SetDataSize(static_cast<size_t>(value));", "confidence": 0.6, "severity": "high", "gid": 2442, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1229, "evidence": "bool result = napiSequence->nativeParcel_->SetDataCapacity(static_cast<size_t>(value));", "confidence": 0.6, "severity": "high", "gid": 2443, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1229, "evidence": "bool result = napiSequence->nativeParcel_->SetDataCapacity(static_cast<size_t>(value));", "confidence": 0.6, "severity": "high", "gid": 2444, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1231, "evidence": "napiSequence->maxCapacityToWrite_ = value;", "confidence": 0.6, "severity": "high", "gid": 2445, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1251, "evidence": "size_t value = napiSequence->nativeParcel_->GetWritableBytes();", "confidence": 0.6, "severity": "high", "gid": 2446, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1251, "evidence": "size_t value = napiSequence->nativeParcel_->GetWritableBytes();", "confidence": 0.6, "severity": "high", "gid": 2447, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1267, "evidence": "size_t value = napiSequence->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 2448, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1267, "evidence": "size_t value = napiSequence->nativeParcel_->GetWritePosition();", "confidence": 0.6, "severity": "high", "gid": 2449, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1302, "evidence": "bool result = napiSequence->nativeParcel_->RewindWrite(static_cast<size_t>(pos));", "confidence": 0.6, "severity": "high", "gid": 2450, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1302, "evidence": "bool result = napiSequence->nativeParcel_->RewindWrite(static_cast<size_t>(pos));", "confidence": 0.6, "severity": "high", "gid": 2451, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1319, "evidence": "bool writeResult = napiSequence->nativeParcel_->WriteInt32(0);", "confidence": 0.6, "severity": "high", "gid": 2452, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1319, "evidence": "bool writeResult = napiSequence->nativeParcel_->WriteInt32(0);", "confidence": 0.6, "severity": "high", "gid": 2453, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1438, "evidence": "bool writeResult = napiSequence->nativeParcel_->WriteRemoteObject(remoteObject);", "confidence": 0.6, "severity": "high", "gid": 2454, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1438, "evidence": "bool writeResult = napiSequence->nativeParcel_->WriteRemoteObject(remoteObject);", "confidence": 0.6, "severity": "high", "gid": 2455, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1487, "evidence": "bool writeResult = napiSequence->nativeParcel_->WriteInterfaceToken(stringValue);", "confidence": 0.6, "severity": "high", "gid": 2456, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1487, "evidence": "bool writeResult = napiSequence->nativeParcel_->WriteInterfaceToken(stringValue);", "confidence": 0.6, "severity": "high", "gid": 2457, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1561, "evidence": "bool result = napiSequence->nativeParcel_->ContainFileDescriptors();", "confidence": 0.6, "severity": "high", "gid": 2458, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1561, "evidence": "bool result = napiSequence->nativeParcel_->ContainFileDescriptors();", "confidence": 0.6, "severity": "high", "gid": 2459, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1591, "evidence": "bool result = napiSequence->nativeParcel_->WriteFileDescriptor(fd);", "confidence": 0.6, "severity": "high", "gid": 2460, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1591, "evidence": "bool result = napiSequence->nativeParcel_->WriteFileDescriptor(fd);", "confidence": 0.6, "severity": "high", "gid": 2461, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1639, "evidence": "sptr<Ashmem> nativeAshmem = napiAshmem->GetAshmem();", "confidence": 0.6, "severity": "high", "gid": 2462, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1646, "evidence": "bool result = napiSequence->nativeParcel_->WriteAshmem(nativeAshmem);", "confidence": 0.6, "severity": "high", "gid": 2463, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1646, "evidence": "bool result = napiSequence->nativeParcel_->WriteAshmem(nativeAshmem);", "confidence": 0.6, "severity": "high", "gid": 2464, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1717, "evidence": "return napiSequence->nativeParcel_->WriteRawData(array.data(), size * BYTE_SIZE_32);", "confidence": 0.6, "severity": "high", "gid": 2465, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1717, "evidence": "return napiSequence->nativeParcel_->WriteRawData(array.data(), size * BYTE_SIZE_32);", "confidence": 0.6, "severity": "high", "gid": 2466, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1739, "evidence": "return napiSequence->nativeParcel_->WriteRawData(data - byteOffset, BYTE_SIZE_32 * size);", "confidence": 0.6, "severity": "high", "gid": 2467, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1739, "evidence": "return napiSequence->nativeParcel_->WriteRawData(data - byteOffset, BYTE_SIZE_32 * size);", "confidence": 0.6, "severity": "high", "gid": 2468, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1832, "evidence": "if (!napiSequence->nativeParcel_->WriteRawData(data, size)) {", "confidence": 0.6, "severity": "high", "gid": 2469, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1832, "evidence": "if (!napiSequence->nativeParcel_->WriteRawData(data, size)) {", "confidence": 0.6, "severity": "high", "gid": 2470, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/napi_common/source/napi_message_sequence_write.cpp", "line": 1850, "evidence": "uint32_t result = napiSequence->nativeParcel_->GetRawDataCapacity();", "confidence": 0.6, "severity": "high", "gid": 2471, "verify": "Verify napiSequence->nativeParcel_ is non-null before dereferencing", "has_risk": true, "preconditions": "napiSequence->nativeParcel_ 被意外置空或释放", "trigger_path": "调用路径推导：JS_*函数（如JS_writeRemoteObjectArray）-> NAPI_MessageSequence成员函数。数据流：JavaScript调用通过napi接口进入C++层，通过napi_unwrap获取NAPI_MessageSequence实例。关键调用点：所有使用nativeParcel_的成员函数都未对nativeParcel_进行空指针检查，尽管构造函数确保初始化时不为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有使用nativeParcel_的成员函数中添加空指针检查，或使用智能指针的get()方法进行安全访问", "verification_notes": "分析结论正确，项目记忆确认nativeParcel_指针使用缺乏检查的系统性问题，前置条件合理，触发路径成立，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/invoker/source/binder_invoker.cpp", "line": 212, "evidence": "if (flat->hdr.type == BINDER_TYPE_HANDLE && flat->cookie != IRemoteObject::IF_PROT_BINDER) {", "confidence": 0.6, "severity": "high", "gid": 2504, "verify": "检查flat指针在使用前是否非空", "has_risk": true, "preconditions": "外部调用SendRequest时传入无效或恶意的MessageParcel对象", "trigger_path": "调用路径推导：外部调用者 -> SendRequest() -> TranslateDBinderProxy() -> 使用flat指针。数据流：MessageParcel对象通过SendRequest参数传入，传递给TranslateDBinderProxy处理，TranslateDBinderProxy直接从MessageParcel获取数据并转换为flat指针。关键调用点：SendRequest()和TranslateDBinderProxy()均未对MessageParcel参数进行有效性校验。", "consequences": "空指针解引用，可能导致程序崩溃或拒绝服务", "suggestions": "在TranslateDBinderProxy中对flat指针进行空指针检查，或者在SendRequest中对输入参数进行有效性验证", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/invoker/source/binder_invoker.cpp", "line": 217, "evidence": "if (flat->hdr.type == BINDER_TYPE_HANDLE && flat->cookie == IRemoteObject::IF_PROT_DATABUS", "confidence": 0.6, "severity": "high", "gid": 2505, "verify": "检查flat指针在使用前是否非空", "has_risk": true, "preconditions": "外部调用SendRequest时传入无效或恶意的MessageParcel对象", "trigger_path": "调用路径推导：外部调用者 -> SendRequest() -> TranslateDBinderProxy() -> 使用flat指针。数据流：MessageParcel对象通过SendRequest参数传入，传递给TranslateDBinderProxy处理，TranslateDBinderProxy直接从MessageParcel获取数据并转换为flat指针。关键调用点：SendRequest()和TranslateDBinderProxy()均未对MessageParcel参数进行有效性校验。", "consequences": "空指针解引用，可能导致程序崩溃或拒绝服务", "suggestions": "在TranslateDBinderProxy中对flat指针进行空指针检查，或者在SendRequest中对输入参数进行有效性验证", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/invoker/source/binder_invoker.cpp", "line": 218, "evidence": "&& flat->handle < IPCProcessSkeleton::DBINDER_HANDLE_BASE) {", "confidence": 0.6, "severity": "high", "gid": 2506, "verify": "检查flat指针在使用前是否非空", "has_risk": true, "preconditions": "外部调用SendRequest时传入无效或恶意的MessageParcel对象", "trigger_path": "调用路径推导：外部调用者 -> SendRequest() -> TranslateDBinderProxy() -> 使用flat指针。数据流：MessageParcel对象通过SendRequest参数传入，传递给TranslateDBinderProxy处理，TranslateDBinderProxy直接从MessageParcel获取数据并转换为flat指针。关键调用点：SendRequest()和TranslateDBinderProxy()均未对MessageParcel参数进行有效性校验。", "consequences": "空指针解引用，可能导致程序崩溃或拒绝服务", "suggestions": "在TranslateDBinderProxy中对flat指针进行空指针检查，或者在SendRequest中对输入参数进行有效性验证", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/invoker/source/binder_invoker.cpp", "line": 329, "evidence": "ZLOGE(LABEL, \"                                      \", flat->handle);", "confidence": 0.6, "severity": "high", "gid": 2512, "verify": "检查flat指针在使用前是否非空", "has_risk": true, "preconditions": "外部调用SendRequest时传入无效或恶意的MessageParcel对象", "trigger_path": "调用路径推导：外部调用者 -> SendRequest() -> TranslateDBinderProxy() -> 使用flat指针。数据流：MessageParcel对象通过SendRequest参数传入，传递给TranslateDBinderProxy处理，TranslateDBinderProxy直接从MessageParcel获取数据并转换为flat指针。关键调用点：SendRequest()和TranslateDBinderProxy()均未对MessageParcel参数进行有效性校验。", "consequences": "空指针解引用，可能导致程序崩溃或拒绝服务", "suggestions": "在TranslateDBinderProxy中对flat指针进行空指针检查，或者在SendRequest中对输入参数进行有效性验证", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/invoker/source/binder_invoker.cpp", "line": 339, "evidence": "if (invoker->SendRequest(flat->handle, DBINDER_ADD_COMMAUTH, data2, reply2, option2) != ERR_NONE) {", "confidence": 0.6, "severity": "high", "gid": 2515, "verify": "检查flat指针在使用前是否非空", "has_risk": true, "preconditions": "外部调用SendRequest时传入无效或恶意的MessageParcel对象", "trigger_path": "调用路径推导：外部调用者 -> SendRequest() -> TranslateDBinderProxy() -> 使用flat指针。数据流：MessageParcel对象通过SendRequest参数传入，传递给TranslateDBinderProxy处理，TranslateDBinderProxy直接从MessageParcel获取数据并转换为flat指针。关键调用点：SendRequest()和TranslateDBinderProxy()均未对MessageParcel参数进行有效性校验。", "consequences": "空指针解引用，可能导致程序崩溃或拒绝服务", "suggestions": "在TranslateDBinderProxy中对flat指针进行空指针检查，或者在SendRequest中对输入参数进行有效性验证", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/invoker/source/binder_invoker.cpp", "line": 339, "evidence": "if (invoker->SendRequest(flat->handle, DBINDER_ADD_COMMAUTH, data2, reply2, option2) != ERR_NONE) {", "confidence": 0.6, "severity": "high", "gid": 2516, "verify": "检查flat指针在使用前是否非空", "has_risk": true, "preconditions": "外部调用SendRequest时传入无效或恶意的MessageParcel对象", "trigger_path": "调用路径推导：外部调用者 -> SendRequest() -> TranslateDBinderProxy() -> 使用flat指针。数据流：MessageParcel对象通过SendRequest参数传入，传递给TranslateDBinderProxy处理，TranslateDBinderProxy直接从MessageParcel获取数据并转换为flat指针。关键调用点：SendRequest()和TranslateDBinderProxy()均未对MessageParcel参数进行有效性校验。", "consequences": "空指针解引用，可能导致程序崩溃或拒绝服务", "suggestions": "在TranslateDBinderProxy中对flat指针进行空指针检查，或者在SendRequest中对输入参数进行有效性验证", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/invoker/source/binder_invoker.cpp", "line": 400, "evidence": "if (flat->hdr.type != BINDER_TYPE_BINDER) {", "confidence": 0.6, "severity": "high", "gid": 2521, "verify": "检查flat指针在使用前是否非空", "has_risk": true, "preconditions": "外部调用SendRequest时传入无效或恶意的MessageParcel对象", "trigger_path": "调用路径推导：外部调用者 -> SendRequest() -> TranslateDBinderProxy() -> 使用flat指针。数据流：MessageParcel对象通过SendRequest参数传入，传递给TranslateDBinderProxy处理，TranslateDBinderProxy直接从MessageParcel获取数据并转换为flat指针。关键调用点：SendRequest()和TranslateDBinderProxy()均未对MessageParcel参数进行有效性校验。", "consequences": "空指针解引用，可能导致程序崩溃或拒绝服务", "suggestions": "在TranslateDBinderProxy中对flat指针进行空指针检查，或者在SendRequest中对输入参数进行有效性验证", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/invoker/source/binder_invoker.cpp", "line": 401, "evidence": "ZLOGE(LABEL, \"                                 \", flat->hdr.type);", "confidence": 0.6, "severity": "high", "gid": 2522, "verify": "检查flat指针在使用前是否非空", "has_risk": true, "preconditions": "外部调用SendRequest时传入无效或恶意的MessageParcel对象", "trigger_path": "调用路径推导：外部调用者 -> SendRequest() -> TranslateDBinderProxy() -> 使用flat指针。数据流：MessageParcel对象通过SendRequest参数传入，传递给TranslateDBinderProxy处理，TranslateDBinderProxy直接从MessageParcel获取数据并转换为flat指针。关键调用点：SendRequest()和TranslateDBinderProxy()均未对MessageParcel参数进行有效性校验。", "consequences": "空指针解引用，可能导致程序崩溃或拒绝服务", "suggestions": "在TranslateDBinderProxy中对flat指针进行空指针检查，或者在SendRequest中对输入参数进行有效性验证", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/invoker/source/binder_invoker.cpp", "line": 405, "evidence": "ZLOGE(LABEL, \"                                                 \", flat->cookie);", "confidence": 0.6, "severity": "high", "gid": 2523, "verify": "检查flat指针在使用前是否非空", "has_risk": true, "preconditions": "外部调用SendRequest时传入无效或恶意的MessageParcel对象", "trigger_path": "调用路径推导：外部调用者 -> SendRequest() -> TranslateDBinderProxy() -> 使用flat指针。数据流：MessageParcel对象通过SendRequest参数传入，传递给TranslateDBinderProxy处理，TranslateDBinderProxy直接从MessageParcel获取数据并转换为flat指针。关键调用点：SendRequest()和TranslateDBinderProxy()均未对MessageParcel参数进行有效性校验。", "consequences": "空指针解引用，可能导致程序崩溃或拒绝服务", "suggestions": "在TranslateDBinderProxy中对flat指针进行空指针检查，或者在SendRequest中对输入参数进行有效性验证", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/invoker/source/binder_invoker.cpp", "line": 409, "evidence": "auto stub = reinterpret_cast<IPCObjectStub *>(flat->cookie);", "confidence": 0.6, "severity": "high", "gid": 2524, "verify": "检查flat指针在使用前是否非空", "has_risk": true, "preconditions": "外部调用SendRequest时传入无效或恶意的MessageParcel对象", "trigger_path": "调用路径推导：外部调用者 -> SendRequest() -> TranslateDBinderProxy() -> 使用flat指针。数据流：MessageParcel对象通过SendRequest参数传入，传递给TranslateDBinderProxy处理，TranslateDBinderProxy直接从MessageParcel获取数据并转换为flat指针。关键调用点：SendRequest()和TranslateDBinderProxy()均未对MessageParcel参数进行有效性校验。", "consequences": "空指针解引用，可能导致程序崩溃或拒绝服务", "suggestions": "在TranslateDBinderProxy中对flat指针进行空指针检查，或者在SendRequest中对输入参数进行有效性验证", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/invoker/source/binder_invoker.cpp", "line": 410, "evidence": "if (stub->GetAndSaveDBinderData(pid, uid) != ERR_NONE) {", "confidence": 0.6, "severity": "high", "gid": 2525, "verify": "检查flat指针在使用前是否非空", "has_risk": true, "preconditions": "外部调用SendRequest时传入无效或恶意的MessageParcel对象", "trigger_path": "调用路径推导：外部调用者 -> SendRequest() -> TranslateDBinderProxy() -> 使用flat指针。数据流：MessageParcel对象通过SendRequest参数传入，传递给TranslateDBinderProxy处理，TranslateDBinderProxy直接从MessageParcel获取数据并转换为flat指针。关键调用点：SendRequest()和TranslateDBinderProxy()均未对MessageParcel参数进行有效性校验。", "consequences": "空指针解引用，可能导致程序崩溃或拒绝服务", "suggestions": "在TranslateDBinderProxy中对flat指针进行空指针检查，或者在SendRequest中对输入参数进行有效性验证", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/invoker/source/binder_invoker.cpp", "line": 411, "evidence": "ZLOGE(LABEL, \"                                               \", flat->cookie);", "confidence": 0.6, "severity": "high", "gid": 2526, "verify": "检查flat指针在使用前是否非空", "has_risk": true, "preconditions": "外部调用SendRequest时传入无效或恶意的MessageParcel对象", "trigger_path": "调用路径推导：外部调用者 -> SendRequest() -> TranslateDBinderProxy() -> 使用flat指针。数据流：MessageParcel对象通过SendRequest参数传入，传递给TranslateDBinderProxy处理，TranslateDBinderProxy直接从MessageParcel获取数据并转换为flat指针。关键调用点：SendRequest()和TranslateDBinderProxy()均未对MessageParcel参数进行有效性校验。", "consequences": "空指针解引用，可能导致程序崩溃或拒绝服务", "suggestions": "在TranslateDBinderProxy中对flat指针进行空指针检查，或者在SendRequest中对输入参数进行有效性验证", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/invoker/source/binder_invoker.cpp", "line": 414, "evidence": "ZLOGI(LABEL, \"                         \", flat->cookie);", "confidence": 0.6, "severity": "high", "gid": 2527, "verify": "检查flat指针在使用前是否非空", "has_risk": true, "preconditions": "外部调用SendRequest时传入无效或恶意的MessageParcel对象", "trigger_path": "调用路径推导：外部调用者 -> SendRequest() -> TranslateDBinderProxy() -> 使用flat指针。数据流：MessageParcel对象通过SendRequest参数传入，传递给TranslateDBinderProxy处理，TranslateDBinderProxy直接从MessageParcel获取数据并转换为flat指针。关键调用点：SendRequest()和TranslateDBinderProxy()均未对MessageParcel参数进行有效性校验。", "consequences": "空指针解引用，可能导致程序崩溃或拒绝服务", "suggestions": "在TranslateDBinderProxy中对flat指针进行空指针检查，或者在SendRequest中对输入参数进行有效性验证", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "error_handling", "pattern": "io_call", "file": "ipc/native/src/core/invoker/source/binder_connector.cpp", "line": 179, "evidence": "(void)fclose(fp);", "confidence": 0.65, "severity": "medium", "gid": 2667, "verify": "验证文件操作是否有错误处理", "has_risk": true, "preconditions": "fclose()操作失败且错误被忽略", "trigger_path": "调用路径推导：外部调用 -> GetSelfTokenID()/GetSelfFirstCallerTokenID() -> fclose()。数据流：文件指针通过fopen()获取，在方法结束时调用fclose()。关键调用点：两个方法中均未检查fclose()返回值，直接使用(void)强制忽略。", "consequences": "可能导致文件未正确关闭，资源泄漏或数据不一致", "suggestions": "添加fclose()错误日志记录，或考虑使用RAII模式管理文件资源", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "error_handling", "pattern": "io_call", "file": "ipc/native/src/core/invoker/source/binder_connector.cpp", "line": 186, "evidence": "(void)fclose(fp);", "confidence": 0.65, "severity": "medium", "gid": 2668, "verify": "验证文件操作是否有错误处理", "has_risk": true, "preconditions": "fclose()操作失败且错误被忽略", "trigger_path": "调用路径推导：外部调用 -> GetSelfTokenID()/GetSelfFirstCallerTokenID() -> fclose()。数据流：文件指针通过fopen()获取，在方法结束时调用fclose()。关键调用点：两个方法中均未检查fclose()返回值，直接使用(void)强制忽略。", "consequences": "可能导致文件未正确关闭，资源泄漏或数据不一致", "suggestions": "添加fclose()错误日志记录，或考虑使用RAII模式管理文件资源", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "error_handling", "pattern": "io_call", "file": "ipc/native/src/core/invoker/source/binder_connector.cpp", "line": 206, "evidence": "(void)fclose(fp);", "confidence": 0.65, "severity": "medium", "gid": 2669, "verify": "验证文件操作是否有错误处理", "has_risk": true, "preconditions": "fclose()操作失败且错误被忽略", "trigger_path": "调用路径推导：外部调用 -> GetSelfTokenID()/GetSelfFirstCallerTokenID() -> fclose()。数据流：文件指针通过fopen()获取，在方法结束时调用fclose()。关键调用点：两个方法中均未检查fclose()返回值，直接使用(void)强制忽略。", "consequences": "可能导致文件未正确关闭，资源泄漏或数据不一致", "suggestions": "添加fclose()错误日志记录，或考虑使用RAII模式管理文件资源", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "error_handling", "pattern": "io_call", "file": "ipc/native/src/core/invoker/source/binder_connector.cpp", "line": 214, "evidence": "(void)fclose(fp);", "confidence": 0.65, "severity": "medium", "gid": 2670, "verify": "验证文件操作是否有错误处理", "has_risk": true, "preconditions": "fclose()操作失败且错误被忽略", "trigger_path": "调用路径推导：外部调用 -> GetSelfTokenID()/GetSelfFirstCallerTokenID() -> fclose()。数据流：文件指针通过fopen()获取，在方法结束时调用fclose()。关键调用点：两个方法中均未检查fclose()返回值，直接使用(void)强制忽略。", "consequences": "可能导致文件未正确关闭，资源泄漏或数据不一致", "suggestions": "添加fclose()错误日志记录，或考虑使用RAII模式管理文件资源", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "missing_virtual_dtor", "file": "ipc/native/src/core/framework/include/ipc_debug.h", "line": 82, "evidence": "class IPCError : public ErrorBase {", "confidence": 0.75, "severity": "high", "gid": 2673, "verify": "验证IPCError类是否需要虚析构函数", "has_risk": true, "preconditions": "IPCError类被继承，且派生类有自己的资源需要管理", "trigger_path": "设计缺陷路径：当通过基类(ErrorBase)指针删除派生类对象时，由于IPCError的析构函数不是虚函数，不会调用派生类的析构函数。调用链：delete基类指针 -> ErrorBase::~ErrorBase()（非虚）-> 跳过派生类析构函数。关键点：IPCError类包含虚函数(GetErrorMap)但未声明虚析构函数。", "consequences": "可能导致派生类资源泄漏，如果派生类管理了需要释放的资源", "suggestions": "将IPCError的析构函数声明为虚函数：virtual ~IPCError() = default;", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/core/framework/include/ipc_workthread.h", "line": 55, "evidence": "static void *ThreadHandler(void *args);", "confidence": 0.5, "severity": "medium", "gid": 2674, "verify": "验证线程处理函数是否实现了适当的同步机制(如互斥锁)来保护共享数据", "has_risk": true, "preconditions": "IPCThreadSkeleton或ProcessSkeleton未正确实现同步机制", "trigger_path": "调用路径推导：IPCWorkThread::Start() -> pthread_create() -> IPCWorkThread::ThreadHandler() -> IPCWorkThread::JoinThread()。数据流：线程参数通过Start函数传递给ThreadHandler，ThreadHandler调用JoinThread。关键调用点：ThreadHandler和JoinThread函数本身未直接实现同步机制，依赖IPCThreadSkeleton和ProcessSkeleton的同步控制。", "consequences": "可能导致数据竞争或线程安全问题，影响IPC通信的可靠性", "suggestions": "1. 在ThreadHandler和JoinThread中直接添加必要的同步机制 2. 确保IPCThreadSkeleton和ProcessSkeleton正确实现了同步控制 3. 对共享资源的访问进行明确的同步保护", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "ipc/native/src/core/framework/include/ipc_workthread.h", "line": 56, "evidence": "static void JoinThread(int proto, int policy);", "confidence": 0.5, "severity": "medium", "gid": 2675, "verify": "验证线程处理函数是否实现了适当的同步机制(如互斥锁)来保护共享数据", "has_risk": true, "preconditions": "IPCThreadSkeleton或ProcessSkeleton未正确实现同步机制", "trigger_path": "调用路径推导：IPCWorkThread::Start() -> pthread_create() -> IPCWorkThread::ThreadHandler() -> IPCWorkThread::JoinThread()。数据流：线程参数通过Start函数传递给ThreadHandler，ThreadHandler调用JoinThread。关键调用点：ThreadHandler和JoinThread函数本身未直接实现同步机制，依赖IPCThreadSkeleton和ProcessSkeleton的同步控制。", "consequences": "可能导致数据竞争或线程安全问题，影响IPC通信的可靠性", "suggestions": "1. 在ThreadHandler和JoinThread中直接添加必要的同步机制 2. 确保IPCThreadSkeleton和ProcessSkeleton正确实现了同步控制 3. 对共享资源的访问进行明确的同步保护", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/framework/source/ipc_skeleton.cpp", "line": 263, "evidence": "bool isBinderInvoker = (proxy->GetProto() == IRemoteObject::IF_PROT_BINDER);", "confidence": 0.6, "severity": "high", "gid": 2801, "verify": "验证proxy指针在解引用前非空", "has_risk": true, "preconditions": "FlushCommands函数被调用时传入nullptr或未校验的IRemoteObject指针", "trigger_path": "调用路径推导：IPCThreadSkeleton::TlsDestructor() -> BinderInvoker::FlushCommands(nullptr)。数据流：在TlsDestructor中直接传入nullptr调用FlushCommands。关键调用点：IPCThreadSkeleton.cpp第71行直接传入nullptr调用FlushCommands，而FlushCommands函数内部未对object参数进行判空就直接解引用。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "1. 在FlushCommands函数开始处添加对object参数的判空检查；2. 确保所有调用路径传入的object参数都是非空的", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/framework/source/process_skeleton.cpp", "line": 166, "evidence": "if (object->IsProxyObject()) {", "confidence": 0.6, "severity": "high", "gid": 2818, "verify": "检查对象指针(object/remoteObject/result/connector)在使用前是否为空", "has_risk": true, "preconditions": "传入的object参数为nullptr", "trigger_path": "调用路径推导：未知调用者 -> AttachObject() -> object->IsProxyObject()。数据流：object参数来自函数调用者，但当前代码中未找到直接调用者。关键调用点：AttachObject()函数未对object参数进行空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在AttachObject()函数入口处添加对object参数的nullptr检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/framework/source/process_skeleton.cpp", "line": 389, "evidence": "auto ret = memcpy_s(dbinderData, sizeof(dbinder_negotiation_data), reinterpret_cast<const void *>(obj->buffer),", "confidence": 0.6, "severity": "high", "gid": 2826, "verify": "检查memcpy_s操作中源/目标缓冲区是否有效，长度是否正确", "has_risk": true, "preconditions": "传入的binder_buffer_object结构体包含恶意构造的buffer指针或长度", "trigger_path": "调用路径推导：ProcessSkeletonUnitTest/UnFlattenDBinderDataFuzzTest -> UnFlattenDBinderData -> memcpy_s。数据流：测试用例或fuzz测试构造的Parcel数据通过ReadBuffer读取为binder_buffer_object，直接传递给memcpy_s。关键调用点：UnFlattenDBinderData函数未验证obj->buffer的有效性和obj->length的正确性。", "consequences": "内存越界访问，可能导致信息泄露或程序崩溃", "suggestions": "在UnFlattenDBinderData中添加输入验证：检查obj->buffer非空且obj->length等于sizeof(dbinder_negotiation_data)", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/framework/source/process_skeleton.cpp", "line": 390, "evidence": "obj->length);", "confidence": 0.6, "severity": "high", "gid": 2827, "verify": "检查memcpy_s操作中源/目标缓冲区是否有效，长度是否正确", "has_risk": true, "preconditions": "传入的binder_buffer_object结构体包含恶意构造的buffer指针或长度", "trigger_path": "调用路径推导：ProcessSkeletonUnitTest/UnFlattenDBinderDataFuzzTest -> UnFlattenDBinderData -> memcpy_s。数据流：测试用例或fuzz测试构造的Parcel数据通过ReadBuffer读取为binder_buffer_object，直接传递给memcpy_s。关键调用点：UnFlattenDBinderData函数未验证obj->buffer的有效性和obj->length的正确性。", "consequences": "内存越界访问，可能导致信息泄露或程序崩溃", "suggestions": "在UnFlattenDBinderData中添加输入验证：检查obj->buffer非空且obj->length等于sizeof(dbinder_negotiation_data)", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/framework/source/message_parcel.cpp", "line": 552, "evidence": "int fd = ashmem->GetAshmemFd();", "confidence": 0.6, "severity": "high", "gid": 3099, "verify": "检查指针解引用前是否确保非空", "has_risk": true, "preconditions": "调用者传入空指针作为ashmem参数", "trigger_path": "调用路径推导：外部调用 -> WriteAshmem()。数据流：ashmem参数由外部调用传入，WriteAshmem()函数内部未对指针进行判空检查。关键调用点：WriteAshmem()函数未对输入指针进行校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在WriteAshmem()函数开头添加空指针检查：if (ashmem == nullptr) { return false; }", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/framework/source/message_parcel.cpp", "line": 553, "evidence": "int32_t size = ashmem->GetAshmemSize();", "confidence": 0.6, "severity": "high", "gid": 3100, "verify": "检查指针解引用前是否确保非空", "has_risk": true, "preconditions": "调用者传入空指针作为ashmem参数", "trigger_path": "调用路径推导：外部调用 -> WriteAshmem()。数据流：ashmem参数由外部调用传入，WriteAshmem()函数内部未对指针进行判空检查。关键调用点：WriteAshmem()函数未对输入指针进行校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在WriteAshmem()函数开头添加空指针检查：if (ashmem == nullptr) { return false; }", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "alloc_no_null_check", "file": "ipc/native/src/core/framework/source/ipc_thread_skeleton.cpp", "line": 106, "evidence": "instance = new (std::nothrow) IPCThreadSkeleton();", "confidence": 0.65, "severity": "medium", "gid": 3113, "verify": "检查new (std::nothrow)分配结果是否在使用前进行了空指针检查", "has_risk": true, "preconditions": "new (std::nothrow)分配失败返回空指针", "trigger_path": "调用路径推导：\n1. 对于gid 3113: GetCurrent() -> GetVaildInstance()\n   - 输入来源：线程本地存储(TLS)获取的current指针\n   - 传递路径：current指针传递给GetVaildInstance()作为参数\n   - 关键调用点：GetVaildInstance()未检查new分配结果就直接使用instance\n\n2. 对于gid 3114: 任何调用GetCurrent()的代码\n   - 输入来源：线程本地存储(TLS)为空时触发分配\n   - 传递路径：直接返回new分配的结果\n   - 关键调用点：GetCurrent()未检查new分配结果就返回current指针\n\n触发条件：当内存不足导致new (std::nothrow)返回空指针时\n", "consequences": "空指针解引用可能导致程序崩溃或未定义行为", "suggestions": "在new (std::nothrow)分配后立即检查指针是否为null，并做适当错误处理", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "alloc_no_null_check", "file": "ipc/native/src/core/framework/source/ipc_thread_skeleton.cpp", "line": 136, "evidence": "current = new (std::nothrow) IPCThreadSkeleton();", "confidence": 0.65, "severity": "medium", "gid": 3114, "verify": "检查new (std::nothrow)分配结果是否在使用前进行了空指针检查", "has_risk": true, "preconditions": "new (std::nothrow)分配失败返回空指针", "trigger_path": "调用路径推导：\n1. 对于gid 3113: GetCurrent() -> GetVaildInstance()\n   - 输入来源：线程本地存储(TLS)获取的current指针\n   - 传递路径：current指针传递给GetVaildInstance()作为参数\n   - 关键调用点：GetVaildInstance()未检查new分配结果就直接使用instance\n\n2. 对于gid 3114: 任何调用GetCurrent()的代码\n   - 输入来源：线程本地存储(TLS)为空时触发分配\n   - 传递路径：直接返回new分配的结果\n   - 关键调用点：GetCurrent()未检查new分配结果就返回current指针\n\n触发条件：当内存不足导致new (std::nothrow)返回空指针时\n", "consequences": "空指针解引用可能导致程序崩溃或未定义行为", "suggestions": "在new (std::nothrow)分配后立即检查指针是否为null，并做适当错误处理", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "type_safety", "pattern": "const_cast_unsafe", "file": "ipc/native/src/core/dbinder/include/dbinder_base_invoker_process.h", "line": 128, "evidence": "uint32_t &newflags = const_cast<uint32_t &>(tr->flags);", "confidence": 0.75, "severity": "high", "gid": 3379, "verify": "验证reinterpret_cast和const_cast类型转换是否安全，是否会导致未定义行为", "has_risk": true, "preconditions": "tr->flags 被标记为 const 但需要被修改", "trigger_path": "调用路径推导：ProcessTransaction() -> 这里。数据流：dbinder_transaction_data 结构体通过参数传入 ProcessTransaction()，其 flags 成员被标记为 const 但需要被 HitraceInvoker::TraceServerReceive 修改。关键调用点：ProcessTransaction() 直接使用 const_cast 修改 const 成员。", "consequences": "违反 const 正确性可能导致未定义行为或难以维护的代码", "suggestions": "建议修改为复制 flags 值而不是直接修改原始数据，或者重新设计数据结构避免需要修改 const 成员", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/dbinder/source/dbinder_databus_invoker.cpp", "line": 289, "evidence": "if (memcpy_s(invokerRawData->GetData().get(), rawDataSize, data + sizeof(dbinder_transaction_data),", "confidence": 0.6, "severity": "high", "gid": 3434, "verify": "invokerRawData->GetData() 返回的指针非空且足够大", "has_risk": true, "preconditions": "系统内存不足导致 new 操作失败，使 InvokerRawData::data_ 为 nullptr", "trigger_path": "调用路径推导：DBinderDatabusInvoker::OnRawDataAvailable() -> InvokerRawData::GetData()。数据流：从网络接收的原始数据通过 OnRawDataAvailable() 处理，创建 InvokerRawData 对象时若内存分配失败，GetData() 返回 nullptr。关键调用点：InvokerRawData::GetData() 未检查 data_ 是否为空。", "consequences": "空指针解引用，可能导致程序崩溃或拒绝服务", "suggestions": "1. 在 InvokerRawData::GetData() 中添加空指针检查；2. 在 memcpy_s 调用前检查 invokerRawData->GetData().get() 是否为 null", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/dbinder/source/dbinder_databus_invoker.cpp", "line": 578, "evidence": "std::string serviceName = sessionObject->GetServiceName();", "confidence": 0.6, "severity": "high", "gid": 3488, "verify": "sessionObject指针在调用方法前非空", "has_risk": true, "preconditions": "sessionObject 指针为空", "trigger_path": "调用路径推导：UpdateClientSession() 的调用者 -> UpdateClientSession()。数据流：sessionObject 作为参数直接传递给 UpdateClientSession() 函数。关键调用点：UpdateClientSession() 函数未对 sessionObject 进行空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在 UpdateClientSession() 函数开始处添加对 sessionObject 的空指针检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/dbinder/source/dbinder_databus_invoker.cpp", "line": 586, "evidence": "int32_t socketId = listener->CreateClientSocket(ownName, serviceName, sessionObject->GetDeviceId());", "confidence": 0.6, "severity": "high", "gid": 3489, "verify": "sessionObject指针在调用方法前非空", "has_risk": true, "preconditions": "sessionObject 指针为空", "trigger_path": "调用路径推导：UpdateClientSession() 的调用者 -> UpdateClientSession()。数据流：sessionObject 作为参数直接传递给 UpdateClientSession() 函数。关键调用点：UpdateClientSession() 函数未对 sessionObject 进行空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在 UpdateClientSession() 函数开始处添加对 sessionObject 的空指针检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/dbinder/source/dbinder_databus_invoker.cpp", "line": 586, "evidence": "int32_t socketId = listener->CreateClientSocket(ownName, serviceName, sessionObject->GetDeviceId());", "confidence": 0.6, "severity": "high", "gid": 3490, "verify": "sessionObject指针在调用方法前非空", "has_risk": true, "preconditions": "sessionObject 指针为空", "trigger_path": "调用路径推导：UpdateClientSession() 的调用者 -> UpdateClientSession()。数据流：sessionObject 作为参数直接传递给 UpdateClientSession() 函数。关键调用点：UpdateClientSession() 函数未对 sessionObject 进行空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在 UpdateClientSession() 函数开始处添加对 sessionObject 的空指针检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/dbinder/source/dbinder_databus_invoker.cpp", "line": 591, "evidence": "sessionObject->SetSocketId(socketId);", "confidence": 0.6, "severity": "high", "gid": 3491, "verify": "sessionObject指针在调用方法前非空", "has_risk": true, "preconditions": "sessionObject 指针为空", "trigger_path": "调用路径推导：UpdateClientSession() 的调用者 -> UpdateClientSession()。数据流：sessionObject 作为参数直接传递给 UpdateClientSession() 函数。关键调用点：UpdateClientSession() 函数未对 sessionObject 进行空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在 UpdateClientSession() 函数开始处添加对 sessionObject 的空指针检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/dbinder/source/dbinder_databus_invoker.cpp", "line": 592, "evidence": "sessionObject->SetPeerPid(peerPid);", "confidence": 0.6, "severity": "high", "gid": 3492, "verify": "sessionObject指针在调用方法前非空", "has_risk": true, "preconditions": "sessionObject 指针为空", "trigger_path": "调用路径推导：UpdateClientSession() 的调用者 -> UpdateClientSession()。数据流：sessionObject 作为参数直接传递给 UpdateClientSession() 函数。关键调用点：UpdateClientSession() 函数未对 sessionObject 进行空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在 UpdateClientSession() 函数开始处添加对 sessionObject 的空指针检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/dbinder/source/dbinder_databus_invoker.cpp", "line": 593, "evidence": "sessionObject->SetPeerUid(peerUid);", "confidence": 0.6, "severity": "high", "gid": 3493, "verify": "sessionObject指针在调用方法前非空", "has_risk": true, "preconditions": "sessionObject 指针为空", "trigger_path": "调用路径推导：UpdateClientSession() 的调用者 -> UpdateClientSession()。数据流：sessionObject 作为参数直接传递给 UpdateClientSession() 函数。关键调用点：UpdateClientSession() 函数未对 sessionObject 进行空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在 UpdateClientSession() 函数开始处添加对 sessionObject 的空指针检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "ipc/native/src/core/dbinder/source/dbinder_databus_invoker.cpp", "line": 597, "evidence": "IPCProcessSkeleton::ConvertToSecureString(sessionObject->GetDeviceId()).c_str(),", "confidence": 0.6, "severity": "high", "gid": 3494, "verify": "sessionObject指针在调用方法前非空", "has_risk": true, "preconditions": "sessionObject 指针为空", "trigger_path": "调用路径推导：UpdateClientSession() 的调用者 -> UpdateClientSession()。数据流：sessionObject 作为参数直接传递给 UpdateClientSession() 函数。关键调用点：UpdateClientSession() 函数未对 sessionObject 进行空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在 UpdateClientSession() 函数开始处添加对 sessionObject 的空指针检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "missing_virtual_dtor", "file": "interfaces/innerkits/ipc_core/include/iremote_object.h", "line": 48, "evidence": "class DeathRecipient : public virtual RefBase {", "confidence": 0.75, "severity": "high", "gid": 3589, "verify": "验证候选 3589 的安全风险", "has_risk": true, "preconditions": "存在派生类继承自DeathRecipient并通过基类指针进行删除操作", "trigger_path": "调用路径推导：IRemoteObject::AddDeathRecipient() -> 存储sptr<DeathRecipient> -> IRemoteObject::RemoveDeathRecipient() -> 删除DeathRecipient对象。数据流：DeathRecipient对象通过智能指针管理生命周期，在删除时通过基类指针操作。关键调用点：删除操作时未调用派生类的析构函数。", "consequences": "派生类资源泄漏或未定义行为", "suggestions": "在DeathRecipient类中添加虚析构函数声明：virtual ~DeathRecipient() = default;", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 534, "evidence": "*errCode = rpc->CJ_WriteRawDataBuffer(data, size);", "confidence": 0.6, "severity": "high", "gid": 3699, "verify": "data指针在解引用前非空", "has_risk": true, "preconditions": "调用者传入nullptr作为data参数或负值/过大值作为size参数", "trigger_path": "调用路径推导：外部调用 -> FfiRpcMessageSequenceImplWriteRawDataBuffer() -> CJ_WriteRawDataBuffer()。数据流：外部调用传入的data和size参数直接传递给CJ_WriteRawDataBuffer()。关键调用点：FfiRpcMessageSequenceImplWriteRawDataBuffer()函数未对data指针进行空指针检查，也未对size参数进行边界检查。", "consequences": "空指针解引用可能导致程序崩溃，无效的size参数可能导致缓冲区溢出", "suggestions": "1. 在FfiRpcMessageSequenceImplWriteRawDataBuffer()中添加data指针的非空检查；2. 添加size参数的边界检查；3. 考虑添加错误码返回机制", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 534, "evidence": "*errCode = rpc->CJ_WriteRawDataBuffer(data, size);", "confidence": 0.6, "severity": "high", "gid": 3700, "verify": "data指针在解引用前非空", "has_risk": true, "preconditions": "调用者传入nullptr作为data参数或负值/过大值作为size参数", "trigger_path": "调用路径推导：外部调用 -> FfiRpcMessageSequenceImplWriteRawDataBuffer() -> CJ_WriteRawDataBuffer()。数据流：外部调用传入的data和size参数直接传递给CJ_WriteRawDataBuffer()。关键调用点：FfiRpcMessageSequenceImplWriteRawDataBuffer()函数未对data指针进行空指针检查，也未对size参数进行边界检查。", "consequences": "空指针解引用可能导致程序崩溃，无效的size参数可能导致缓冲区溢出", "suggestions": "1. 在FfiRpcMessageSequenceImplWriteRawDataBuffer()中添加data指针的非空检查；2. 添加size参数的边界检查；3. 考虑添加错误码返回机制", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 823, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3747, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 830, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3748, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 843, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3749, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 846, "evidence": "std::vector<uint8_t> vector = rpc->CJ_ReadUInt8ArrayBuffer(errCode);", "confidence": 0.6, "severity": "high", "gid": 3750, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 854, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3751, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 861, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3752, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 874, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3753, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 877, "evidence": "std::vector<int16_t> vector = rpc->CJ_ReadInt16ArrayBuffer(errCode);", "confidence": 0.6, "severity": "high", "gid": 3754, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 885, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3755, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 892, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3756, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 905, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3757, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 908, "evidence": "std::vector<uint16_t> vector = rpc->CJ_ReadUInt16ArrayBuffer(errCode);", "confidence": 0.6, "severity": "high", "gid": 3758, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 916, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3759, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 923, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3760, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 936, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3761, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 939, "evidence": "std::vector<int32_t> vector = rpc->CJ_ReadInt32ArrayBuffer(errCode);", "confidence": 0.6, "severity": "high", "gid": 3762, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 947, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3763, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 954, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3764, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 967, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3765, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 970, "evidence": "std::vector<uint32_t> vector = rpc->CJ_ReadUInt32ArrayBuffer(errCode);", "confidence": 0.6, "severity": "high", "gid": 3766, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 978, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3767, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 985, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3768, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 998, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3769, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1001, "evidence": "std::vector<float> vector = rpc->CJ_ReadFloatArrayBuffer(errCode);", "confidence": 0.6, "severity": "high", "gid": 3770, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1009, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3771, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1016, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3772, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1029, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3773, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1032, "evidence": "std::vector<double> vector = rpc->CJ_ReadDoubleArrayBuffer(errCode);", "confidence": 0.6, "severity": "high", "gid": 3774, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1040, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3775, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1047, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3776, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1059, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3777, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1062, "evidence": "std::vector<int64_t> vector = rpc->CJ_ReadInt64ArrayBuffer(errCode);", "confidence": 0.6, "severity": "high", "gid": 3778, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1070, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3779, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1077, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3780, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1090, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3781, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1093, "evidence": "std::vector<uint64_t> vector = rpc->CJ_ReadUInt64ArrayBuffer(errCode);", "confidence": 0.6, "severity": "high", "gid": 3782, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1101, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3783, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1108, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3784, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1121, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3785, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1125, "evidence": "return rpc->CJ_ReadRawDataBuffer(size, errCode);", "confidence": 0.6, "severity": "high", "gid": 3786, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1135, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3787, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1139, "evidence": "return rpc->CJ_ReadRemoteObject(errCode);", "confidence": 0.6, "severity": "high", "gid": 3788, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1148, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3789, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1152, "evidence": "return rpc->CJ_ReadRemoteObjectArray(errCode);", "confidence": 0.6, "severity": "high", "gid": 3790, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1171, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3791, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1175, "evidence": "return rpc->CJ_ContainFileDescriptors(errCode);", "confidence": 0.6, "severity": "high", "gid": 3792, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1184, "evidence": "*errCode = errorDesc::WRITE_DATA_TO_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3793, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1188, "evidence": "*errCode = rpc->CJ_WriteFileDescriptor(fd);", "confidence": 0.6, "severity": "high", "gid": 3794, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1188, "evidence": "*errCode = rpc->CJ_WriteFileDescriptor(fd);", "confidence": 0.6, "severity": "high", "gid": 3795, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1197, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3796, "verify": "验证errCode指针在解引用前非空", "has_risk": true, "preconditions": "外部调用者传入 null 指针作为 errCode 参数", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcMessageSequenceImpl* 函数。数据流：errCode 参数直接由外部调用者传入，函数内部未进行 null 检查即解引用。关键调用点：所有 FfiRpcMessageSequenceImpl* 函数均未对 errCode 参数进行 null 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 FfiRpcMessageSequenceImpl* 函数中添加对 errCode 参数的 null 检查，或在函数文档中明确要求调用者必须传入有效指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1210, "evidence": "*errCode = errorDesc::WRITE_DATA_TO_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3798, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "外部调用者传入NULL指针作为errCode参数", "trigger_path": "调用路径推导：外部调用者（如JavaScript/Node.js通过FFI）-> FfiRpc*系列函数。数据流：errCode指针由外部调用者直接传入，在FfiRpc*系列函数中被直接解引用而未进行NULL检查。关键调用点：所有FfiRpc*系列函数均未对errCode参数进行NULL检查。", "consequences": "空指针解引用，导致程序崩溃或未定义行为", "suggestions": "在所有FfiRpc*系列函数中对errCode参数进行NULL检查，在NULL时返回错误或使用默认错误码", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1216, "evidence": "*errCode = errorDesc::WRITE_DATA_TO_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3800, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "外部调用者传入NULL指针作为errCode参数", "trigger_path": "调用路径推导：外部调用者（如JavaScript/Node.js通过FFI）-> FfiRpc*系列函数。数据流：errCode指针由外部调用者直接传入，在FfiRpc*系列函数中被直接解引用而未进行NULL检查。关键调用点：所有FfiRpc*系列函数均未对errCode参数进行NULL检查。", "consequences": "空指针解引用，导致程序崩溃或未定义行为", "suggestions": "在所有FfiRpc*系列函数中对errCode参数进行NULL检查，在NULL时返回错误或使用默认错误码", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1229, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3804, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "外部调用者传入NULL指针作为errCode参数", "trigger_path": "调用路径推导：外部调用者（如JavaScript/Node.js通过FFI）-> FfiRpc*系列函数。数据流：errCode指针由外部调用者直接传入，在FfiRpc*系列函数中被直接解引用而未进行NULL检查。关键调用点：所有FfiRpc*系列函数均未对errCode参数进行NULL检查。", "consequences": "空指针解引用，导致程序崩溃或未定义行为", "suggestions": "在所有FfiRpc*系列函数中对errCode参数进行NULL检查，在NULL时返回错误或使用默认错误码", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1233, "evidence": "if (*errCode != 0) {", "confidence": 0.6, "severity": "high", "gid": 3806, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "外部调用者传入NULL指针作为errCode参数", "trigger_path": "调用路径推导：外部调用者（如JavaScript/Node.js通过FFI）-> FfiRpc*系列函数。数据流：errCode指针由外部调用者直接传入，在FfiRpc*系列函数中被直接解引用而未进行NULL检查。关键调用点：所有FfiRpc*系列函数均未对errCode参数进行NULL检查。", "consequences": "空指针解引用，导致程序崩溃或未定义行为", "suggestions": "在所有FfiRpc*系列函数中对errCode参数进行NULL检查，在NULL时返回错误或使用默认错误码", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1239, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3807, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "外部调用者传入NULL指针作为errCode参数", "trigger_path": "调用路径推导：外部调用者（如JavaScript/Node.js通过FFI）-> FfiRpc*系列函数。数据流：errCode指针由外部调用者直接传入，在FfiRpc*系列函数中被直接解引用而未进行NULL检查。关键调用点：所有FfiRpc*系列函数均未对errCode参数进行NULL检查。", "consequences": "空指针解引用，导致程序崩溃或未定义行为", "suggestions": "在所有FfiRpc*系列函数中对errCode参数进行NULL检查，在NULL时返回错误或使用默认错误码", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1252, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3809, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "外部调用者传入NULL指针作为errCode参数", "trigger_path": "调用路径推导：外部调用者（如JavaScript/Node.js通过FFI）-> FfiRpc*系列函数。数据流：errCode指针由外部调用者直接传入，在FfiRpc*系列函数中被直接解引用而未进行NULL检查。关键调用点：所有FfiRpc*系列函数均未对errCode参数进行NULL检查。", "consequences": "空指针解引用，导致程序崩溃或未定义行为", "suggestions": "在所有FfiRpc*系列函数中对errCode参数进行NULL检查，在NULL时返回错误或使用默认错误码", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1282, "evidence": "*errCode = errorDesc::CHECK_PARAM_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3812, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "外部调用者传入NULL指针作为errCode参数", "trigger_path": "调用路径推导：外部调用者（如JavaScript/Node.js通过FFI）-> FfiRpc*系列函数。数据流：errCode指针由外部调用者直接传入，在FfiRpc*系列函数中被直接解引用而未进行NULL检查。关键调用点：所有FfiRpc*系列函数均未对errCode参数进行NULL检查。", "consequences": "空指针解引用，导致程序崩溃或未定义行为", "suggestions": "在所有FfiRpc*系列函数中对errCode参数进行NULL检查，在NULL时返回错误或使用默认错误码", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1289, "evidence": "*errCode = errorDesc::CHECK_PARAM_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3815, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "外部调用者传入NULL指针作为errCode参数", "trigger_path": "调用路径推导：外部调用者（如JavaScript/Node.js通过FFI）-> FfiRpc*系列函数。数据流：errCode指针由外部调用者直接传入，在FfiRpc*系列函数中被直接解引用而未进行NULL检查。关键调用点：所有FfiRpc*系列函数均未对errCode参数进行NULL检查。", "consequences": "空指针解引用，导致程序崩溃或未定义行为", "suggestions": "在所有FfiRpc*系列函数中对errCode参数进行NULL检查，在NULL时返回错误或使用默认错误码", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1295, "evidence": "*errCode = errorDesc::CHECK_PARAM_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3816, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "外部调用者传入NULL指针作为errCode参数", "trigger_path": "调用路径推导：外部调用者（如JavaScript/Node.js通过FFI）-> FfiRpc*系列函数。数据流：errCode指针由外部调用者直接传入，在FfiRpc*系列函数中被直接解引用而未进行NULL检查。关键调用点：所有FfiRpc*系列函数均未对errCode参数进行NULL检查。", "consequences": "空指针解引用，导致程序崩溃或未定义行为", "suggestions": "在所有FfiRpc*系列函数中对errCode参数进行NULL检查，在NULL时返回错误或使用默认错误码", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1302, "evidence": "*errCode = errorDesc::CHECK_PARAM_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3817, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "外部调用者传入NULL指针作为errCode参数", "trigger_path": "调用路径推导：外部调用者（如JavaScript/Node.js通过FFI）-> FfiRpc*系列函数。数据流：errCode指针由外部调用者直接传入，在FfiRpc*系列函数中被直接解引用而未进行NULL检查。关键调用点：所有FfiRpc*系列函数均未对errCode参数进行NULL检查。", "consequences": "空指针解引用，导致程序崩溃或未定义行为", "suggestions": "在所有FfiRpc*系列函数中对errCode参数进行NULL检查，在NULL时返回错误或使用默认错误码", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1308, "evidence": "*errCode = errorDesc::CHECK_PARAM_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3818, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "外部调用者传入NULL指针作为errCode参数", "trigger_path": "调用路径推导：外部调用者（如JavaScript/Node.js通过FFI）-> FfiRpc*系列函数。数据流：errCode指针由外部调用者直接传入，在FfiRpc*系列函数中被直接解引用而未进行NULL检查。关键调用点：所有FfiRpc*系列函数均未对errCode参数进行NULL检查。", "consequences": "空指针解引用，导致程序崩溃或未定义行为", "suggestions": "在所有FfiRpc*系列函数中对errCode参数进行NULL检查，在NULL时返回错误或使用默认错误码", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1345, "evidence": "*errCode = errorDesc::CHECK_PARAM_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3822, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "外部调用者传入NULL指针作为errCode参数", "trigger_path": "调用路径推导：外部调用者（如JavaScript/Node.js通过FFI）-> FfiRpc*系列函数。数据流：errCode指针由外部调用者直接传入，在FfiRpc*系列函数中被直接解引用而未进行NULL检查。关键调用点：所有FfiRpc*系列函数均未对errCode参数进行NULL检查。", "consequences": "空指针解引用，导致程序崩溃或未定义行为", "suggestions": "在所有FfiRpc*系列函数中对errCode参数进行NULL检查，在NULL时返回错误或使用默认错误码", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1358, "evidence": "*errCode = errorDesc::OS_MMAP_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3824, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "外部调用者传入NULL指针作为errCode参数", "trigger_path": "调用路径推导：外部调用者（如JavaScript/Node.js通过FFI）-> FfiRpc*系列函数。数据流：errCode指针由外部调用者直接传入，在FfiRpc*系列函数中被直接解引用而未进行NULL检查。关键调用点：所有FfiRpc*系列函数均未对errCode参数进行NULL检查。", "consequences": "空指针解引用，导致程序崩溃或未定义行为", "suggestions": "在所有FfiRpc*系列函数中对errCode参数进行NULL检查，在NULL时返回错误或使用默认错误码", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1371, "evidence": "*errCode = errorDesc::OS_MMAP_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3827, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "外部调用者传入NULL指针作为errCode参数", "trigger_path": "调用路径推导：外部调用者（如JavaScript/Node.js通过FFI）-> FfiRpc*系列函数。数据流：errCode指针由外部调用者直接传入，在FfiRpc*系列函数中被直接解引用而未进行NULL检查。关键调用点：所有FfiRpc*系列函数均未对errCode参数进行NULL检查。", "consequences": "空指针解引用，导致程序崩溃或未定义行为", "suggestions": "在所有FfiRpc*系列函数中对errCode参数进行NULL检查，在NULL时返回错误或使用默认错误码", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1384, "evidence": "*errCode = errorDesc::OS_MMAP_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3830, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "外部调用者传入NULL指针作为errCode参数", "trigger_path": "调用路径推导：外部调用者（如JavaScript/Node.js通过FFI）-> FfiRpc*系列函数。数据流：errCode指针由外部调用者直接传入，在FfiRpc*系列函数中被直接解引用而未进行NULL检查。关键调用点：所有FfiRpc*系列函数均未对errCode参数进行NULL检查。", "consequences": "空指针解引用，导致程序崩溃或未定义行为", "suggestions": "在所有FfiRpc*系列函数中对errCode参数进行NULL检查，在NULL时返回错误或使用默认错误码", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1397, "evidence": "*errCode = errorDesc::OS_IOCTL_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3833, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "外部调用者传入NULL指针作为errCode参数", "trigger_path": "调用路径推导：外部调用者（如JavaScript/Node.js通过FFI）-> FfiRpc*系列函数。数据流：errCode指针由外部调用者直接传入，在FfiRpc*系列函数中被直接解引用而未进行NULL检查。关键调用点：所有FfiRpc*系列函数均未对errCode参数进行NULL检查。", "consequences": "空指针解引用，导致程序崩溃或未定义行为", "suggestions": "在所有FfiRpc*系列函数中对errCode参数进行NULL检查，在NULL时返回错误或使用默认错误码", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1410, "evidence": "*errCode = errorDesc::WRITE_TO_ASHMEM_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3836, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "外部调用者传入NULL指针作为errCode参数", "trigger_path": "调用路径推导：外部调用者（如JavaScript/Node.js通过FFI）-> FfiRpc*系列函数。数据流：errCode指针由外部调用者直接传入，在FfiRpc*系列函数中被直接解引用而未进行NULL检查。关键调用点：所有FfiRpc*系列函数均未对errCode参数进行NULL检查。", "consequences": "空指针解引用，导致程序崩溃或未定义行为", "suggestions": "在所有FfiRpc*系列函数中对errCode参数进行NULL检查，在NULL时返回错误或使用默认错误码", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1423, "evidence": "*errCode = errorDesc::READ_FROM_ASHMEM_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3839, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "外部调用者传入NULL指针作为errCode参数", "trigger_path": "调用路径推导：外部调用者（如JavaScript/Node.js通过FFI）-> FfiRpc*系列函数。数据流：errCode指针由外部调用者直接传入，在FfiRpc*系列函数中被直接解引用而未进行NULL检查。关键调用点：所有FfiRpc*系列函数均未对errCode参数进行NULL检查。", "consequences": "空指针解引用，导致程序崩溃或未定义行为", "suggestions": "在所有FfiRpc*系列函数中对errCode参数进行NULL检查，在NULL时返回错误或使用默认错误码", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1483, "evidence": "*errCode = errorDesc::PROXY_OR_REMOTE_OBJECT_INVALID_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3843, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "外部调用者传入NULL指针作为errCode参数", "trigger_path": "调用路径推导：外部调用者（如JavaScript/Node.js通过FFI）-> FfiRpc*系列函数。数据流：errCode指针由外部调用者直接传入，在FfiRpc*系列函数中被直接解引用而未进行NULL检查。关键调用点：所有FfiRpc*系列函数均未对errCode参数进行NULL检查。", "consequences": "空指针解引用，导致程序崩溃或未定义行为", "suggestions": "在所有FfiRpc*系列函数中对errCode参数进行NULL检查，在NULL时返回错误或使用默认错误码", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1496, "evidence": "*errCode = errorDesc::PROXY_OR_REMOTE_OBJECT_INVALID_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3845, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "外部调用者传入NULL指针作为errCode参数", "trigger_path": "调用路径推导：外部调用者（如JavaScript/Node.js通过FFI）-> FfiRpc*系列函数。数据流：errCode指针由外部调用者直接传入，在FfiRpc*系列函数中被直接解引用而未进行NULL检查。关键调用点：所有FfiRpc*系列函数均未对errCode参数进行NULL检查。", "consequences": "空指针解引用，导致程序崩溃或未定义行为", "suggestions": "在所有FfiRpc*系列函数中对errCode参数进行NULL检查，在NULL时返回错误或使用默认错误码", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1563, "evidence": "*errCode = errorDesc::PROXY_OR_REMOTE_OBJECT_INVALID_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3849, "verify": "验证errCode指针在使用前非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为NULL", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcRemoteProxyRegisterDeathRecipient/FfiRpcRemoteProxyUnregisterDeathRecipient/FfiRpcRemoteProxyGetDescriptor。数据流：外部调用者直接传入errCode指针，这些FFI导出函数未对指针进行空指针检查就直接解引用。关键调用点：所有三个函数都未对errCode参数进行空指针校验。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在函数入口处添加errCode指针的非空检查，例如：if (errCode == nullptr) { return; }", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1576, "evidence": "*errCode = errorDesc::PROXY_OR_REMOTE_OBJECT_INVALID_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3852, "verify": "验证errCode指针在使用前非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为NULL", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcRemoteProxyRegisterDeathRecipient/FfiRpcRemoteProxyUnregisterDeathRecipient/FfiRpcRemoteProxyGetDescriptor。数据流：外部调用者直接传入errCode指针，这些FFI导出函数未对指针进行空指针检查就直接解引用。关键调用点：所有三个函数都未对errCode参数进行空指针校验。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在函数入口处添加errCode指针的非空检查，例如：if (errCode == nullptr) { return; }", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/ipc_ffi.cpp", "line": 1589, "evidence": "*errCode = errorDesc::PROXY_OR_REMOTE_OBJECT_INVALID_ERROR;", "confidence": 0.6, "severity": "high", "gid": 3855, "verify": "验证errCode指针在使用前非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为NULL", "trigger_path": "调用路径推导：外部调用者 -> FfiRpcRemoteProxyRegisterDeathRecipient/FfiRpcRemoteProxyUnregisterDeathRecipient/FfiRpcRemoteProxyGetDescriptor。数据流：外部调用者直接传入errCode指针，这些FFI导出函数未对指针进行空指针检查就直接解引用。关键调用点：所有三个函数都未对errCode参数进行空指针校验。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在函数入口处添加errCode指针的非空检查，例如：if (errCode == nullptr) { return; }", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "type_safety", "pattern": "reinterpret_cast_unsafe", "file": "interfaces/innerkits/cj/src/remote_proxy_impl.cpp", "line": 40, "evidence": "auto func = reinterpret_cast<void (*)()>(funcId_);", "confidence": 0.7999999999999999, "severity": "high", "gid": 3887, "verify": "验证reinterpret_cast的使用是否安全", "has_risk": true, "preconditions": "外部传入的funcId参数被当作函数指针使用", "trigger_path": "调用路径推导：FfiRpcRemoteObjectSendMessageRequest() -> RegisterDeathRecipient() -> new CJDeathRecipient(funcId) -> OnRemoteDied()。数据流：外部FFI调用传入funcId，通过RegisterDeathRecipient传递给CJDeathRecipient构造函数存储，在OnRemoteDied回调时直接转换为函数指针调用。关键调用点：所有调用路径均未对funcId进行有效性验证。", "consequences": "可能导致任意代码执行，攻击者可以控制程序执行流", "suggestions": "1. 验证funcId是否为有效的函数地址 2. 使用函数注册表机制替代直接转换 3. 添加边界检查确保指针转换安全", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "type_safety", "pattern": "reinterpret_cast_unsafe", "file": "interfaces/innerkits/cj/src/remote_proxy_impl.cpp", "line": 111, "evidence": "auto callback = CJLambda::Create(reinterpret_cast<void (*)(RequestResult)>(funcId));", "confidence": 0.7999999999999999, "severity": "high", "gid": 3888, "verify": "验证reinterpret_cast的使用是否安全", "has_risk": true, "preconditions": "外部传入的funcId参数被当作函数指针使用", "trigger_path": "调用路径推导：FfiRpcRemoteProxySendMessageRequest() -> SendMessageRequest()。数据流：外部FFI调用传入funcId，在SendMessageRequest中直接转换为函数指针调用。关键调用点：所有调用路径均未对funcId进行有效性验证。", "consequences": "可能导致任意代码执行，攻击者可以控制程序执行流", "suggestions": "1. 验证funcId是否为有效的函数地址 2. 使用函数注册表机制替代直接转换 3. 添加边界检查确保指针转换安全", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "type_safety", "pattern": "reinterpret_cast_unsafe", "file": "interfaces/innerkits/cj/src/remote_object_impl.cpp", "line": 110, "evidence": "auto callback = CJLambda::Create(reinterpret_cast<void (*)(RequestResult)>(param->callback));", "confidence": 0.7999999999999999, "severity": "high", "gid": 3945, "verify": "检查类型转换是否安全，是否有足够的类型保证", "has_risk": true, "preconditions": "传入的param->callback不是一个有效的函数指针", "trigger_path": "调用路径推导：SendMessageRequest() -> StubExecuteSendRequest()。数据流：外部传入的funcId作为param->callback，未经类型验证直接转换为函数指针。关键调用点：StubExecuteSendRequest()函数未对函数指针的有效性进行验证。", "consequences": "可能导致程序崩溃或任意代码执行", "suggestions": "使用类型安全的回调机制，或至少验证函数指针是否在有效范围内", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "type_safety", "pattern": "reinterpret_cast_unsafe", "file": "interfaces/innerkits/cj/src/remote_object_impl.cpp", "line": 264, "evidence": "auto remoteObject = reinterpret_cast<sptr<IRemoteObject>*>(param);", "confidence": 0.7999999999999999, "severity": "high", "gid": 3946, "verify": "检查类型转换是否安全，是否有足够的类型保证", "has_risk": true, "preconditions": "传入的param指针不是有效的sptr<IRemoteObject>*类型", "trigger_path": "调用路径推导：外部调用 -> OHOS_CallCreateRemoteObject()/OHOS_CallGetNativeRemoteObject()。数据流：外部传入的void*参数未经类型验证直接转换为智能指针指针。关键调用点：两个函数虽然检查了nullptr，但未验证类型安全性。", "consequences": "可能导致类型混淆、内存访问错误或程序崩溃", "suggestions": "使用类型安全的接口设计，避免使用void*参数，或增加类型验证机制", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "type_safety", "pattern": "reinterpret_cast_unsafe", "file": "interfaces/innerkits/cj/src/remote_object_impl.cpp", "line": 277, "evidence": "auto remoteObject = reinterpret_cast<sptr<IRemoteObject>*>(param);", "confidence": 0.7999999999999999, "severity": "high", "gid": 3947, "verify": "检查类型转换是否安全，是否有足够的类型保证", "has_risk": true, "preconditions": "传入的param指针不是有效的sptr<IRemoteObject>*类型", "trigger_path": "调用路径推导：外部调用 -> OHOS_CallCreateRemoteObject()/OHOS_CallGetNativeRemoteObject()。数据流：外部传入的void*参数未经类型验证直接转换为智能指针指针。关键调用点：两个函数虽然检查了nullptr，但未验证类型安全性。", "consequences": "可能导致类型混淆、内存访问错误或程序崩溃", "suggestions": "使用类型安全的接口设计，避免使用void*参数，或增加类型验证机制", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "error_handling", "pattern": "io_call", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1232, "evidence": "close(fd);", "confidence": 0.65, "severity": "medium", "gid": 3948, "verify": "验证fd是否有效且未被重复关闭", "has_risk": true, "preconditions": "调用者传入无效或已关闭的文件描述符", "trigger_path": "调用路径推导：外部调用 -> FfiRpcMessageSequenceImplCloseFileDescriptor() -> MessageSequenceImpl::CJ_CloseFileDescriptor() -> close(fd)。数据流：文件描述符通过FFI接口传入，直接传递给close系统调用。关键调用点：FfiRpcMessageSequenceImplCloseFileDescriptor()未对fd有效性进行检查，MessageSequenceImpl::CJ_CloseFileDescriptor()直接调用close()无校验。", "consequences": "可能导致EBADF错误或重复关闭已关闭的文件描述符，影响系统稳定性", "suggestions": "1) 在关闭前检查fd有效性；2) 添加错误处理；3) 考虑使用RAII模式管理文件描述符生命周期", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 779, "evidence": "if (nativeParcel_->GetDataSize() < nativeParcel_->GetReadPosition()) {", "confidence": 0.6, "severity": "high", "gid": 4057, "verify": "nativeParcel_ pointer is not null before dereference", "has_risk": true, "preconditions": "nativeParcel_指针为null", "trigger_path": "调用路径推导：CheckReadPosition()和CheckReadLength()函数被其他读取函数调用时，未对nativeParcel_指针进行null检查。数据流：nativeParcel_指针通过构造函数或初始化函数设置，在CheckReadPosition()和CheckReadLength()中被直接解引用。关键调用点：CheckReadPosition()和CheckReadLength()函数未对nativeParcel_指针进行null检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在CheckReadPosition()和CheckReadLength()函数开始处添加对nativeParcel_指针的null检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 781, "evidence": "maxCapacityToWrite_, nativeParcel_->GetWritePosition());", "confidence": 0.6, "severity": "high", "gid": 4058, "verify": "nativeParcel_ pointer is not null before dereference", "has_risk": true, "preconditions": "nativeParcel_指针为null", "trigger_path": "调用路径推导：CheckReadPosition()和CheckReadLength()函数被其他读取函数调用时，未对nativeParcel_指针进行null检查。数据流：nativeParcel_指针通过构造函数或初始化函数设置，在CheckReadPosition()和CheckReadLength()中被直接解引用。关键调用点：CheckReadPosition()和CheckReadLength()函数未对nativeParcel_指针进行null检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在CheckReadPosition()和CheckReadLength()函数开始处添加对nativeParcel_指针的null检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 790, "evidence": "size_t remainSize = nativeParcel_->GetDataSize() - nativeParcel_->GetReadPosition();", "confidence": 0.6, "severity": "high", "gid": 4059, "verify": "nativeParcel_ pointer is not null before dereference", "has_risk": true, "preconditions": "nativeParcel_指针为null", "trigger_path": "调用路径推导：CheckReadPosition()和CheckReadLength()函数被其他读取函数调用时，未对nativeParcel_指针进行null检查。数据流：nativeParcel_指针通过构造函数或初始化函数设置，在CheckReadPosition()和CheckReadLength()中被直接解引用。关键调用点：CheckReadPosition()和CheckReadLength()函数未对nativeParcel_指针进行null检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在CheckReadPosition()和CheckReadLength()函数开始处添加对nativeParcel_指针的null检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 795, "evidence": "arrayLength, remainSize, typeSize, nativeParcel_->GetDataSize(), nativeParcel_->GetReadPosition());", "confidence": 0.6, "severity": "high", "gid": 4060, "verify": "nativeParcel_ pointer is not null before dereference", "has_risk": true, "preconditions": "nativeParcel_指针为null", "trigger_path": "调用路径推导：CheckReadPosition()和CheckReadLength()函数被其他读取函数调用时，未对nativeParcel_指针进行null检查。数据流：nativeParcel_指针通过构造函数或初始化函数设置，在CheckReadPosition()和CheckReadLength()中被直接解引用。关键调用点：CheckReadPosition()和CheckReadLength()函数未对nativeParcel_指针进行null检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在CheckReadPosition()和CheckReadLength()函数开始处添加对nativeParcel_指针的null检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 744, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4049, "verify": "errCode pointer is not null before dereference", "has_risk": true, "preconditions": "调用者传入的 errCode 指针为 null", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl 的各种 Read* 方法（如 CJ_ReadByte/CJ_ReadShort 等）。数据流：errCode 参数由外部调用者直接传入，在 MessageSequenceImpl 的各种 Read* 方法中未进行判空检查即直接解引用。关键调用点：所有 Read* 方法均未对 errCode 参数进行判空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 Read* 方法中添加对 errCode 参数的判空检查，或者在方法文档中明确要求调用者必须传入有效的指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 753, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4051, "verify": "errCode pointer is not null before dereference", "has_risk": true, "preconditions": "调用者传入的 errCode 指针为 null", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl 的各种 Read* 方法（如 CJ_ReadByte/CJ_ReadShort 等）。数据流：errCode 参数由外部调用者直接传入，在 MessageSequenceImpl 的各种 Read* 方法中未进行判空检查即直接解引用。关键调用点：所有 Read* 方法均未对 errCode 参数进行判空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 Read* 方法中添加对 errCode 参数的判空检查，或者在方法文档中明确要求调用者必须传入有效的指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 762, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4053, "verify": "errCode pointer is not null before dereference", "has_risk": true, "preconditions": "调用者传入的 errCode 指针为 null", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl 的各种 Read* 方法（如 CJ_ReadByte/CJ_ReadShort 等）。数据流：errCode 参数由外部调用者直接传入，在 MessageSequenceImpl 的各种 Read* 方法中未进行判空检查即直接解引用。关键调用点：所有 Read* 方法均未对 errCode 参数进行判空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 Read* 方法中添加对 errCode 参数的判空检查，或者在方法文档中明确要求调用者必须传入有效的指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 771, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4055, "verify": "errCode pointer is not null before dereference", "has_risk": true, "preconditions": "调用者传入的 errCode 指针为 null", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl 的各种 Read* 方法（如 CJ_ReadByte/CJ_ReadShort 等）。数据流：errCode 参数由外部调用者直接传入，在 MessageSequenceImpl 的各种 Read* 方法中未进行判空检查即直接解引用。关键调用点：所有 Read* 方法均未对 errCode 参数进行判空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 Read* 方法中添加对 errCode 参数的判空检查，或者在方法文档中明确要求调用者必须传入有效的指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 807, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4061, "verify": "errCode pointer is not null before dereference", "has_risk": true, "preconditions": "调用者传入的 errCode 指针为 null", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl 的各种 Read* 方法（如 CJ_ReadByte/CJ_ReadShort 等）。数据流：errCode 参数由外部调用者直接传入，在 MessageSequenceImpl 的各种 Read* 方法中未进行判空检查即直接解引用。关键调用点：所有 Read* 方法均未对 errCode 参数进行判空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 Read* 方法中添加对 errCode 参数的判空检查，或者在方法文档中明确要求调用者必须传入有效的指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 817, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4063, "verify": "errCode pointer is not null before dereference", "has_risk": true, "preconditions": "调用者传入的 errCode 指针为 null", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl 的各种 Read* 方法（如 CJ_ReadByte/CJ_ReadShort 等）。数据流：errCode 参数由外部调用者直接传入，在 MessageSequenceImpl 的各种 Read* 方法中未进行判空检查即直接解引用。关键调用点：所有 Read* 方法均未对 errCode 参数进行判空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 Read* 方法中添加对 errCode 参数的判空检查，或者在方法文档中明确要求调用者必须传入有效的指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 825, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4065, "verify": "errCode pointer is not null before dereference", "has_risk": true, "preconditions": "调用者传入的 errCode 指针为 null", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl 的各种 Read* 方法（如 CJ_ReadByte/CJ_ReadShort 等）。数据流：errCode 参数由外部调用者直接传入，在 MessageSequenceImpl 的各种 Read* 方法中未进行判空检查即直接解引用。关键调用点：所有 Read* 方法均未对 errCode 参数进行判空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 Read* 方法中添加对 errCode 参数的判空检查，或者在方法文档中明确要求调用者必须传入有效的指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 833, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4066, "verify": "errCode pointer is not null before dereference", "has_risk": true, "preconditions": "调用者传入的 errCode 指针为 null", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl 的各种 Read* 方法（如 CJ_ReadByte/CJ_ReadShort 等）。数据流：errCode 参数由外部调用者直接传入，在 MessageSequenceImpl 的各种 Read* 方法中未进行判空检查即直接解引用。关键调用点：所有 Read* 方法均未对 errCode 参数进行判空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 Read* 方法中添加对 errCode 参数的判空检查，或者在方法文档中明确要求调用者必须传入有效的指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 843, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4068, "verify": "errCode pointer is not null before dereference", "has_risk": true, "preconditions": "调用者传入的 errCode 指针为 null", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl 的各种 Read* 方法（如 CJ_ReadByte/CJ_ReadShort 等）。数据流：errCode 参数由外部调用者直接传入，在 MessageSequenceImpl 的各种 Read* 方法中未进行判空检查即直接解引用。关键调用点：所有 Read* 方法均未对 errCode 参数进行判空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 Read* 方法中添加对 errCode 参数的判空检查，或者在方法文档中明确要求调用者必须传入有效的指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 851, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4070, "verify": "errCode pointer is not null before dereference", "has_risk": true, "preconditions": "调用者传入的 errCode 指针为 null", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl 的各种 Read* 方法（如 CJ_ReadByte/CJ_ReadShort 等）。数据流：errCode 参数由外部调用者直接传入，在 MessageSequenceImpl 的各种 Read* 方法中未进行判空检查即直接解引用。关键调用点：所有 Read* 方法均未对 errCode 参数进行判空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 Read* 方法中添加对 errCode 参数的判空检查，或者在方法文档中明确要求调用者必须传入有效的指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 859, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4071, "verify": "errCode pointer is not null before dereference", "has_risk": true, "preconditions": "调用者传入的 errCode 指针为 null", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl 的各种 Read* 方法（如 CJ_ReadByte/CJ_ReadShort 等）。数据流：errCode 参数由外部调用者直接传入，在 MessageSequenceImpl 的各种 Read* 方法中未进行判空检查即直接解引用。关键调用点：所有 Read* 方法均未对 errCode 参数进行判空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 Read* 方法中添加对 errCode 参数的判空检查，或者在方法文档中明确要求调用者必须传入有效的指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 869, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4073, "verify": "errCode pointer is not null before dereference", "has_risk": true, "preconditions": "调用者传入的 errCode 指针为 null", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl 的各种 Read* 方法（如 CJ_ReadByte/CJ_ReadShort 等）。数据流：errCode 参数由外部调用者直接传入，在 MessageSequenceImpl 的各种 Read* 方法中未进行判空检查即直接解引用。关键调用点：所有 Read* 方法均未对 errCode 参数进行判空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 Read* 方法中添加对 errCode 参数的判空检查，或者在方法文档中明确要求调用者必须传入有效的指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 877, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4075, "verify": "errCode pointer is not null before dereference", "has_risk": true, "preconditions": "调用者传入的 errCode 指针为 null", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl 的各种 Read* 方法（如 CJ_ReadByte/CJ_ReadShort 等）。数据流：errCode 参数由外部调用者直接传入，在 MessageSequenceImpl 的各种 Read* 方法中未进行判空检查即直接解引用。关键调用点：所有 Read* 方法均未对 errCode 参数进行判空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 Read* 方法中添加对 errCode 参数的判空检查，或者在方法文档中明确要求调用者必须传入有效的指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 885, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4076, "verify": "errCode pointer is not null before dereference", "has_risk": true, "preconditions": "调用者传入的 errCode 指针为 null", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl 的各种 Read* 方法（如 CJ_ReadByte/CJ_ReadShort 等）。数据流：errCode 参数由外部调用者直接传入，在 MessageSequenceImpl 的各种 Read* 方法中未进行判空检查即直接解引用。关键调用点：所有 Read* 方法均未对 errCode 参数进行判空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 Read* 方法中添加对 errCode 参数的判空检查，或者在方法文档中明确要求调用者必须传入有效的指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 895, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4078, "verify": "errCode pointer is not null before dereference", "has_risk": true, "preconditions": "调用者传入的 errCode 指针为 null", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl 的各种 Read* 方法（如 CJ_ReadByte/CJ_ReadShort 等）。数据流：errCode 参数由外部调用者直接传入，在 MessageSequenceImpl 的各种 Read* 方法中未进行判空检查即直接解引用。关键调用点：所有 Read* 方法均未对 errCode 参数进行判空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 Read* 方法中添加对 errCode 参数的判空检查，或者在方法文档中明确要求调用者必须传入有效的指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 903, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4080, "verify": "errCode pointer is not null before dereference", "has_risk": true, "preconditions": "调用者传入的 errCode 指针为 null", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl 的各种 Read* 方法（如 CJ_ReadByte/CJ_ReadShort 等）。数据流：errCode 参数由外部调用者直接传入，在 MessageSequenceImpl 的各种 Read* 方法中未进行判空检查即直接解引用。关键调用点：所有 Read* 方法均未对 errCode 参数进行判空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 Read* 方法中添加对 errCode 参数的判空检查，或者在方法文档中明确要求调用者必须传入有效的指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 911, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4081, "verify": "errCode pointer is not null before dereference", "has_risk": true, "preconditions": "调用者传入的 errCode 指针为 null", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl 的各种 Read* 方法（如 CJ_ReadByte/CJ_ReadShort 等）。数据流：errCode 参数由外部调用者直接传入，在 MessageSequenceImpl 的各种 Read* 方法中未进行判空检查即直接解引用。关键调用点：所有 Read* 方法均未对 errCode 参数进行判空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 Read* 方法中添加对 errCode 参数的判空检查，或者在方法文档中明确要求调用者必须传入有效的指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 921, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4083, "verify": "errCode pointer is not null before dereference", "has_risk": true, "preconditions": "调用者传入的 errCode 指针为 null", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl 的各种 Read* 方法（如 CJ_ReadByte/CJ_ReadShort 等）。数据流：errCode 参数由外部调用者直接传入，在 MessageSequenceImpl 的各种 Read* 方法中未进行判空检查即直接解引用。关键调用点：所有 Read* 方法均未对 errCode 参数进行判空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 Read* 方法中添加对 errCode 参数的判空检查，或者在方法文档中明确要求调用者必须传入有效的指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 929, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4085, "verify": "errCode pointer is not null before dereference", "has_risk": true, "preconditions": "调用者传入的 errCode 指针为 null", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl 的各种 Read* 方法（如 CJ_ReadByte/CJ_ReadShort 等）。数据流：errCode 参数由外部调用者直接传入，在 MessageSequenceImpl 的各种 Read* 方法中未进行判空检查即直接解引用。关键调用点：所有 Read* 方法均未对 errCode 参数进行判空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 Read* 方法中添加对 errCode 参数的判空检查，或者在方法文档中明确要求调用者必须传入有效的指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 937, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4086, "verify": "errCode pointer is not null before dereference", "has_risk": true, "preconditions": "调用者传入的 errCode 指针为 null", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl 的各种 Read* 方法（如 CJ_ReadByte/CJ_ReadShort 等）。数据流：errCode 参数由外部调用者直接传入，在 MessageSequenceImpl 的各种 Read* 方法中未进行判空检查即直接解引用。关键调用点：所有 Read* 方法均未对 errCode 参数进行判空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 Read* 方法中添加对 errCode 参数的判空检查，或者在方法文档中明确要求调用者必须传入有效的指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 947, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4088, "verify": "errCode pointer is not null before dereference", "has_risk": true, "preconditions": "调用者传入的 errCode 指针为 null", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl 的各种 Read* 方法（如 CJ_ReadByte/CJ_ReadShort 等）。数据流：errCode 参数由外部调用者直接传入，在 MessageSequenceImpl 的各种 Read* 方法中未进行判空检查即直接解引用。关键调用点：所有 Read* 方法均未对 errCode 参数进行判空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 Read* 方法中添加对 errCode 参数的判空检查，或者在方法文档中明确要求调用者必须传入有效的指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 955, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4090, "verify": "errCode pointer is not null before dereference", "has_risk": true, "preconditions": "调用者传入的 errCode 指针为 null", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl 的各种 Read* 方法（如 CJ_ReadByte/CJ_ReadShort 等）。数据流：errCode 参数由外部调用者直接传入，在 MessageSequenceImpl 的各种 Read* 方法中未进行判空检查即直接解引用。关键调用点：所有 Read* 方法均未对 errCode 参数进行判空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 Read* 方法中添加对 errCode 参数的判空检查，或者在方法文档中明确要求调用者必须传入有效的指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 963, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4091, "verify": "errCode pointer is not null before dereference", "has_risk": true, "preconditions": "调用者传入的 errCode 指针为 null", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl 的各种 Read* 方法（如 CJ_ReadByte/CJ_ReadShort 等）。数据流：errCode 参数由外部调用者直接传入，在 MessageSequenceImpl 的各种 Read* 方法中未进行判空检查即直接解引用。关键调用点：所有 Read* 方法均未对 errCode 参数进行判空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 Read* 方法中添加对 errCode 参数的判空检查，或者在方法文档中明确要求调用者必须传入有效的指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 973, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4093, "verify": "errCode pointer is not null before dereference", "has_risk": true, "preconditions": "调用者传入的 errCode 指针为 null", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl 的各种 Read* 方法（如 CJ_ReadByte/CJ_ReadShort 等）。数据流：errCode 参数由外部调用者直接传入，在 MessageSequenceImpl 的各种 Read* 方法中未进行判空检查即直接解引用。关键调用点：所有 Read* 方法均未对 errCode 参数进行判空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 Read* 方法中添加对 errCode 参数的判空检查，或者在方法文档中明确要求调用者必须传入有效的指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 981, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4095, "verify": "errCode pointer is not null before dereference", "has_risk": true, "preconditions": "调用者传入的 errCode 指针为 null", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl 的各种 Read* 方法（如 CJ_ReadByte/CJ_ReadShort 等）。数据流：errCode 参数由外部调用者直接传入，在 MessageSequenceImpl 的各种 Read* 方法中未进行判空检查即直接解引用。关键调用点：所有 Read* 方法均未对 errCode 参数进行判空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 Read* 方法中添加对 errCode 参数的判空检查，或者在方法文档中明确要求调用者必须传入有效的指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 989, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4096, "verify": "errCode pointer is not null before dereference", "has_risk": true, "preconditions": "调用者传入的 errCode 指针为 null", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl 的各种 Read* 方法（如 CJ_ReadByte/CJ_ReadShort 等）。数据流：errCode 参数由外部调用者直接传入，在 MessageSequenceImpl 的各种 Read* 方法中未进行判空检查即直接解引用。关键调用点：所有 Read* 方法均未对 errCode 参数进行判空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在所有 Read* 方法中添加对 errCode 参数的判空检查，或者在方法文档中明确要求调用者必须传入有效的指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 999, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4098, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1007, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4100, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1015, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4101, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1025, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4103, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1039, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4106, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1048, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4108, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1058, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4110, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1068, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4112, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1078, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4114, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1088, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4116, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1098, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4118, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1108, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4120, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1118, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4122, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1128, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4124, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1138, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4126, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1146, "evidence": "*errCode = errorDesc::CHECK_PARAM_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4127, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1150, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4128, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1156, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4130, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1161, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4131, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1167, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4132, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1176, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4133, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1181, "evidence": "*errCode = errorDesc::PROXY_OR_REMOTE_OBJECT_INVALID_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4135, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1192, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4137, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1202, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4139, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1207, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4140, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1226, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4143, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1247, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4144, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/cj/src/message_sequence_impl.cpp", "line": 1269, "evidence": "*errCode = errorDesc::READ_DATA_FROM_MESSAGE_SEQUENCE_ERROR;", "confidence": 0.6, "severity": "high", "gid": 4147, "verify": "errCode指针在使用前必须非空", "has_risk": true, "preconditions": "调用者传入的errCode指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> MessageSequenceImpl类的各种CJ_Read*Array方法。数据流：调用者直接传入errCode指针，方法内部未对指针进行空指针检查就直接解引用。关键调用点：所有CJ_Read*Array方法入口处缺少errCode指针的空检查。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在所有CJ_Read*Array方法开始处添加errCode指针的空检查，或确保所有调用者都传入有效的errCode指针", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/rust/src/cxx/remote_object_wrapper.cpp", "line": 67, "evidence": "bool res = sptr_->AddDeathRecipient(recipient);", "confidence": 0.6, "severity": "high", "gid": 4161, "verify": "验证指针在解引用前是否非空", "has_risk": true, "preconditions": "sptr_ 指针未被正确初始化或设置为空", "trigger_path": "调用路径推导：AddDeathRecipient() 直接使用 sptr_ 指针。数据流：sptr_ 作为类成员变量，在构造函数中初始化为 nullptr，可能未被后续代码正确初始化。关键调用点：AddDeathRecipient() 方法未检查 sptr_ 是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在 AddDeathRecipient() 方法开始处添加 sptr_ 的非空检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/innerkits/rust/src/cxx/remote_object_wrapper.cpp", "line": 193, "evidence": "auto rust_s = raw->descriptor();", "confidence": 0.6, "severity": "high", "gid": 4173, "verify": "验证指针在解引用前是否非空", "has_risk": true, "preconditions": "stub.into_raw() 返回空指针或无效指针", "trigger_path": "调用路径推导：FromRemoteStub() -> stub.into_raw()。数据流：rust::Box<RemoteStubWrapper> 通过 into_raw() 转换为原始指针，未进行空指针检查。关键调用点：FromRemoteStub() 方法未检查 raw 指针是否为空。", "consequences": "空指针解引用导致程序崩溃", "suggestions": "在调用 raw->descriptor() 前添加空指针检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/c/src/dbinder_stub.c", "line": 136, "evidence": "dBinderServiceStub->binderObject = binderObject;", "confidence": 0.6, "severity": "high", "gid": 4199, "verify": "验证binderObject指针在操作前是否非空", "has_risk": true, "preconditions": "传入的binderObject参数为空指针", "trigger_path": "调用路径推导：FindOrNewDBinderStub() -> GetDBinderStub() -> 直接使用binderObject。数据流：binderObject作为参数传递给FindOrNewDBinderStub()，该函数未进行空指针检查直接传递给GetDBinderStub()，GetDBinderStub()也未检查直接赋值给dBinderServiceStub->binderObject。关键调用点：FindOrNewDBinderStub()和GetDBinderStub()均未对binderObject进行空指针校验。", "consequences": "可能导致空指针解引用，引发程序崩溃", "suggestions": "在FindOrNewDBinderStub()或GetDBinderStub()函数中添加对binderObject的空指针检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/c/src/dbinder_service.c", "line": 203, "evidence": "int32_t sessionId = g_trans->Connect(DBINDER_SESSION_NAME, deviceId, NULL);", "confidence": 0.6, "severity": "high", "gid": 4238, "verify": "验证指针在使用前是否为空", "has_risk": true, "preconditions": "g_trans 全局指针未正确初始化或为空", "trigger_path": "调用路径推导：系统初始化 -> 各功能函数调用 -> g_trans 使用。数据流：g_trans 是全局变量，在系统初始化时设置，但未在所有使用点检查是否已初始化。关键调用点：所有使用 g_trans 的函数都未检查其是否为空指针。", "consequences": "可能导致程序崩溃或功能异常", "suggestions": "1. 在系统初始化时确保 g_trans 被正确设置；2. 在所有使用 g_trans 的地方添加空指针检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/c/src/dbinder_service.c", "line": 214, "evidence": "if (g_trans->Send(sessionId, (void *)msg, msg->head.len) != ERR_NONE) {", "confidence": 0.6, "severity": "high", "gid": 4239, "verify": "验证指针在使用前是否为空", "has_risk": true, "preconditions": "g_trans 全局指针未正确初始化或为空", "trigger_path": "调用路径推导：系统初始化 -> 各功能函数调用 -> g_trans 使用。数据流：g_trans 是全局变量，在系统初始化时设置，但未在所有使用点检查是否已初始化。关键调用点：所有使用 g_trans 的函数都未检查其是否为空指针。", "consequences": "可能导致程序崩溃或功能异常", "suggestions": "1. 在系统初始化时确保 g_trans 被正确设置；2. 在所有使用 g_trans 的地方添加空指针检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/c/src/dbinder_service.c", "line": 214, "evidence": "if (g_trans->Send(sessionId, (void *)msg, msg->head.len) != ERR_NONE) {", "confidence": 0.6, "severity": "high", "gid": 4240, "verify": "验证指针在使用前是否为空", "has_risk": true, "preconditions": "g_trans 全局指针未正确初始化或为空", "trigger_path": "调用路径推导：系统初始化 -> 各功能函数调用 -> g_trans 使用。数据流：g_trans 是全局变量，在系统初始化时设置，但未在所有使用点检查是否已初始化。关键调用点：所有使用 g_trans 的函数都未检查其是否为空指针。", "consequences": "可能导致程序崩溃或功能异常", "suggestions": "1. 在系统初始化时确保 g_trans 被正确设置；2. 在所有使用 g_trans 的地方添加空指针检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/c/src/dbinder_service.c", "line": 232, "evidence": "if (g_trans->GetLocalDeviceID(DBINDER_SESSION_NAME, localDeviceID) != ERR_NONE) {", "confidence": 0.6, "severity": "high", "gid": 4242, "verify": "验证指针在使用前是否为空", "has_risk": true, "preconditions": "g_trans 全局指针未正确初始化或为空", "trigger_path": "调用路径推导：系统初始化 -> 各功能函数调用 -> g_trans 使用。数据流：g_trans 是全局变量，在系统初始化时设置，但未在所有使用点检查是否已初始化。关键调用点：所有使用 g_trans 的函数都未检查其是否为空指针。", "consequences": "可能导致程序崩溃或功能异常", "suggestions": "1. 在系统初始化时确保 g_trans 被正确设置；2. 在所有使用 g_trans 的地方添加空指针检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "error_handling", "pattern": "pthread_ret_unchecked", "file": "dbinder/c/src/dbinder_service.c", "line": 110, "evidence": "pthread_mutex_lock(&g_binderList.mutex);", "confidence": 0.6, "severity": "medium", "gid": 4215, "verify": "验证pthread函数调用是否检查了返回值", "has_risk": true, "preconditions": "在多线程环境下，pthread_mutex_lock调用失败（如资源不足、死锁等情况）", "trigger_path": "调用路径推导：多个线程并发访问共享资源时，通过各查询函数（如GetRegisterService/QueryDBinderStub等）直接调用pthread_mutex_lock而未检查返回值。数据流：线程竞争直接导致锁操作失败。关键调用点：所有调用pthread_mutex_lock的函数均未检查返回值。", "consequences": "可能导致线程同步失效、数据竞争、死锁或未定义行为", "suggestions": "1) 对所有pthread_mutex_lock调用添加返回值检查；2) 使用锁封装函数统一处理错误；3) 考虑使用RAII模式管理锁资源", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "error_handling", "pattern": "pthread_ret_unchecked", "file": "dbinder/c/src/dbinder_service.c", "line": 147, "evidence": "pthread_mutex_lock(&g_stubRegistedList.mutex);", "confidence": 0.6, "severity": "medium", "gid": 4216, "verify": "验证pthread函数调用是否检查了返回值", "has_risk": true, "preconditions": "在多线程环境下，pthread_mutex_lock调用失败（如资源不足、死锁等情况）", "trigger_path": "调用路径推导：多个线程并发访问共享资源时，通过各查询函数（如GetRegisterService/QueryDBinderStub等）直接调用pthread_mutex_lock而未检查返回值。数据流：线程竞争直接导致锁操作失败。关键调用点：所有调用pthread_mutex_lock的函数均未检查返回值。", "consequences": "可能导致线程同步失效、数据竞争、死锁或未定义行为", "suggestions": "1) 对所有pthread_mutex_lock调用添加返回值检查；2) 使用锁封装函数统一处理错误；3) 考虑使用RAII模式管理锁资源", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "error_handling", "pattern": "pthread_ret_unchecked", "file": "dbinder/c/src/dbinder_service.c", "line": 382, "evidence": "pthread_mutex_lock(&mutex);", "confidence": 0.6, "severity": "medium", "gid": 4217, "verify": "验证pthread函数调用是否检查了返回值", "has_risk": true, "preconditions": "在多线程环境下，pthread_mutex_lock调用失败（如资源不足、死锁等情况）", "trigger_path": "调用路径推导：多个线程并发访问共享资源时，通过各查询函数（如GetRegisterService/QueryDBinderStub等）直接调用pthread_mutex_lock而未检查返回值。数据流：线程竞争直接导致锁操作失败。关键调用点：所有调用pthread_mutex_lock的函数均未检查返回值。", "consequences": "可能导致线程同步失效、数据竞争、死锁或未定义行为", "suggestions": "1) 对所有pthread_mutex_lock调用添加返回值检查；2) 使用锁封装函数统一处理错误；3) 考虑使用RAII模式管理锁资源", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "error_handling", "pattern": "pthread_ret_unchecked", "file": "dbinder/c/src/dbinder_service.c", "line": 406, "evidence": "pthread_mutex_lock(&g_sessionInfoList.mutex);", "confidence": 0.6, "severity": "medium", "gid": 4218, "verify": "验证pthread函数调用是否检查了返回值", "has_risk": true, "preconditions": "在多线程环境下，pthread_mutex_lock调用失败（如资源不足、死锁等情况）", "trigger_path": "调用路径推导：多个线程并发访问共享资源时，通过各查询函数（如GetRegisterService/QueryDBinderStub等）直接调用pthread_mutex_lock而未检查返回值。数据流：线程竞争直接导致锁操作失败。关键调用点：所有调用pthread_mutex_lock的函数均未检查返回值。", "consequences": "可能导致线程同步失效、数据竞争、死锁或未定义行为", "suggestions": "1) 对所有pthread_mutex_lock调用添加返回值检查；2) 使用锁封装函数统一处理错误；3) 考虑使用RAII模式管理锁资源", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "error_handling", "pattern": "pthread_ret_unchecked", "file": "dbinder/c/src/dbinder_service.c", "line": 432, "evidence": "pthread_mutex_lock(&g_proxyObjectList.mutex);", "confidence": 0.6, "severity": "medium", "gid": 4219, "verify": "验证pthread函数调用是否检查了返回值", "has_risk": true, "preconditions": "在多线程环境下，pthread_mutex_lock调用失败（如资源不足、死锁等情况）", "trigger_path": "调用路径推导：多个线程并发访问共享资源时，通过各查询函数（如GetRegisterService/QueryDBinderStub等）直接调用pthread_mutex_lock而未检查返回值。数据流：线程竞争直接导致锁操作失败。关键调用点：所有调用pthread_mutex_lock的函数均未检查返回值。", "consequences": "可能导致线程同步失效、数据竞争、死锁或未定义行为", "suggestions": "1) 对所有pthread_mutex_lock调用添加返回值检查；2) 使用锁封装函数统一处理错误；3) 考虑使用RAII模式管理锁资源", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "error_handling", "pattern": "pthread_ret_unchecked", "file": "dbinder/c/src/dbinder_service.c", "line": 627, "evidence": "pthread_mutex_lock(&g_threadLockInfoList.mutex);", "confidence": 0.6, "severity": "medium", "gid": 4220, "verify": "验证pthread函数调用是否检查了返回值", "has_risk": true, "preconditions": "在多线程环境下，pthread_mutex_lock调用失败（如资源不足、死锁等情况）", "trigger_path": "调用路径推导：多个线程并发访问共享资源时，通过各查询函数（如GetRegisterService/QueryDBinderStub等）直接调用pthread_mutex_lock而未检查返回值。数据流：线程竞争直接导致锁操作失败。关键调用点：所有调用pthread_mutex_lock的函数均未检查返回值。", "consequences": "可能导致线程同步失效、数据竞争、死锁或未定义行为", "suggestions": "1) 对所有pthread_mutex_lock调用添加返回值检查；2) 使用锁封装函数统一处理错误；3) 考虑使用RAII模式管理锁资源", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "error_handling", "pattern": "pthread_ret_unchecked", "file": "dbinder/c/src/dbinder_service.c", "line": 654, "evidence": "pthread_mutex_lock(&g_stubRegistedList.mutex);", "confidence": 0.6, "severity": "medium", "gid": 4221, "verify": "验证pthread函数调用是否检查了返回值", "has_risk": true, "preconditions": "在多线程环境下，pthread_mutex_lock调用失败（如资源不足、死锁等情况）", "trigger_path": "调用路径推导：多个线程并发访问共享资源时，通过各查询函数（如GetRegisterService/QueryDBinderStub等）直接调用pthread_mutex_lock而未检查返回值。数据流：线程竞争直接导致锁操作失败。关键调用点：所有调用pthread_mutex_lock的函数均未检查返回值。", "consequences": "可能导致线程同步失效、数据竞争、死锁或未定义行为", "suggestions": "1) 对所有pthread_mutex_lock调用添加返回值检查；2) 使用锁封装函数统一处理错误；3) 考虑使用RAII模式管理锁资源", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "thread_safety", "pattern": "cond_wait_no_loop", "file": "dbinder/c/src/dbinder_service.c", "line": 355, "evidence": "ret = pthread_cond_timedwait(&threadLockInfo->condition, &threadLockInfo->mutex, &waitTime);", "confidence": 0.6, "severity": "medium", "gid": 4222, "verify": "验证条件变量等待是否在循环中", "has_risk": true, "preconditions": "线程在等待条件变量时可能发生虚假唤醒", "trigger_path": "调用路径推导：InvokerRemoteDBinder() -> pthread_cond_timedwait()。数据流：线程通过InvokerRemoteDBinder函数进入等待状态，直接调用pthread_cond_timedwait等待条件变量，未在循环中检查条件。关键调用点：InvokerRemoteDBinder()函数未将条件变量等待放入循环中检查。", "consequences": "可能导致线程在条件未真正满足时被唤醒，引发竞态条件或逻辑错误", "suggestions": "将pthread_cond_timedwait调用放入while循环中，检查相关条件是否满足", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "dbinder/c/src/dbinder_service.c", "line": 203, "evidence": "int32_t sessionId = g_trans->Connect(DBINDER_SESSION_NAME, deviceId, NULL);", "confidence": 0.5, "severity": "medium", "gid": 4376, "verify": "验证远程调用操作是否线程安全", "has_risk": true, "preconditions": "多线程环境下并发访问 g_trans 全局变量", "trigger_path": "调用路径推导：任何调用 SendDataToRemote() 或 InvokerRemoteDBinder() 的线程 -> 访问 g_trans 成员函数。数据流：g_trans 作为全局变量被多个线程共享访问，在 SendDataToRemote() 中通过 g_trans->Connect()/Send() 和 WaitForSessionIdReady() 访问，在 SendEntryToRemote() 中通过 g_trans->GetLocalDeviceID() 访问。关键调用点：所有访问 g_trans 的地方都没有同步机制保护。", "consequences": "数据竞争可能导致程序崩溃或未定义行为", "suggestions": "1. 对 g_trans 的访问加全局锁保护；2. 或确保 g_trans 在初始化完成后不再修改（只读访问）", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "dbinder/c/src/dbinder_service.c", "line": 209, "evidence": "if (WaitForSessionIdReady(&g_sessionIdList, sessionId) != ERR_NONE) {", "confidence": 0.5, "severity": "medium", "gid": 4377, "verify": "验证远程调用操作是否线程安全", "has_risk": true, "preconditions": "多线程环境下并发访问 g_trans 全局变量", "trigger_path": "调用路径推导：任何调用 SendDataToRemote() 或 InvokerRemoteDBinder() 的线程 -> 访问 g_trans 成员函数。数据流：g_trans 作为全局变量被多个线程共享访问，在 SendDataToRemote() 中通过 g_trans->Connect()/Send() 和 WaitForSessionIdReady() 访问，在 SendEntryToRemote() 中通过 g_trans->GetLocalDeviceID() 访问。关键调用点：所有访问 g_trans 的地方都没有同步机制保护。", "consequences": "数据竞争可能导致程序崩溃或未定义行为", "suggestions": "1. 对 g_trans 的访问加全局锁保护；2. 或确保 g_trans 在初始化完成后不再修改（只读访问）", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "dbinder/c/src/dbinder_service.c", "line": 214, "evidence": "if (g_trans->Send(sessionId, (void *)msg, msg->head.len) != ERR_NONE) {", "confidence": 0.5, "severity": "medium", "gid": 4378, "verify": "验证远程调用操作是否线程安全", "has_risk": true, "preconditions": "多线程环境下并发访问 g_trans 全局变量", "trigger_path": "调用路径推导：任何调用 SendDataToRemote() 或 InvokerRemoteDBinder() 的线程 -> 访问 g_trans 成员函数。数据流：g_trans 作为全局变量被多个线程共享访问，在 SendDataToRemote() 中通过 g_trans->Connect()/Send() 和 WaitForSessionIdReady() 访问，在 SendEntryToRemote() 中通过 g_trans->GetLocalDeviceID() 访问。关键调用点：所有访问 g_trans 的地方都没有同步机制保护。", "consequences": "数据竞争可能导致程序崩溃或未定义行为", "suggestions": "1. 对 g_trans 的访问加全局锁保护；2. 或确保 g_trans 在初始化完成后不再修改（只读访问）", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "dbinder/c/src/dbinder_service.c", "line": 232, "evidence": "if (g_trans->GetLocalDeviceID(DBINDER_SESSION_NAME, localDeviceID) != ERR_NONE) {", "confidence": 0.5, "severity": "medium", "gid": 4380, "verify": "验证远程调用操作是否线程安全", "has_risk": true, "preconditions": "多线程环境下并发访问 g_trans 全局变量", "trigger_path": "调用路径推导：任何调用 SendDataToRemote() 或 InvokerRemoteDBinder() 的线程 -> 访问 g_trans 成员函数。数据流：g_trans 作为全局变量被多个线程共享访问，在 SendDataToRemote() 中通过 g_trans->Connect()/Send() 和 WaitForSessionIdReady() 访问，在 SendEntryToRemote() 中通过 g_trans->GetLocalDeviceID() 访问。关键调用点：所有访问 g_trans 的地方都没有同步机制保护。", "consequences": "数据竞争可能导致程序崩溃或未定义行为", "suggestions": "1. 对 g_trans 的访问加全局锁保护；2. 或确保 g_trans 在初始化完成后不再修改（只读访问）", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "dbinder/c/src/dbinder_service.c", "line": 510, "evidence": "static int32_t GetDatabusNameByProxy(ProxyObject *proxy)", "confidence": 0.5, "severity": "medium", "gid": 4461, "verify": "验证远程消息处理过程中的线程同步机制", "has_risk": true, "preconditions": "多个线程同时访问同一个 ProxyObject 对象", "trigger_path": "调用路径推导：OnRemoteInvokerDataBusMessage() -> GetDatabusNameByProxy()。数据流：远程消息通过 OnRemoteInvokerDataBusMessage 接收，传递给 GetDatabusNameByProxy 处理。关键调用点：OnRemoteInvokerDataBusMessage 未对 ProxyObject 的并发访问进行同步。", "consequences": "数据竞争可能导致 sessionName 状态不一致", "suggestions": "为 ProxyObject 添加互斥锁保护或使用线程安全的数据结构", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "dbinder/c/src/dbinder_service.c", "line": 528, "evidence": "static int32_t OnRemoteInvokerDataBusMessage(ProxyObject *proxy, DHandleEntryTxRx *replyMessage,", "confidence": 0.6, "severity": "medium", "gid": 4462, "verify": "验证远程消息处理过程中的线程同步机制", "has_risk": true, "preconditions": "多个线程同时处理远程消息", "trigger_path": "调用路径推导：OnRemoteInvokerMessage() -> OnRemoteInvokerDataBusMessage() -> GetDatabusNameByProxy()/GetLocalDeviceID()。数据流：远程消息通过线程池分发到 OnRemoteInvokerMessage，传递给 OnRemoteInvokerDataBusMessage 处理。关键调用点：共享的 ProxyObject 和全局 g_trans 变量访问缺少同步机制。", "consequences": "并发访问可能导致数据竞争或状态不一致", "suggestions": "为共享资源添加适当的同步机制，如互斥锁或原子操作", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "dbinder/c/src/dbinder_service.c", "line": 536, "evidence": "if (GetDatabusNameByProxy(proxy) != ERR_NONE) {", "confidence": 0.5, "severity": "medium", "gid": 4463, "verify": "验证远程消息处理过程中的线程同步机制", "has_risk": true, "preconditions": "多个线程同时处理远程消息", "trigger_path": "调用路径推导：OnRemoteInvokerMessage() -> OnRemoteInvokerDataBusMessage() -> GetDatabusNameByProxy()/GetLocalDeviceID()。数据流：远程消息通过线程池分发到 OnRemoteInvokerMessage，传递给 OnRemoteInvokerDataBusMessage 处理。关键调用点：共享的 ProxyObject 和全局 g_trans 变量访问缺少同步机制。", "consequences": "并发访问可能导致数据竞争或状态不一致", "suggestions": "为共享资源添加适当的同步机制，如互斥锁或原子操作", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "dbinder/c/src/dbinder_service.c", "line": 542, "evidence": "int32_t ret = g_trans->GetLocalDeviceID(DBINDER_SESSION_NAME, localDeviceId);", "confidence": 0.5, "severity": "medium", "gid": 4464, "verify": "验证远程消息处理过程中的线程同步机制", "has_risk": true, "preconditions": "多个线程同时处理远程消息", "trigger_path": "调用路径推导：OnRemoteInvokerMessage() -> OnRemoteInvokerDataBusMessage() -> GetDatabusNameByProxy()/GetLocalDeviceID()。数据流：远程消息通过线程池分发到 OnRemoteInvokerMessage，传递给 OnRemoteInvokerDataBusMessage 处理。关键调用点：共享的 ProxyObject 和全局 g_trans 变量访问缺少同步机制。", "consequences": "并发访问可能导致数据竞争或状态不一致", "suggestions": "为共享资源添加适当的同步机制，如互斥锁或原子操作", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "dbinder/c/src/dbinder_service.c", "line": 585, "evidence": "static void *OnRemoteInvokerMessage(void *args)", "confidence": 0.5, "severity": "medium", "gid": 4465, "verify": "验证远程消息处理过程中的线程同步机制", "has_risk": true, "preconditions": "多个线程同时处理远程消息", "trigger_path": "调用路径推导：OnRemoteInvokerMessage() -> OnRemoteInvokerDataBusMessage() -> GetDatabusNameByProxy()/GetLocalDeviceID()。数据流：远程消息通过线程池分发到 OnRemoteInvokerMessage，传递给 OnRemoteInvokerDataBusMessage 处理。关键调用点：共享的 ProxyObject 和全局 g_trans 变量访问缺少同步机制。", "consequences": "并发访问可能导致数据竞争或状态不一致", "suggestions": "为共享资源添加适当的同步机制，如互斥锁或原子操作", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "dbinder/c/src/dbinder_service.c", "line": 711, "evidence": "if (AttachSessionObject(session) != 0) {", "confidence": 0.5, "severity": "medium", "gid": 4493, "verify": "验证远程消息处理过程中的线程同步机制", "has_risk": true, "preconditions": "多个线程同时创建会话对象", "trigger_path": "调用路径推导：OnRemoteReplyMessage() -> MakeSessionByReplyMessage() -> AttachSessionObject()。数据流：远程回复消息触发会话创建流程。关键调用点：AttachSessionObject 的调用未显示同步机制。", "consequences": "并发会话创建可能导致内存泄漏或数据损坏", "suggestions": "检查并确保 AttachSessionObject 内部有适当的同步机制", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/dbinder_service/src/dbinder_service.cpp", "line": 848, "evidence": "int err = proxy->InvokeListenThread(data, reply);", "confidence": 0.6, "severity": "high", "gid": 4675, "verify": "验证proxy指针在解引用前非空", "has_risk": true, "preconditions": "proxy指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> CheckInvokeListenThreadIllegal() -> 缺陷代码。数据流：proxy指针作为参数传入CheckInvokeListenThreadIllegal函数，函数内部未对proxy进行nullptr检查就直接调用其方法。关键调用点：CheckInvokeListenThreadIllegal()函数未对proxy参数进行nullptr检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在CheckInvokeListenThreadIllegal函数开头添加proxy指针的nullptr检查，如：if (proxy == nullptr) { return false; }", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/dbinder_service/src/dbinder_service.cpp", "line": 850, "evidence": "DBINDER_LOGE(LOG_LABEL, \"                                                       \", err, proxy->GetHandle());", "confidence": 0.6, "severity": "high", "gid": 4676, "verify": "验证proxy指针在解引用前非空", "has_risk": true, "preconditions": "proxy指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> CheckInvokeListenThreadIllegal() -> 缺陷代码。数据流：proxy指针作为参数传入CheckInvokeListenThreadIllegal函数，函数内部未对proxy进行nullptr检查就直接调用其方法。关键调用点：CheckInvokeListenThreadIllegal()函数未对proxy参数进行nullptr检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在CheckInvokeListenThreadIllegal函数开头添加proxy指针的nullptr检查，如：if (proxy == nullptr) { return false; }", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/dbinder_service/src/dbinder_service.cpp", "line": 861, "evidence": "\"                                      \", stubIndex, serverSessionName.c_str(), proxy->GetHandle(),", "confidence": 0.6, "severity": "high", "gid": 4677, "verify": "验证proxy指针在解引用前非空", "has_risk": true, "preconditions": "proxy指针为nullptr", "trigger_path": "调用路径推导：外部调用者 -> CheckInvokeListenThreadIllegal() -> 缺陷代码。数据流：proxy指针作为参数传入CheckInvokeListenThreadIllegal函数，函数内部未对proxy进行nullptr检查就直接调用其方法。关键调用点：CheckInvokeListenThreadIllegal()函数未对proxy参数进行nullptr检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在CheckInvokeListenThreadIllegal函数开头添加proxy指针的nullptr检查，如：if (proxy == nullptr) { return false; }", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/dbinder_service/src/dbinder_service.cpp", "line": 784, "evidence": "bool isSaAvailable = dbinderCallback_->LoadSystemAbilityFromRemote(replyMessage->deviceIdInfo.fromDeviceId,", "confidence": 0.6, "severity": "high", "gid": 4668, "verify": "验证dbinderCallback_指针在解引用前非空", "has_risk": true, "preconditions": "StartDBinderService未被调用或传入的callbackImpl为空，导致dbinderCallback_保持nullptr状态", "trigger_path": "调用路径推导：StartDBinderService() -> OnRemoteInvokerMessage() -> dbinderCallback_->LoadSystemAbilityFromRemote()。数据流：dbinderCallback_在StartDBinderService中初始化，在OnRemoteInvokerMessage中使用。关键调用点：OnRemoteInvokerMessage()函数未对dbinderCallback_进行空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在使用dbinderCallback_前添加空指针检查，确保指针有效性", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/dbinder_service/src/dbinder_service.cpp", "line": 784, "evidence": "bool isSaAvailable = dbinderCallback_->LoadSystemAbilityFromRemote(replyMessage->deviceIdInfo.fromDeviceId,", "confidence": 0.6, "severity": "high", "gid": 4669, "verify": "验证dbinderCallback_指针在解引用前非空", "has_risk": true, "preconditions": "StartDBinderService未被调用或传入的callbackImpl为空，导致dbinderCallback_保持nullptr状态", "trigger_path": "调用路径推导：StartDBinderService() -> OnRemoteInvokerMessage() -> dbinderCallback_->LoadSystemAbilityFromRemote()。数据流：dbinderCallback_在StartDBinderService中初始化，在OnRemoteInvokerMessage中使用。关键调用点：OnRemoteInvokerMessage()函数未对dbinderCallback_进行空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在使用dbinderCallback_前添加空指针检查，确保指针有效性", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/dbinder_service/src/dbinder_service.cpp", "line": 681, "evidence": "if (!saProxy->AddDeathRecipient(death)) {", "confidence": 0.6, "severity": "high", "gid": 4648, "verify": "验证saProxy指针在解引用前非空", "has_risk": true, "preconditions": "remoteObject.GetRefPtr()返回nullptr", "trigger_path": "调用路径推导：LoadSystemAbilityComplete() -> remoteObject.GetRefPtr() -> reinterpret_cast<IPCObjectProxy*> -> saProxy->AddDeathRecipient()。数据流：remoteObject参数传入LoadSystemAbilityComplete，虽然检查了remoteObject是否为null，但未检查remoteObject.GetRefPtr()的返回值。关键调用点：LoadSystemAbilityComplete()函数未对remoteObject.GetRefPtr()的结果进行校验。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在调用saProxy->AddDeathRecipient()前添加对saProxy的null检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/dbinder_service/src/dbinder_service.cpp", "line": 881, "evidence": "DBINDER_LOGE(LOG_LABEL, \"                                          \", proxy->GetHandle());", "confidence": 0.6, "severity": "high", "gid": 4687, "verify": "proxy指针在解引用前必须非空", "has_risk": true, "preconditions": "IPCObjectProxy指针proxy可能为空", "trigger_path": "调用路径推导：LoadSystemAbilityComplete() -> OnRemoteInvokerDataBusMessage() -> 各proxy解引用点。数据流：remoteObject.GetRefPtr()返回的指针未经判空直接转换为IPCObjectProxy*并传递给OnRemoteInvokerDataBusMessage()。关键调用点：LoadSystemAbilityComplete()中未对saProxy进行判空检查，OnRemoteInvokerDataBusMessage()入口处也未对proxy参数进行判空检查。", "consequences": "空指针解引用可能导致程序崩溃", "suggestions": "1. 在LoadSystemAbilityComplete()中对saProxy进行判空检查；2. 在OnRemoteInvokerDataBusMessage()入口处添加proxy参数的非空检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/dbinder_service/src/dbinder_service.cpp", "line": 907, "evidence": "DBINDER_LOGE(LOG_LABEL, \"                                       \", proxy->GetHandle());", "confidence": 0.6, "severity": "high", "gid": 4689, "verify": "proxy指针在解引用前必须非空", "has_risk": true, "preconditions": "IPCObjectProxy指针proxy可能为空", "trigger_path": "调用路径推导：LoadSystemAbilityComplete() -> OnRemoteInvokerDataBusMessage() -> 各proxy解引用点。数据流：remoteObject.GetRefPtr()返回的指针未经判空直接转换为IPCObjectProxy*并传递给OnRemoteInvokerDataBusMessage()。关键调用点：LoadSystemAbilityComplete()中未对saProxy进行判空检查，OnRemoteInvokerDataBusMessage()入口处也未对proxy参数进行判空检查。", "consequences": "空指针解引用可能导致程序崩溃", "suggestions": "1. 在LoadSystemAbilityComplete()中对saProxy进行判空检查；2. 在OnRemoteInvokerDataBusMessage()入口处添加proxy参数的非空检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/dbinder_service/src/dbinder_service.cpp", "line": 908, "evidence": "DfxReportFailHandleEvent(DbinderErrorCode::RPC_DRIVER, proxy->GetHandle(),", "confidence": 0.6, "severity": "high", "gid": 4690, "verify": "proxy指针在解引用前必须非空", "has_risk": true, "preconditions": "IPCObjectProxy指针proxy可能为空", "trigger_path": "调用路径推导：LoadSystemAbilityComplete() -> OnRemoteInvokerDataBusMessage() -> 各proxy解引用点。数据流：remoteObject.GetRefPtr()返回的指针未经判空直接转换为IPCObjectProxy*并传递给OnRemoteInvokerDataBusMessage()。关键调用点：LoadSystemAbilityComplete()中未对saProxy进行判空检查，OnRemoteInvokerDataBusMessage()入口处也未对proxy参数进行判空检查。", "consequences": "空指针解引用可能导致程序崩溃", "suggestions": "1. 在LoadSystemAbilityComplete()中对saProxy进行判空检查；2. 在OnRemoteInvokerDataBusMessage()入口处添加proxy参数的非空检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/dbinder_service/src/dbinder_service.cpp", "line": 913, "evidence": "DfxReportFailHandleEvent(DbinderErrorCode::RPC_DRIVER, proxy->GetHandle(),", "confidence": 0.6, "severity": "high", "gid": 4691, "verify": "proxy指针在解引用前必须非空", "has_risk": true, "preconditions": "IPCObjectProxy指针proxy可能为空", "trigger_path": "调用路径推导：LoadSystemAbilityComplete() -> OnRemoteInvokerDataBusMessage() -> 各proxy解引用点。数据流：remoteObject.GetRefPtr()返回的指针未经判空直接转换为IPCObjectProxy*并传递给OnRemoteInvokerDataBusMessage()。关键调用点：LoadSystemAbilityComplete()中未对saProxy进行判空检查，OnRemoteInvokerDataBusMessage()入口处也未对proxy参数进行判空检查。", "consequences": "空指针解引用可能导致程序崩溃", "suggestions": "1. 在LoadSystemAbilityComplete()中对saProxy进行判空检查；2. 在OnRemoteInvokerDataBusMessage()入口处添加proxy参数的非空检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/dbinder_service/src/dbinder_service.cpp", "line": 923, "evidence": "DfxReportFailHandleEvent(DbinderErrorCode::RPC_DRIVER, proxy->GetHandle(),", "confidence": 0.6, "severity": "high", "gid": 4692, "verify": "proxy指针在解引用前必须非空", "has_risk": true, "preconditions": "IPCObjectProxy指针proxy可能为空", "trigger_path": "调用路径推导：LoadSystemAbilityComplete() -> OnRemoteInvokerDataBusMessage() -> 各proxy解引用点。数据流：remoteObject.GetRefPtr()返回的指针未经判空直接转换为IPCObjectProxy*并传递给OnRemoteInvokerDataBusMessage()。关键调用点：LoadSystemAbilityComplete()中未对saProxy进行判空检查，OnRemoteInvokerDataBusMessage()入口处也未对proxy参数进行判空检查。", "consequences": "空指针解引用可能导致程序崩溃", "suggestions": "1. 在LoadSystemAbilityComplete()中对saProxy进行判空检查；2. 在OnRemoteInvokerDataBusMessage()入口处添加proxy参数的非空检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/dbinder_service/src/dbinder_service.cpp", "line": 928, "evidence": "DfxReportFailHandleEvent(DbinderErrorCode::RPC_DRIVER, proxy->GetHandle(), RADAR_ERR_MEMCPY_DATA, __FUNCTION__);", "confidence": 0.6, "severity": "high", "gid": 4693, "verify": "proxy指针在解引用前必须非空", "has_risk": true, "preconditions": "IPCObjectProxy指针proxy可能为空", "trigger_path": "调用路径推导：LoadSystemAbilityComplete() -> OnRemoteInvokerDataBusMessage() -> 各proxy解引用点。数据流：remoteObject.GetRefPtr()返回的指针未经判空直接转换为IPCObjectProxy*并传递给OnRemoteInvokerDataBusMessage()。关键调用点：LoadSystemAbilityComplete()中未对saProxy进行判空检查，OnRemoteInvokerDataBusMessage()入口处也未对proxy参数进行判空检查。", "consequences": "空指针解引用可能导致程序崩溃", "suggestions": "1. 在LoadSystemAbilityComplete()中对saProxy进行判空检查；2. 在OnRemoteInvokerDataBusMessage()入口处添加proxy参数的非空检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/dbinder_service/src/dbinder_service.cpp", "line": 1070, "evidence": "if ((oldSession->stubIndex != newSession->stubIndex) || (oldSession->toPort != newSession->toPort)", "confidence": 0.6, "severity": "high", "gid": 4714, "verify": "oldSession/newSession指针在解引用前必须非空", "has_risk": true, "preconditions": "传入的 newSession 参数为 null", "trigger_path": "调用路径推导：MakeSessionByReplyMessage() -> IsSameSession()。数据流：replyMessage 通过 OnRemoteReplyMessage 接收并传递给 MakeSessionByReplyMessage，MakeSessionByReplyMessage 创建 session 对象并调用 IsSameSession 时未检查 newSession 参数是否为空。关键调用点：MakeSessionByReplyMessage 函数未对 newSession 参数进行空指针检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在 IsSameSession 函数入口处添加对 oldSession 和 newSession 的空指针检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/dbinder_service/src/dbinder_service.cpp", "line": 1070, "evidence": "if ((oldSession->stubIndex != newSession->stubIndex) || (oldSession->toPort != newSession->toPort)", "confidence": 0.6, "severity": "high", "gid": 4715, "verify": "oldSession/newSession指针在解引用前必须非空", "has_risk": true, "preconditions": "传入的 newSession 参数为 null", "trigger_path": "调用路径推导：MakeSessionByReplyMessage() -> IsSameSession()。数据流：replyMessage 通过 OnRemoteReplyMessage 接收并传递给 MakeSessionByReplyMessage，MakeSessionByReplyMessage 创建 session 对象并调用 IsSameSession 时未检查 newSession 参数是否为空。关键调用点：MakeSessionByReplyMessage 函数未对 newSession 参数进行空指针检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在 IsSameSession 函数入口处添加对 oldSession 和 newSession 的空指针检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/dbinder_service/src/dbinder_service.cpp", "line": 1071, "evidence": "|| (oldSession->fromPort != newSession->fromPort) || (oldSession->type != newSession->type)", "confidence": 0.6, "severity": "high", "gid": 4716, "verify": "oldSession/newSession指针在解引用前必须非空", "has_risk": true, "preconditions": "传入的 newSession 参数为 null", "trigger_path": "调用路径推导：MakeSessionByReplyMessage() -> IsSameSession()。数据流：replyMessage 通过 OnRemoteReplyMessage 接收并传递给 MakeSessionByReplyMessage，MakeSessionByReplyMessage 创建 session 对象并调用 IsSameSession 时未检查 newSession 参数是否为空。关键调用点：MakeSessionByReplyMessage 函数未对 newSession 参数进行空指针检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在 IsSameSession 函数入口处添加对 oldSession 和 newSession 的空指针检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/dbinder_service/src/dbinder_service.cpp", "line": 1071, "evidence": "|| (oldSession->fromPort != newSession->fromPort) || (oldSession->type != newSession->type)", "confidence": 0.6, "severity": "high", "gid": 4717, "verify": "oldSession/newSession指针在解引用前必须非空", "has_risk": true, "preconditions": "传入的 newSession 参数为 null", "trigger_path": "调用路径推导：MakeSessionByReplyMessage() -> IsSameSession()。数据流：replyMessage 通过 OnRemoteReplyMessage 接收并传递给 MakeSessionByReplyMessage，MakeSessionByReplyMessage 创建 session 对象并调用 IsSameSession 时未检查 newSession 参数是否为空。关键调用点：MakeSessionByReplyMessage 函数未对 newSession 参数进行空指针检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在 IsSameSession 函数入口处添加对 oldSession 和 newSession 的空指针检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/dbinder_service/src/dbinder_service.cpp", "line": 1072, "evidence": "|| (oldSession->serviceName != newSession->serviceName)) {", "confidence": 0.6, "severity": "high", "gid": 4718, "verify": "oldSession/newSession指针在解引用前必须非空", "has_risk": true, "preconditions": "传入的 newSession 参数为 null", "trigger_path": "调用路径推导：MakeSessionByReplyMessage() -> IsSameSession()。数据流：replyMessage 通过 OnRemoteReplyMessage 接收并传递给 MakeSessionByReplyMessage，MakeSessionByReplyMessage 创建 session 对象并调用 IsSameSession 时未检查 newSession 参数是否为空。关键调用点：MakeSessionByReplyMessage 函数未对 newSession 参数进行空指针检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在 IsSameSession 函数入口处添加对 oldSession 和 newSession 的空指针检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/dbinder_service/src/dbinder_service.cpp", "line": 1072, "evidence": "|| (oldSession->serviceName != newSession->serviceName)) {", "confidence": 0.6, "severity": "high", "gid": 4719, "verify": "oldSession/newSession指针在解引用前必须非空", "has_risk": true, "preconditions": "传入的 newSession 参数为 null", "trigger_path": "调用路径推导：MakeSessionByReplyMessage() -> IsSameSession()。数据流：replyMessage 通过 OnRemoteReplyMessage 接收并传递给 MakeSessionByReplyMessage，MakeSessionByReplyMessage 创建 session 对象并调用 IsSameSession 时未检查 newSession 参数是否为空。关键调用点：MakeSessionByReplyMessage 函数未对 newSession 参数进行空指针检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在 IsSameSession 函数入口处添加对 oldSession 和 newSession 的空指针检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/dbinder_service/src/dbinder_service.cpp", "line": 1075, "evidence": "if (strncmp(oldSession->deviceIdInfo.fromDeviceId, newSession->deviceIdInfo.fromDeviceId, DEVICEID_LENGTH) != 0", "confidence": 0.6, "severity": "high", "gid": 4720, "verify": "oldSession/newSession指针在解引用前必须非空", "has_risk": true, "preconditions": "传入的 newSession 参数为 null", "trigger_path": "调用路径推导：MakeSessionByReplyMessage() -> IsSameSession()。数据流：replyMessage 通过 OnRemoteReplyMessage 接收并传递给 MakeSessionByReplyMessage，MakeSessionByReplyMessage 创建 session 对象并调用 IsSameSession 时未检查 newSession 参数是否为空。关键调用点：MakeSessionByReplyMessage 函数未对 newSession 参数进行空指针检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在 IsSameSession 函数入口处添加对 oldSession 和 newSession 的空指针检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/dbinder_service/src/dbinder_service.cpp", "line": 1075, "evidence": "if (strncmp(oldSession->deviceIdInfo.fromDeviceId, newSession->deviceIdInfo.fromDeviceId, DEVICEID_LENGTH) != 0", "confidence": 0.6, "severity": "high", "gid": 4721, "verify": "oldSession/newSession指针在解引用前必须非空", "has_risk": true, "preconditions": "传入的 newSession 参数为 null", "trigger_path": "调用路径推导：MakeSessionByReplyMessage() -> IsSameSession()。数据流：replyMessage 通过 OnRemoteReplyMessage 接收并传递给 MakeSessionByReplyMessage，MakeSessionByReplyMessage 创建 session 对象并调用 IsSameSession 时未检查 newSession 参数是否为空。关键调用点：MakeSessionByReplyMessage 函数未对 newSession 参数进行空指针检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在 IsSameSession 函数入口处添加对 oldSession 和 newSession 的空指针检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/dbinder_service/src/dbinder_service.cpp", "line": 1076, "evidence": "|| strncmp(oldSession->deviceIdInfo.toDeviceId, newSession->deviceIdInfo.toDeviceId, DEVICEID_LENGTH) != 0) {", "confidence": 0.6, "severity": "high", "gid": 4722, "verify": "oldSession/newSession指针在解引用前必须非空", "has_risk": true, "preconditions": "传入的 newSession 参数为 null", "trigger_path": "调用路径推导：MakeSessionByReplyMessage() -> IsSameSession()。数据流：replyMessage 通过 OnRemoteReplyMessage 接收并传递给 MakeSessionByReplyMessage，MakeSessionByReplyMessage 创建 session 对象并调用 IsSameSession 时未检查 newSession 参数是否为空。关键调用点：MakeSessionByReplyMessage 函数未对 newSession 参数进行空指针检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在 IsSameSession 函数入口处添加对 oldSession 和 newSession 的空指针检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "dbinder/dbinder_service/src/dbinder_service.cpp", "line": 1076, "evidence": "|| strncmp(oldSession->deviceIdInfo.toDeviceId, newSession->deviceIdInfo.toDeviceId, DEVICEID_LENGTH) != 0) {", "confidence": 0.6, "severity": "high", "gid": 4723, "verify": "oldSession/newSession指针在解引用前必须非空", "has_risk": true, "preconditions": "传入的 newSession 参数为 null", "trigger_path": "调用路径推导：MakeSessionByReplyMessage() -> IsSameSession()。数据流：replyMessage 通过 OnRemoteReplyMessage 接收并传递给 MakeSessionByReplyMessage，MakeSessionByReplyMessage 创建 session 对象并调用 IsSameSession 时未检查 newSession 参数是否为空。关键调用点：MakeSessionByReplyMessage 函数未对 newSession 参数进行空指针检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在 IsSameSession 函数入口处添加对 oldSession 和 newSession 的空指针检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "type_safety", "pattern": "reinterpret_cast_unsafe", "file": "dbinder/dbinder_service/src/dbinder_service.cpp", "line": 1352, "evidence": "IPCObjectProxy *callbackProxy = reinterpret_cast<IPCObjectProxy *>(proxy.GetRefPtr());", "confidence": 0.7999999999999999, "severity": "high", "gid": 4783, "verify": "验证reinterpret_cast转换是否安全，确保源指针和目标类型兼容", "has_risk": true, "preconditions": "proxy对象不是IPCObjectProxy类型", "trigger_path": "调用路径推导：NoticeCallbackProxy() -> ProcessCallbackProxy() -> ProcessCallbackProxyInner()。数据流：noticeProxy_存储的IRemoteObject指针通过ProcessCallbackProxy传递到ProcessCallbackProxyInner。关键调用点：ProcessCallbackProxyInner()未验证proxy对象是否为IPCObjectProxy类型。", "consequences": "类型不匹配导致未定义行为，可能引发程序崩溃或内存损坏", "suggestions": "1. 使用dynamic_cast进行安全类型转换 2. 添加类型验证方法 3. 修改设计避免危险类型转换", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "interfaces/innerkits/rust/src/remote/wrapper.rs", "line": 134, "evidence": "let file = unsafe { File::from_raw_fd(fd) };", "confidence": 0.8, "severity": "high", "gid": 4837, "verify": "验证unsafe块中的操作是否安全，特别是原始指针操作和资源管理", "has_risk": true, "preconditions": "传入的fd是无效的或已被关闭的文件描述符，或者调用者继续使用该fd", "trigger_path": "调用路径推导：外部调用者 -> dump() -> unsafe块。数据流：文件描述符fd由外部调用者传入，直接传递给File::from_raw_fd()。关键调用点：dump()函数未对fd有效性进行校验。", "consequences": "可能导致文件描述符错误使用或双重释放", "suggestions": "1. 添加文档说明调用者必须转移fd所有权；2. 考虑使用OwnedFd类型代替原始fd；3. 添加fd有效性检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "rust", "category": "unsafe_usage", "pattern": "get_unchecked", "file": "interfaces/innerkits/rust/src/remote/wrapper.rs", "line": 127, "evidence": "let mut data = MsgParcel::from_ptr(data.get_unchecked_mut() as *mut MessageParcel);", "confidence": 0.8, "severity": "high", "gid": 4840, "verify": "验证get_unchecked_mut调用前是否确保索引有效", "has_risk": true, "preconditions": "外部调用者传入无效的MessageParcel指针", "trigger_path": "调用路径推导：外部FFI调用 -> RemoteStubWrapper::on_remote_request() -> get_unchecked_mut()。数据流：MessageParcel指针通过FFI接口传入，直接传递给get_unchecked_mut()使用。关键调用点：FFI边界处未对指针有效性进行检查，Rust侧直接使用unsafe操作。", "consequences": "可能导致无效内存访问、数据损坏或程序崩溃", "suggestions": "1. 在FFI边界添加指针有效性检查；2. 使用安全方法替代get_unchecked_mut；3. 添加输入参数校验", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "rust", "category": "unsafe_usage", "pattern": "get_unchecked", "file": "interfaces/innerkits/rust/src/remote/wrapper.rs", "line": 128, "evidence": "let mut reply = MsgParcel::from_ptr(reply.get_unchecked_mut() as *mut MessageParcel);", "confidence": 0.8, "severity": "high", "gid": 4841, "verify": "验证get_unchecked_mut调用前是否确保索引有效", "has_risk": true, "preconditions": "外部调用者传入无效的MessageParcel指针", "trigger_path": "调用路径推导：外部FFI调用 -> RemoteStubWrapper::on_remote_request() -> get_unchecked_mut()。数据流：MessageParcel指针通过FFI接口传入，直接传递给get_unchecked_mut()使用。关键调用点：FFI边界处未对指针有效性进行检查，Rust侧直接使用unsafe操作。", "consequences": "可能导致无效内存访问、数据损坏或程序崩溃", "suggestions": "1. 在FFI边界添加指针有效性检查；2. 使用安全方法替代get_unchecked_mut；3. 添加输入参数校验", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "interfaces/innerkits/rust/src/remote/obj.rs", "line": 69, "evidence": "pub unsafe fn new_unchecked(wrap: UniquePtr<IRemoteObjectWrapper>) -> Self {", "confidence": 0.8, "severity": "high", "gid": 4842, "verify": "验证unsafe函数是否正确地处理了不安全操作并有适当的边界检查", "has_risk": true, "preconditions": "调用者传入未经校验的UniquePtr<IRemoteObjectWrapper>指针", "trigger_path": "调用路径推导：外部代码可直接调用new_unchecked()。数据流：调用者直接传入UniquePtr参数。关键调用点：函数内部未对UniquePtr进行null检查。", "consequences": "可能导致空指针解引用或无效内存访问", "suggestions": "1) 添加参数null检查；2) 限制该函数只能被内部安全代码调用；3) 提供安全封装函数替代直接调用", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "interfaces/innerkits/rust/src/parcel/msg.rs", "line": 236, "evidence": "unsafe { Ok(File::from_raw_fd(fd)) }", "confidence": 0.8, "severity": "high", "gid": 4991, "verify": "验证unsafe块中的操作是否有必要的安全保证和边界检查", "has_risk": true, "preconditions": "传入无效的文件描述符(fd)", "trigger_path": "调用路径推导：read_file() -> from_raw_fd()。数据流：通过ReadFileDescriptor()获取fd后直接传递给from_raw_fd()。关键调用点：read_file()函数未对fd的有效性进行检查。", "consequences": "可能导致文件描述符泄漏或未定义行为", "suggestions": "检查fd有效性后再调用from_raw_fd()，或使用推荐的read_raw_fd()替代", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "rust", "category": "concurrency", "pattern": "unsafe_impl_Send_or_Sync", "file": "interfaces/innerkits/rust/src/parcel/msg.rs", "line": 46, "evidence": "unsafe impl Send for MsgParcel {}", "confidence": 0.8, "severity": "high", "gid": 5023, "verify": "验证unsafe Send实现是否确实可以安全地跨线程发送", "has_risk": true, "preconditions": "MsgParcel对象被跨线程共享，且内部包含未同步的原始指针或文件描述符", "trigger_path": "调用路径推导：任何线程创建函数 -> 线程入口函数 -> 使用MsgParcel对象。数据流：MsgParcel对象通过线程参数或共享变量传递给其他线程。关键调用点：MsgParcel的Send实现未验证内部ParcelMem枚举的所有变体是否满足线程安全要求。", "consequences": "可能导致数据竞争、内存不安全或资源泄漏", "suggestions": "1) 确保ParcelMem的所有变体都是线程安全的 2) 或者改为使用Arc<Mutex<MsgParcel>>等同步机制", "verification_notes": "未进行二次验证（--no-verification）"}
