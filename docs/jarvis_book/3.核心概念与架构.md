# 3. 核心概念与系统架构

本章将深入探讨 Jarvis 的核心概念，并解释它们如何组合成一个有机的、可扩展的系统。我们将首先独立介绍每一个核心概念，然后通过架构图和工作流来展示它们如何协同工作。

## 3.1 核心概念

要深入了解并有效使用 Jarvis，理解其背后的几个核心概念至关重要。本节将介绍构成 Jarvis 系统的六大基石：**代理（Agent）**、**工具(Tool)**、**平台(Platform)**、**模型(Model)**、**方法论（Methodology）**和**记忆系统（Memory System）**。

### 3.1.1 代理 (Agent)

**代理(Agent)** 是 Jarvis 的"大脑"和执行中枢，一个高度灵活的**协调者和调度者**。它本身不包含复杂的业务逻辑，而是通过一个**主循环**来驱动整个工作流：获取能力、请求决策、委托执行、循环迭代。

Agent 的核心设计思想是**委托（Delegation）**。它将具体的执行逻辑（如工具调用）委托给不同的**输出处理器(Output Handler)**。这使得 Agent 的核心与具体能力完全解耦。例如，`ToolRegistry` 就是一个专门处理 `TOOL_CALL` 标签的输出处理器。

### 3.1.2 工具与工具注册表 (Tool & ToolRegistry)

**工具(Tool)** 是 Jarvis 的"双手"，是原子化的、功能单一的可执行单元。

**工具注册表(ToolRegistry)** 是所有工具的管理者。它负责发现、加载和执行工具，并通过三种独立的机制来集成它们：
1.  **内置工具**: 加载项目自带的原生Python工具。
2.  **外部Python工具**: 加载用户在指定目录（如 `~/.jarvis/tools`）下创建的Python工具。
3.  **MCP工具**: 通过模型通信协议（MCP）与外部独立进程通信，以接入该进程提供的工具，这是实现高级扩展的关键技术。

### 3.1.3 平台与平台注册表 (Platform & PlatformRegistry)

**平台(Platform)** 是 Jarvis 与大语言模型（LLM）之间的**桥梁和适配器**。它负责对接不同的 LLM 服务提供商（例如 OpenAI、Kimi、腾讯元宝等），将 Agent 的请求转换为特定服务商的 API 调用，并将响应结果返回给 Agent。在 Jarvis 中，平台被抽象为一个统一的**接口**，屏蔽了不同 LLM 服务商 API 的差异。

**平台注册表(PlatformRegistry)** 负责加载所有可用的平台实现。它通过扫描目录中的 `.py` 文件来加载**原生Python平台**，确保 Agent 能以一致的方式与不同的 LLM 服务商交互。

### 3.1.4 模型 (Model)

**模型(Model)** 是指由**平台**提供的、执行具体思考和文本生成任务的**语言模型引擎**，例如 `gpt-4o`, `moonshot-v1-8k` 等。模型是 Jarvis 智能的核心来源。

平台和模型是**提供者**与**产品**的关系。Jarvis 的设计将两者清晰地分开，允许用户通过配置文件在同一平台下轻松切换不同的模型。

### 3.1.5 方法论与中心方法论库

**方法论 (Methodology)** 是 Jarvis 实现"智能进化"的核心机制。它是一套结构化的、用于指导代理解决问题的"思维框架"或"最佳实践"。它定义了代理在面对任务时应该"如何思考"，从而影响它发送给 LLM 的 Prompt 内容，以产生更优的决策。

**中心方法论库 (Central Methodology Repository)** 是一个基于 Git 的共享知识库。它允许用户和团队将个人沉淀的有效方法论分享到一个中心化的 Git 仓库中。通过简单的 `git pull/push`，团队成员之间可以轻松同步和分发这些宝贵的经验，加速整个团队解决问题的能力。这一设计不仅促进了知识的复用，也构建了一个持续学习和演进的集体智慧网络。

### 3.1.6 记忆系统 (Memory System)

**记忆系统 (Memory System)** 是 Jarvis 实现"知识积累"和"经验复用"的重要机制。它为 Agent 提供了持久化存储和检索信息的能力，使得系统能够在不同的任务和会话之间共享和复用知识。

记忆系统包含三种类型的记忆：

1. **短期记忆 (Short-term Memory)**: 存储在内存中的临时信息，主要用于当前任务的上下文保持。这些记忆在任务结束后会被清除。

2. **项目长期记忆 (Project Long-term Memory)**: 与特定项目相关的持久化信息，存储在项目目录的 `.jarvis/memory` 下。这些记忆包含了项目特定的知识、配置和经验。

3. **全局长期记忆 (Global Long-term Memory)**: 跨项目的通用信息，存储在用户数据目录的 `memory/global_long_term` 下。包括用户偏好、通用知识、最佳实践等。

记忆系统通过三个核心工具实现：
- **save_memory**: 保存信息到指定类型的记忆存储
- **retrieve_memory**: 根据标签或类型检索相关记忆
- **clear_memory**: 清理指定的记忆内容

每条记忆都包含唯一ID、标签列表、内容和时间戳，支持灵活的标签化检索。这种设计使得 Agent 能够快速定位和复用相关知识，提高任务执行的效率和准确性。
此外，若启用 force_save_memory，系统会在对话被总结清理或任务完成等关键节点（事件 BEFORE_HISTORY_CLEAR、TASK_COMPLETED）通过事件机制触发记忆保存提示或自动保存逻辑，确保关键信息不会遗漏。


### 3.1.7 任务规划器（Planner / TaskPlanner）

任务规划器是负责将复杂用户任务分解为可执行子任务的智能规划组件。它通过递归分析任务结构和依赖关系，生成结构化的执行计划，帮助Agent更有效地协调和执行任务。

- 核心职责：
  - 任务分解：将高层目标拆分为清晰的子任务
  - 依赖分析：识别子任务之间的依赖关系和执行顺序
  - 计划生成：创建包含并行性、终止条件、回退策略的结构化计划
  - 子任务调度：创建适当的子Agent（sub_agent/sub_code_agent）来执行具体的子任务
  - 结果汇总：收集子任务执行结果并生成 <RESULT_SUMMARY>
  - 规划质量控制：与方法论系统和记忆系统交互，提升规划质量

- 输入输出：
  - 输入：用户任务描述、上下文信息、当前深度（不超过 JARVIS_PLAN_MAX_DEPTH 限制）
  - 输出（写回父 Agent 会话上下文，用于后续主循环继续处理）：
    - 规划块：<PLAN> … </PLAN>（YAML 列表，子任务清单）
    - 子任务结果块：<SUB_TASK_RESULTS> … </SUB_TASK_RESULTS>
    - 结果汇总块：<RESULT_SUMMARY> … </RESULT_SUMMARY>

- 交互关系：
  - 与主 Agent 协同工作，在启用 --plan 时被调用
  - 可访问工具注册表评估工具能力
  - 委托子Agent执行子任务

- 技术实现：
  - 核心组件：TaskPlanner 类（位于 `src/jarvis/jarvis_agent/task_planner.py`）
  - 与 TaskAnalyzer 紧密协作，支持任务分析方法论
  - 配置支持：通过 CLI 开关 `--plan/--no-plan` 控制启用状态
  - 规划深度限制：由 `JARVIS_PLAN_MAX_DEPTH` 环境变量控制（默认值 3）

- 产出结构示例：
  - 规划块（PLAN）：严格为 YAML 列表，仅包含字符串项
    <PLAN>
    - 分析当前任务，提取需要修改的文件列表
    - 修改配置默认值并更新相关 schema
    - 更新文档中对该默认值的描述
    </PLAN>
  - 结果块（SUB_TASK_RESULTS）：按子任务顺序记录执行详情
    <SUB_TASK_RESULTS>
    - 子任务1: 分析当前任务，提取需要修改的文件列表
      结果: ...
    - 子任务2: 修改配置默认值并更新相关 schema
      结果: ...
    - 子任务3: 更新文档中对该默认值的描述
      结果: ...
    </SUB_TASK_RESULTS>
  - 汇总块（RESULT_SUMMARY）：面向后续整合的简要结论
    <RESULT_SUMMARY>
    …要点式总结，包含已完成项、遗留风险与下一步建议…
    </RESULT_SUMMARY>

- 容错与回退：
  - 当模型返回 `<DONT_NEED/>` 或无法解析出有效的 <PLAN> YAML 列表时，Planner 认为“无需拆分”，直接返回不修改上下文。
  - 子任务执行失败时，仍记录失败原因并继续后续子任务，确保整体流程可推进。
  - 汇总生成失败不影响主流程，将以占位的 <RESULT_SUMMARY> 继续。

- 典型工作流：
  1. Agent 接收用户任务。
  2. 启用 --plan 时，Agent 委托 TaskPlanner 生成执行计划。
  3. TaskPlanner 使用临时模型评估是否需要拆分：
     - 需要拆分：严格输出 <PLAN> … </PLAN>，内部为 YAML 列表；
     - 不需要拆分：仅输出 `<DONT_NEED/>`。
  4. 当存在 <PLAN> 时，TaskPlanner 依序为每个子任务创建子 Agent，并基于“原始任务 + 规划清单 + 前置子任务结果”执行当前子任务。
  5. TaskPlanner 记录每个子任务的执行结果，形成 <SUB_TASK_RESULTS> 块。
  6. TaskPlanner 使用临时模型对所有子任务结果进行简要汇总，生成 <RESULT_SUMMARY>。
  7. TaskPlanner 将 <PLAN>、<SUB_TASK_RESULTS>、<RESULT_SUMMARY> 合并写回父 Agent 的会话上下文（session.prompt），随后由主运行循环继续完成最终整合与输出。

- 设计要点：
  - 结构化标签：通过 <PLAN>/<SUB_TASK_RESULTS>/<RESULT_SUMMARY> 明确阶段性产物，便于下游处理与审计。
  - 幂等与可回退：规划失败或无需拆分时，不对上下文做任何修改，主循环按常规路径继续。
  - 可扩展性：子任务执行器使用与父 Agent 相同的类构造参数，便于继承行为与共享能力。

## 3.2 系统架构

本节在"核心概念"的基础上，深入探讨这些概念如何组合成一个有机的、可扩展的系统。

### 3.2.1 架构关系图

下图清晰地展示了 Jarvis 各核心组件之间的静态关系和依赖。
图中已包含 EventBus（事件总线）、PromptManager（提示管理器）、SessionManager（会话管理器）等配套组件，具体见 3.3 节。

```plantuml
@startuml
!theme vibrant

title Jarvis 系统架构

package "用户交互层 (User Interaction Layer)" #AliceBlue {
    actor 用户 as User
    [CLI 入口\n(jvs, jca, ...)] as CLI
}

package "Jarvis 应用程序" #LightGreen {
    node "代理" {
        [运行循环\n(AgentRunLoop)]
        [输出处理器]
        [提示管理器]
        [会话管理器]
        [事件总线]
        [工具执行器]
        [用户交互封装]

        [记忆管理器]
        [任务分析器]
        [任务规划器]
        [文件方法论管理器]
    }

    node "注册表" {
        [工具注册表]
        [平台注册表]
    }
}

package "可插拔能力" #Orange {
    package "工具" {
        [内置工具]
        [外部 .py 工具]
        [MCP 工具]
        [中心工具库 (Git)] as CentralTool
    }
    package "平台" {
        [原生 .py 平台]
    }
    package "知识" {
        [本地方法论] as LocalMethodology
        [中心方法论库 (Git)] as CentralMethodology
    }
    package "记忆系统" {
        [短期记忆\n(内存)] as ShortMem
        [项目长期记忆\n(.jarvis/memory)] as ProjMem
        [全局长期记忆\n(~/.jarvis/data/memory)] as GlobalMem
        [记忆工具\n(保存/检索/清除)] as MemTools
    }
}

package "基础设施层 (Infrastructure Layer)" #LightGrey {
    database "外部系统" as ExternalSystem
}

cloud "LLM 服务" {
    [OpenAI API]
    [Kimi API]
    [腾讯元宝 API]
    [其他 LLM API]
}

User --> CLI
CLI --> 代理 : 分派任务

代理 --> 工具注册表 : 使用
代理 --> 平台注册表 : 使用
代理 --> [运行循环\n(AgentRunLoop)] : 委派运行
代理 --> [提示管理器] : 构建系统/附加提示
代理 --> [会话管理器] : 管理对话/上下文
代理 --> [事件总线] : 广播事件
代理 --> [工具执行器] : 执行工具调用
代理 --> [任务规划器] : 规划与调度
[任务规划器] ..> 工具注册表 : 评估工具能力
[工具执行器] --> 工具注册表 : 解析与分发

工具注册表 --> [内置工具] : 加载
工具注册表 --> [外部 .py 工具] : 加载
工具注册表 --> [MCP 工具] : 通过 MCP 加载
[外部 .py 工具] <--> CentralTool : 分享/同步（经 ShareManager）

平台注册表 --> [原生 .py 平台] : 加载

代理 --> [原生 .py 平台] : 发送提示词
[原生 .py 平台] --> [OpenAI API] : 适配并调用
[原生 .py 平台] --> [Kimi API] : 适配并调用
[原生 .py 平台] --> [腾讯元宝 API] : 适配并调用
[原生 .py 平台] --> [其他 LLM API] : 适配并调用

[内置工具] --> ExternalSystem
[外部 .py 工具] --> ExternalSystem
[MCP 工具] ..> "外部进程" : 委托

[文件方法论管理器] --> LocalMethodology : 读取
LocalMethodology <--> CentralMethodology : 同步

[记忆管理器] --> MemTools : 管理
MemTools --> ShortMem : 访问
MemTools --> ProjMem : 访问
MemTools --> GlobalMem : 访问

代理 --> [记忆管理器] : 使用
代理 --> [任务分析器] : 使用
代理 --> [文件方法论管理器] : 使用
工具注册表 --> MemTools : 加载

@enduml
```

#### 角色职责

- 代理（Agent）
  - 系统协调中心，负责初始化与组装各组件（EventBus、MemoryManager、TaskAnalyzer、FileMethodologyManager、PromptManager、SessionManager、输出处理器等）
  - 将主运行循环委派给 AgentRunLoop，聚焦高层编排与状态管理
  - 统一设置系统提示词（通过 PromptManager），并在首次运行时按需进行工具筛选与方法论/文件处理
  - 通过 ToolRegistry 调用工具，通过 PlatformRegistry 访问平台/模型
  - 使用事件常量广播关键事件（TASK_STARTED/BEFORE_MODEL_CALL/AFTER_MODEL_CALL/BEFORE_TOOL_CALL/AFTER_TOOL_CALL/BEFORE_HISTORY_CLEAR/AFTER_HISTORY_CLEAR/AFTER_SUMMARY/TASK_COMPLETED 等）

- 运行循环（AgentRunLoop）
  - 承载主循环逻辑：调用模型、解析并执行工具、处理中断、驱动下一步
  - 使用 LoopAction 表达跳过当前轮（skip_turn）、继续（continue）、完成（complete）
  - 使用 utils.join_prompts 安全拼接提示：仅拼接非空片段，并以两个换行分隔
  - 使用 utils.normalize_next_action 规范化下一步动作（兼容 Enum 与字符串）
  - 输入处理器控制：根据 run_input_handlers_next_turn 标志决定下一轮是否运行输入处理器，并在触发后清除该标志，避免重复执行
  - 处理自动完成：当开启 auto_complete 且检测到 ot('!!!COMPLETE!!!') 或回退至字面量 '!!!COMPLETE!!!' 时直接收尾
  - 在工具调用与模型调用等关键节点通过 EventBus 广播事件（使用事件常量，如 BEFORE_TOOL_CALL/AFTER_TOOL_CALL），并在工具调用后支持 after_tool_call_cb 回调；事件载荷：BEFORE_TOOL_CALL 包含 agent/current_response；AFTER_TOOL_CALL 包含 agent/current_response/need_return/tool_prompt
  - 失败兜底：主循环对异常进行捕获，使用 PrettyOutput 输出错误并返回 "Task failed: ..."

- 提示管理器（PromptManager）
  - 构建系统提示词（拼装系统指令与工具使用提示）
  - 构建默认附加提示（整合工具使用规范与记忆提示）
  - 仅做字符串拼装，不直接访问模型，保持与现有行为一致

- 会话管理器（SessionManager）
  - 管理 prompt、addon_prompt、conversation_length、用户数据
  - 提供 save/restore/clear_history 能力，持久化路径位于 .jarvis/saved_session_*.json
  - clear_history 重置模型状态但保留系统提示的约束环境

- 事件总线（EventBus）
  - 提供 subscribe/emit/unsubscribe 的轻量同步事件机制
  - 回调异常隔离，避免影响主流程，便于旁路扩展能力（如记忆保存、任务分析）

- 工具执行器（ToolExecutor / execute_tool_call）
  - 解析模型响应，匹配可处理的输出处理器（默认为 ToolRegistry），强制单操作约束
  - 支持执行前确认（execute_tool_confirm），执行并返回结果或错误信息
  - 将“是否直接返回结果”与“下一步提示”统一为标准返回协议

- 配置（AgentConfig）
  - 使用数据类聚合初始化参数，负责解析默认值（use_methodology/use_analysis/execute_tool_confirm/force_save_memory/max_token_count 等）
  - 当存在 files 时默认禁用 use_methodology，确保行为合理
  - 解析结果回填到 Agent 保持向后兼容

- 用户交互封装（UserInteractionHandler）
  - 对多行输入函数做兼容封装（支持 func(tip, print_on_empty) 与 func(tip) 两种签名）
  - 对确认函数做统一封装，便于未来替换为 TUI/WebUI

- 工具注册表（ToolRegistry）
  - 统一发现、加载与执行工具：内置工具、外部 .py 工具、MCP 工具
  - 作为默认输出处理器接收工具调用请求并执行具体工具

- 平台注册表与平台（PlatformRegistry / BasePlatform）
  - 动态创建平台实例、设置模型名称与模型组、适配不同厂商 API
  - 提供 chat_until_success、set_system_prompt、upload_files/save/restore 等能力

- 记忆管理器（MemoryManager）
  - 准备记忆标签提示、在附加提示中注入记忆相关引导
  - 自动记忆保存：在开启 force_save_memory 时于 before_history_clear/task_completed 等事件触发保存逻辑
  - 与工具 save_memory/retrieve_memory/clear_memory 协作，沉淀与复用知识

- 文件与方法论管理器（FileMethodologyManager）
  - 根据平台能力选择文件上传模式或本地模式
  - 负责方法论的上传或本地加载，以及在上下文过长时以文件方式上传历史

- 任务分析器（TaskAnalyzer）
  - 在任务完成阶段基于事件旁路执行分析（如满意度收集、方法论沉淀），不阻塞主流程

- 输出处理器（Output Handler）
  - 一个可扩展的处理器链，默认包含 ToolRegistry；Agent 将模型响应委派给能处理的处理器，由处理器解析并执行（参见 OutputHandlerProtocol: name/can_handle/prompt/handle）

### 3.2.2 核心架构原则

Jarvis 的架构遵循以下几个核心设计原则：

1.  **代理作为协调中心 (Agent-Centric Coordination)**: 系统的核心是 **Agent**，但它是一个轻量级的**协调者**，其主要职责是驱动主循环，并将具体的任务委托给专门的处理器。

2.  **通过注册表实现解耦 (Decoupling via Registries)**: **ToolRegistry** 和 **PlatformRegistry** 是实现系统可插拔性的关键。Agent 不直接与任何具体的工具或平台耦合，它只与注册表交互。

3.  **基于委托的执行模式 (Delegation-Based Execution)**: Agent 接收到来自 LLM 的响应后，不会自己去解析，而是将响应传递给一个**输出处理器**列表。这种**委托机制**将"决策"与"执行"完全分离。

4.  **将 LLM 作为可插拔的推理引擎 (LLM as a Pluggable Reasoning Engine)**: **Platform** 作为 Agent 与 LLM 之间的适配层，将不同 LLM 服务商的 API 差异完全封装起来。这使得 Agent 可以用统一的方式向任何 LLM "提问"（发送Prompt）并获得"回答"（决策文本），而无需关心底层是哪个服务商的模型。

5.  **分层的记忆管理 (Hierarchical Memory Management)**: **记忆系统**采用三层架构（短期、项目长期、全局长期），通过标签化管理实现灵活的知识组织。记忆的存储和检索通过统一的工具接口实现，确保了系统的可扩展性和易用性。

### 3.2.3 端到端工作流：一次工具调用的生命周期

下面的流程描述了上述架构原则在一次典型的工具调用中是如何协同工作的：

1.  **任务分派**: 用户通过 **CLI** 启动一个任务，CLI 将其分派给一个配置好的 **Agent**。

2.  **决策请求**: `Agent` 的主循环启动。它向 `ToolRegistry` 请求所有可用工具的描述，然后将用户任务和这份工具清单组合成一个 Prompt，通过 `PlatformRegistry` 获取的**平台**，发送给**模型**(LLM)，请求下一步的行动决策。

3.  **决策返回**: **模型**(LLM) 思考后，决定调用 `read_code` 工具，并返回一个包含 `TOOL_CALL` 指令的文本。

4.  **委托执行**: `Agent` 接收到这段文本，并将其**委托**给能识别 `TOOL_CALL` 标签的 `ToolRegistry` 进行处理。同时，运行循环通过事件总线广播 BEFORE_TOOL_CALL（载荷：`agent`、`current_response`），以便旁路能力感知工具即将执行。

5.  **工具执行**: `ToolRegistry` 解析出工具名称和参数，调用目标工具的 `execute` 方法并返回其执行结果。运行循环从工具调用接口接收标准返回 `(need_return, tool_prompt)`，用于统一后续流程控制与提示拼接。

6.  **结果反馈与循环**: `Agent` 将工具结果整合进上下文：使用 `utils.join_prompts` 将上一轮提示与 `tool_prompt` 按双换行安全拼接；随后通过事件总线广播 AFTER_TOOL_CALL（载荷：`agent`、`current_response`、`need_return`、`tool_prompt`）。若 `need_return=True`，则直接返回当前 `session.prompt` 并结束；否则继续进入新一轮“思考-决策-委托”循环，直到任务最终完成。

## 3.3 核心组件详解

### 3.3.1 Jarvis Agent

`Jarvis Agent` 是系统的指挥中心，负责协调所有操作。它位于 `src/jarvis/jarvis_agent` 模块中，其核心是 `Agent` 类。

#### 主要职责

- **任务理解与规划**: Agent 接收用户输入，并与大型语言模型（LLM）协作，将高级任务分解为一系列具体的、可执行的步骤。
- **工具调用**: 根据规划，Agent 动态选择并调用合适的工具来执行每个步骤。它是模型与工具集之间的桥梁。
- **状态管理**: Agent 维护着整个任务的上下文，包括对话历史、工具执行结果以及任何中间产物。当对话历史过长时，它会自动进行总结以管理上下文长度。
- **人机交互**: Agent 管理与用户的交互循环，接收指令，反馈结果，并根据用户干预调整执行路径。
- **记忆管理**: 通过 `MemoryManager` 管理短期、项目长期和全局长期记忆，实现知识的持久化和复用。
- **任务分析**: 通过 `TaskAnalyzer` 在任务完成后进行分析，提炼方法论和改进建议。
- **文件和方法论处理**: 通过 `FileMethodologyManager` 处理文件上传和方法论加载。

#### 关联组件与内部模块
- EventBus（事件总线）: 提供简单的发布/订阅机制（使用事件常量：BEFORE_MODEL_CALL/AFTER_MODEL_CALL、BEFORE_TOOL_CALL/AFTER_TOOL_CALL、BEFORE_HISTORY_CLEAR/AFTER_HISTORY_CLEAR、TASK_STARTED/TASK_COMPLETED 等，定义于 jarvis.jarvis_agent.events），以旁路方式集成能力，回调异常隔离不影响主流程。
- PromptManager（提示管理器）: 统一构建系统提示与默认附加提示，保持与现有行为一致，并集中注入工具使用规范和记忆提示。
- AgentConfig（配置聚合）: 将 Agent 初始化参数集中到数据类中，解析默认值（use_methodology/use_analysis/execute_tool_confirm/force_save_memory/max_token_count 等），保持向后兼容。
- UserInteractionHandler（用户交互封装）: 对多行输入与确认交互做轻量封装，便于未来替换为 TUI/WebUI。
- TaskManager（任务管理器）: 由 AgentManager 在进入 Agent.run 之前调用，用于加载与选择预定义任务（支持 fzf 选择与编号跳过），并可询问用户补充信息；当追加补充信息时使用 utils.join_prompts 进行提示拼接，保持上下文一致性。
- ToolExecutor（工具执行器）: 通过 `execute_tool_call` 统一解析与执行模型返回的工具调用，支持执行前确认和错误处理；标准返回协议：返回 (need_return, tool_prompt)，当 need_return 为 True 时运行循环直接返回当前 session.prompt，否则将 tool_prompt 使用 utils.join_prompts 拼接到上下文后继续。
- Utils（工具函数）: 提供 join_prompts/is_auto_complete/normalize_next_action 等统一实现：join_prompts 仅拼接非空片段并以两个换行分隔；is_auto_complete 基于 ot('!!!COMPLETE!!!') 检测，异常时回退到字面量 '!!!COMPLETE!!!'；normalize_next_action 将 Enum 映射为其字符串 value，其他类型返回空字符串。
- AgentRunLoop（运行循环）: 将主运行循环逻辑抽离为独立类，Agent._main_loop 仅做委派，便于演进与测试。

#### 初始化流程

Agent 的初始化过程是高度可配置的，包含以下关键步骤：

1. **模型初始化** (`_init_model`):
   - 根据 `model_group` 确定平台和模型
   - 通过 `PlatformRegistry` 创建平台实例
   - 设置模型名称和模型组

2. **会话初始化** (`_init_session`):
   - 创建 `SessionManager` 实例
   - 管理对话历史、用户数据和附加提示

3. **处理器初始化** (`_init_handlers`):
   - 设置输出处理器 (如 `ToolRegistry`)
   - 设置输入处理器 (如 `shell_input_handler`, `builtin_input_handler`)
   - 设置多行输入处理器

4. **配置初始化** (`_init_config`):
   - 设置方法论使用标志 (`use_methodology`)
   - 设置任务分析标志 (`use_analysis`)
   - 设置工具执行确认标志 (`execute_tool_confirm`)
   - 设置记忆强制保存标志 (`force_save_memory`)
   - 设置最大token数 (`max_token_count`)

5. **管理器与总线初始化**:
   - 创建 `EventBus` 实例（先于其他管理器，便于在构造过程中安全订阅事件）
   - 创建 `MemoryManager` 实例
   - 创建 `TaskAnalyzer` 实例
   - 创建 `FileMethodologyManager` 实例
   - 创建 `PromptManager` 实例
   - 设置系统提示词（通过 `PromptManager` 构建并设置到模型）
   - 输出启动统计信息（`show_agent_startup_stats` 展示方法论/工具/记忆等资源概览）

#### 主运行循环 (AgentRunLoop)

主运行循环由 `AgentRunLoop.run` 承载（`Agent._main_loop` 仅委派调用）。其工作流程如下，并在关键节点通过 EventBus 广播事件（如 BEFORE_MODEL_CALL/AFTER_MODEL_CALL、BEFORE_TOOL_CALL/AFTER_TOOL_CALL、BEFORE_HISTORY_CLEAR/AFTER_HISTORY_CLEAR、TASK_STARTED/TASK_COMPLETED 等），以旁路方式接入其他能力：

1. **首次运行处理**:
   - 通过 `FileMethodologyManager` 处理文件上传和方法论加载
   - 准备记忆标签提示
   - 预定义任务选择在 AgentManager 层进行（如有），Agent 首轮不负责加载
   - 工具筛选（按需）: 当可用工具数量超过阈值时（由配置项阈值控制），使用临时模型筛选相关工具并更新系统提示词，以降低工具集合规模、提升决策效率

2. **模型调用** (`_call_model`):
   - 处理输入处理器链
   - 管理对话长度，必要时进行总结
   - 调用模型并获取响应

3. **工具执行** (`_call_tools`):
   - 通过 `execute_tool_call` 执行工具
   - 处理工具执行结果
   - 执行工具调用后回调

4. **中断处理** (`_handle_run_interrupt`):
   - 处理用户中断请求
   - 获取用户补充信息
   - 决定是否继续工具调用
   - 使用 `LoopAction` 标识跳过当前轮次或继续执行（continue/complete），并在检测到待执行工具时征询用户确认

5. **任务完成处理** (`_complete_task`):
   - 收集满意度反馈
   - 进行任务分析 (如果启用)
   - 生成任务总结

6. **循环控制**:
   - 根据用户输入决定继续或完成任务
   - 自动完成检测: 若开启 `auto_complete` 且模型响应中包含 `!!!COMPLETE!!!` 标记，则直接进入任务完成流程

### 3.3.2 工具注册表 (Tool Registry) 详解

`ToolRegistry` (位于 `src/jarvis/jarvis_tools/registry.py`) 是 Jarvis 工具驱动架构的基石。它是一个动态的工具加载器和执行器，负责管理 Agent 可用的所有工具。

#### 动态工具加载

`ToolRegistry` 在初始化时会自动扫描并加载来自多个源的工具：

- **内置工具**: 位于 `src/jarvis/jarvis_tools/` 目录下的核心工具。
- **外部工具**: 用户可以在 `~/.jarvis/tools/` 目录下添加自定义的 Python 工具脚本。
- **MCP 工具**: 通过模型上下文协议（MCP）集成的外部应用或服务。这些工具通过 `~/.jarvis/mcp/` 目录或 `JARVIS_MCP` 配置中的 YAML 配置进行定义。

这种分层加载机制使得核心功能保持稳定，同时为用户提供了极大的灵活性来扩展 Jarvis 的能力。

#### 工具加载概览
ToolRegistry 支持从多来源加载工具（内置、外部 .py、MCP），统一管理与执行，确保使用体验一致。具体的命名约定与配置细节请参考“高级主题”或开发者文档。

#### 工具执行


当 Agent 决定使用一个工具时，`ToolRegistry` 会：
1. 解析模型生成的工具调用请求。
2. 查找已注册的同名工具。
3. 验证并传递参数。
4. 调用工具的 `execute` 方法。
5. 捕获并格式化 `stdout` 和 `stderr`，然后返回给 Agent。

#### 调用与兼容性概览
ToolRegistry 提供统一的工具调用接口并兼容历史实现，确保在不同版本/场景下稳定运行。更详细的协议版本说明与兼容策略请参考“高级主题”或开发者文档。

#### 鲁棒性增强：缺失结束标签的自动补全

- 解析时严格要求工具调用标签必须位于行首：仅当 ot("TOOL_CALL") 和 ct("TOOL_CALL") 都在行首时才匹配为一个完整的调用块。
- 若检测到行首存在起始标签但缺失结束标签，Registry 会尝试在内容末尾自动补全一个行首结束标签后再次解析：
  - 如果补全后 YAML 解析成功，则继续执行该调用，并在工具执行结果前附加一段友好提示，提醒后续调用需包含完整的开始与结束标签。
  - 如果补全后仍解析失败，则返回包含工具系统使用规范（tool_system_guide）的错误信息，指导修正格式。
- 该机制提升了对模型偶发格式缺失的容错能力，但不会放宽对并发多次调用的单次执行约束（检测到多个调用块仍会报错并拒绝执行）。

#### 大输出处理：自动上传或智能截断
- 当工具输出过大可能导致上下文溢出时（基于 is_context_overflow，结合当前 model_group），Registry 进行以下处理：
  1) 若当前平台支持文件上传（upload_files）：
     - 生成当前对话的关键信息总结（generate_summary），随后清理历史（clear_history）以释放上下文。
     - 将工具输出写入临时文件并上传。
     - 返回一段包含“对话总结 + 本次工具调用的 name/arguments/want（YAML 形式）”的提示，引导模型在新的上下文基础上继续任务。
  2) 若平台不支持上传：
     - 对输出进行智能截断，仅保留前 30 行与后 30 行，中间以“...内容太长，已截取前后30行...”标识，最大限度保留关键信息。
- 上述处理对调用方透明，无需额外配置即可获得稳定的长输出处理体验。

#### 执行记录与统计
- 每次工具执行都会通过 StatsManager 计数，供 CLI 显示工具使用统计（如 jarvis_tools.cli 的 stat 命令）。
- 同时以用户数据的形式记录执行的工具：
  - __last_executed_tool__：本轮最后一次执行的工具名
  - __executed_tools__：本轮累计执行的工具名列表
- 这些信息可被记忆系统与分析模块用于更精确的旁路逻辑与提示优化。

### 3.3.3 平台注册表 (Platform Registry) 详解

`PlatformRegistry` (位于 `src/jarvis/jarvis_platform/registry.py`) 负责管理与不同大型语言模型（LLM）平台的交互。它使得 Jarvis 可以无缝切换和使用多个 AI 提供商。

#### 平台抽象

所有平台都必须继承自 `BasePlatform` 类，并实现一套标准接口，如 `chat`, `set_model_name`, `upload_files` 等。这种设计将特定平台的实现细节与 Agent 的核心逻辑解耦。

#### 动态平台加载

与 `ToolRegistry` 类似，`PlatformRegistry` 也会动态加载平台实现：

- **内置平台**: 位于 `src/jarvis/jarvis_platform/` 目录下的官方支持平台。
- **外部平台**: 用户可以在 `~/.jarvis/models/` 目录下添加自定义的平台适配器。

这使得社区可以方便地为 Jarvis 贡献对新 LLM 平台的支持。

### 3.3.4 记忆系统概览

记忆系统为 Agent 提供短期、项目长期、全局长期三层记忆，用于在多轮对话与不同任务之间复用知识，提升决策的连贯性与效率。主要能力：
- 保存：在关键节点将有价值的信息持久化，便于后续复用
- 检索：按类型与标签快速筛选并获取相关记忆
- 清理：按需清空或整理指定范围的记忆

默认行为：
- 在任务开始、上下文清理前、任务完成等时机提示保存关键信息，尽可能减少遗漏
- 记忆以标签组织，便于后续精确检索

具体的使用方法与命令示例，请参考第 4 章“使用指南”的记忆系统部分。

### 3.3.5 任务分析方法论 (Task Analysis Methodology)


**任务分析**由 `TaskAnalyzer` 类实现，位于 `src/jarvis/jarvis_agent/task_analyzer.py`。它提供了以下核心功能：

1. **任务分析** (`analysis_task`):
   - 准备分析提示 (基于 `TASK_ANALYSIS_PROMPT`)
   - 处理分析循环
   - 执行工具调用 (如方法论保存)

2. **满意度反馈收集** (`collect_satisfaction_feedback`):
   - 收集用户对任务完成的满意度
   - 记录用户反馈

3. **分析循环处理** (`_process_analysis_loop`):
   - 调用模型进行分析
   - 处理工具调用
   - 管理分析状态

任务分析在以下场景触发：
- 任务完成时 (如果启用 `use_analysis`)
- 用户明确请求分析时

### 3.3.6 文件和方法论管理 (File & Methodology Management)

**文件和方法论管理**由 `FileMethodologyManager` 类实现，位于 `src/jarvis/jarvis_agent/file_methodology_manager.py`。它提供了以下核心功能：

1. **文件和方法论处理** (`handle_files_and_methodology`):
   - 根据平台能力选择处理模式
   - 支持文件上传模式 (`_handle_file_upload_mode`)
   - 支持本地模式 (`_handle_local_mode`)

2. **方法论上传** (`_handle_methodology_upload`):
   - 上传方法论文件
   - 处理上传失败回退

3. **本地方法论加载** (`_load_local_methodology`):
   - 加载本地方法论
   - 集成记忆标签提示

4. **历史处理** (`handle_history_with_file_upload`):
   - 使用临时文件上传历史对话
   - 管理上下文长度

### 3.3.7 执行流程时序图

下面的时序图展示了核心组件在**初始化**和**任务执行**两个阶段中的交互流程：

#### 初始化阶段 (Initialization Phase)

```plantuml
@startuml
!theme vibrant
title 核心组件交互 - 初始化阶段 (Initialization)

participant "main()" as Main
participant "Agent" as Agent
participant "ToolRegistry" as ToolRegistry
participant "PlatformRegistry" as PlatformRegistry
participant "MemoryManager" as MemoryManager
participant "TaskAnalyzer" as TaskAnalyzer
participant "FileMethodologyManager" as FileMethodologyManager

box "Dynamically Loaded" #LightBlue
    participant "MyTool" as Tool
    participant "MyPlatform" as Platform
end box

== Initialization Phase ==
Main -> Agent : __init__(output_handler=[ToolRegistry()], ...)
activate Agent
Agent -> ToolRegistry : __init__()
activate ToolRegistry
note right of ToolRegistry : Scans `tools` directories
ToolRegistry -> Tool : Discovers and registers
deactivate ToolRegistry

Agent -> PlatformRegistry : Gets global instance
activate PlatformRegistry
note right of PlatformRegistry: Scans `platforms` directories
PlatformRegistry -> Platform : Discovers and registers
deactivate PlatformRegistry

Agent -> Agent : _init_model()
Agent -> Agent : _init_session()
Agent -> Agent : _init_handlers()
Agent -> Agent : _init_config()

Agent -> MemoryManager : __init__()
Agent -> TaskAnalyzer : __init__()
Agent -> FileMethodologyManager : __init__()

Agent -> Agent : Builds system prompt\nwith tool definitions from ToolRegistry
deactivate Agent
@enduml
```

#### 任务执行阶段 (Task Execution Phase)

```plantuml
@startuml
!theme vibrant
title 核心组件交互 - 任务执行阶段 (Execution)

participant "main()" as Main
participant "Agent" as Agent
participant "ToolRegistry" as ToolRegistry
participant "MemoryManager" as MemoryManager
participant "TaskAnalyzer" as TaskAnalyzer
participant "FileMethodologyManager" as FileMethodologyManager
participant "TaskPlanner" as TaskPlanner

box "Dynamically Loaded" #LightBlue
    participant "MyTool" as Tool
end box

== Task Execution Phase ==
Main -> Agent : run("user task")
note over Main: 预定义任务选择（如有）在 AgentManager 层完成，再调用 Agent.run()
activate Agent

Agent -> FileMethodologyManager : handle_files_and_methodology()
Agent -> MemoryManager : prepare_memory_tags_prompt()

' 可选的任务规划步骤（启用 --plan 时）
Agent -> TaskPlanner : maybe_plan_and_dispatch("user task") [可选，--plan]
activate TaskPlanner
note right of TaskPlanner: 当需要拆分时：\n1) 生成 <PLAN>（YAML 列表）\n2) 依序调度子Agent执行子任务\n3) 汇总并写回 <RESULT_SUMMARY>/<SUB_TASK_RESULTS>
TaskPlanner --> Agent : 更新 session.prompt（合并 PLAN/RESULT_SUMMARY/SUB_TASK_RESULTS）
deactivate TaskPlanner

Agent -> Agent : _call_model("user task 或合并后的上下文")
note right of Agent: Abstract call to LLM via a Platform object
Agent -> Agent : _handle_run_interrupt()
note right of Agent: 可广播 INTERRUPT_TRIGGERED；可能 skip_turn 或直接返回

Agent -> ToolRegistry : handle_tool_calls("TOOL_CALL(MyTool, ...)")
activate ToolRegistry
ToolRegistry -> Tool : execute(...)
activate Tool
Tool --> ToolRegistry : {"success": true, "stdout": "..."}
deactivate Tool
ToolRegistry --> Agent : "Tool output string"
Agent -> Agent : after_tool_call_cb(agent) (可选)
deactivate ToolRegistry

Agent -> MemoryManager : prompt_memory_save()
Agent -> TaskAnalyzer : collect_satisfaction_feedback()

Agent -> Agent : _call_model("Tool output string")
note over Agent : Loop continues...
deactivate Agent
@enduml
```







