# 4. 使用指南

本章是 Jarvis 的实用操作手册，将详细介绍主要命令的用法、参数和常见场景示例。

在阅读本章之前，我们建议您先通过 [快速开始](./2.快速开始.md) 了解 Jarvis 的基本安装和配置。

## 4.1 首次运行配置

在您第一次运行任何 `jarvis` 命令之前，需要进行一次简单的配置，以连接到 AI 大模型平台。

### 生成配置文件

首次运行任何 jarvis 命令（例如 `jarvis` 或 `jpm info`），系统会自动在您的用户主目录下创建 `~/.jarvis/` 文件夹，以及一个默认的配置文件 `config.yaml`。

### 编辑配置文件

打开 `~/.jarvis/config.yaml` 文件。您会看到类似如下的结构：

```yaml
# yaml-language-server: $schema=...
JARVIS_PLATFORM: yuanbao
JARVIS_MODEL: deep_seek_v3
# ... 其他配置 ...
ENV:
  YUANBAO_COOKIES: ''
  KIMI_API_KEY: ''
  TONGYI_COOKIES: ''
```

### 填入凭证

Jarvis 默认推荐使用腾讯元宝平台，因为它免费且功能强大。您需要填入其凭证：

1. 登录腾讯元宝网页版。
2. 打开浏览器开发者工具（通常按 F12），切换到"网络(Network)"标签页。
3. 找到任意一个发往 `yuanbao.tencent.com` 的请求，在请求头(Request Headers)中找到 `Cookie` 字段，并复制其完整的值。
4. 将复制的 Cookie 字符串粘贴到 `YUANBAO_COOKIES: ''` 的引号中。

配置完成后，文件应如下所示：
```yaml
# ...
ENV:
  YUANBAO_COOKIES: '复制到此处的长长的Cookie字符串...'
  KIMI_API_KEY: ''
  TONGYI_COOKIES: ''
```

> 如果您希望使用其他平台（如 Kimi、通义或 OpenAI），请相应地填入它们的 `API_KEY` 或 `COOKIES`。

保存文件后，Jarvis 便已配置完成，可以正常使用了。

## 4.2 通用交互技巧

无论您使用哪个 Jarvis 工具，掌握以下交互技巧都将极大提升您的效率。

### 1. 快捷键 (多行输入模式)

在需要您输入多行文本（如 `jvs` 或 `jca` 的交互模式）时，可以使用以下快捷键：

| 快捷键        | 功能                                               |
|---------------|----------------------------------------------------|
| `@`           | 触发“Git 文件模式”的文件/指令补全；若安装 fzf，将弹出 Git 文件选择器。 |
| `#`           | 触发“全量文件模式”的文件补全（排除 .git）；若安装 fzf，将弹出全量文件选择器。 |
| `Tab`         | 在弹出的补全建议列表中进行选择。                   |
| `Enter`       | 在补全列表打开时应用选中项，否则用于换行。         |
| `Ctrl + J`    | 提交您的多行输入，开始执行任务。                   |
| `Ctrl + C`    | 取消当前的输入操作。                               |
| `Ctrl + O`    | 复制AI的上一条回复到系统剪贴板，方便您使用。     |

### 2. 提示词技巧 (Prompting)

编写高质量的提示词是让 Jarvis 发挥最大潜能的关键。

- 明确角色与目标: 在任务开始时，清晰地告诉Jarvis它应该扮演什么角色，以及最终要达成的目标是什么。
  > 例: "你现在是一个资深的运维专家。我的目标是排查并解决一个 Kubernetes Pod 启动失败的问题。"
- 提供上下文与特殊指令 (`@`/`#`): 使用 `@` 或 `#` 符号可以触发强大的上下文补全和快捷指令功能。
  - 提供文件上下文: 输入 `@` 或 `#` 后跟文件名（支持模糊搜索和自动补全），可将文件内容注入到对话中，为 AI 提供充足的分析背景。
    - `@` Git 文件模式：仅在 Git 跟踪的文件中进行补全/选择，列表干净、速度更快。
    - `#` 全量文件模式：在整个工作目录中进行补全/选择，自动排除 `.git`，适合未纳入 Git 的文件。
    - 若系统安装了 fzf，按下 `@`/`#` 会弹出对应的文件选择器；否则使用内置补全列表。
    - 选择后会将路径以单引号包裹插入；若光标前存在以该前导符开头、且不含空格的片段，会被整体替换为所选路径。
    > 例: "请分析 `@./src/main.py` 这个文件中的代码，并找出潜在的性能瓶颈。"
    > 例: "请分析 `#./logs/latest.log` 这个文件中的内容，定位错误栈来源。"
  - 执行特殊指令: 输入 `@` 或 `#` 后，补全菜单还会显示一系列内置指令，用于快速控制对话或执行常用操作。
    > 例: 输入 `'<Summary>'` 并提交，可以要求 Jarvis 对之前的对话进行总结。

    以下是所有可用的内置特殊指令：

    | 指令 | 功能描述 |
    |---|---|
    | `'<Summary>'` | 让 AI 总结当前的对话历史，并将摘要作为新的上下文，这有助于在长对话中保持焦点。 |
    | `'<Clear>'` | 清空当前的对话历史记录，开始一个全新的对话。 |
    | `'<ToolUsage>'` | 显示所有可用工具的列表和详细说明，帮助你了解 AI 能做什么。 |
    | `'<ReloadConfig>'` | 重新加载 Jarvis 的配置文件。如果你在运行时修改了配置，可以使用此指令使其生效。 |
    | `'<SaveSession>'` | 保存当前的对话状态（包括历史记录）。之后可以通过 `jvs --restore-session` 来恢复。 |
    | `'<自定义标签>'` | 你可以在 `~/.jarvis/config.yaml` 中通过 `JARVIS_REPLACE_MAP` 定义自己的标签，用于插入预设的模板文本。这对于重复性的输入非常有用。 |
- 分解复杂任务: 对于复杂的任务，将其分解为更小、更具体的步骤，并引导 Jarvis 逐步完成。

### 3. 人工介入与控制 (Human-in-the-Loop)

Jarvis 的一个核心特性是支持在任务执行的任意阶段进行人工介入。

- 执行前确认: 在执行可能产生影响的操作（如运行脚本、修改文件）之前，Jarvis 会暂停并请求您的确认 `[Y/n]`。这是第一层防护。

- 思考后介入 (`Ctrl+C`): 这是最关键的介入方式。
  - 当 AI 正在“思考”（即大模型正在生成下一步计划）时，您可以随时按下 `Ctrl+C`。
  - Jarvis 不会立即打断模型的思考，而是会等待当前思考步骤完成（即API返回结果）。
  - 在执行模型生成的计划（如调用工具）之前，系统会检测到中断信号，暂停执行并提示您："模型交互期间被中断，请输入用户干预信息："。
  - 这为您提供了一个审查并否决 AI 下一步行动的宝贵机会。您可以输入新指令来纠正它，或直接拒绝它即将执行的工具调用。

- 工具调用裁决: 这是“思考后介入”的具体体现。当您中断了一个即将发生的工具调用时，系统会询问您是否继续处理该工具。这让您拥有对每一步具体操作的最终决定权。

- 强制退出 (多次`Ctrl+C`): 如果您希望立即终止整个 Jarvis 程序，而不想等待当前思考步骤完成，可以快速连续按下 `Ctrl+C` 五次以上（或长按）。这将触发系统的强制退出机制。

### 4. 非交互模式 (自动化)

对于需要在自动化环境（如 CI/CD 流水线、定时任务脚本）中运行 Jarvis 的场景，可以使用 `-n` 或 `--non-interactive` 参数来启用非交互模式。

该模式具有以下特点：

- 无用户提示: 在此模式下，Jarvis 不会提出任何需要用户输入 `[Y/n]` 确认或进行选择的问题。所有交互式环节都会被跳过。
- 强制任务输入: 由于无法在运行时交互式地输入任务，因此必须在启动命令中通过参数（如 `jvs -T "..."`, `jca -r "..."`, `jma -i "..."`）提供初始任务。如果未提供，程序将报错退出。
- 禁用交互功能: 会自动禁用一些纯交互式的功能，例如 `jvs` 启动时检测 Git 仓库并询问是否切换到 `jca` 的功能。
- 脚本执行超时: 为了防止自动化脚本被意外挂起，在非交互模式下，由 `execute_script` 工具执行的脚本默认有 5分钟 的超时限制。

此参数是实现 Jarvis 自动化的关键，适用于所有需要无人值守执行的场景。

---

## 4.3 通用代理 (`jarvis` / `jvs`)

`jvs` 是您的通用AI助手，适用于各种开放式、非特异性的任务。

### 核心能力
-   任务分析与规划: 理解复杂目标并拆解为执行步骤。
-   多工具协同: 智能选择并组合使用文件读写、代码执行、网页搜索等工具。
-   系统交互: 能够执行 Shell 命令与您的操作系统进行交互。
-   预定义任务: 支持从配置文件加载预设任务，简化重复性工作。

### 常用参数
| 参数                | 描述                             |
| ------------------- | -------------------------------- |
| `-T`, `--task`      | 直接从命令行提供初始任务。         |
| `-f`, `--config`    | 指定自定义配置文件的路径。         |
| `-g`, `--llm-group` | 临时指定模型组，覆盖默认配置。 |
| `-G`, `--tool-group`| 临时指定工具组，覆盖默认配置。 |
| `--restore-session` | 从 `.jarvis/saved_session.json` 恢复上一次的会话。 |
| `-e`, `--edit`      | 快速编辑默认的 `~/.jarvis/config.yaml` 配置文件。|
| `--share-methodology` | 分享本地方法论到中心方法论仓库。 |
| `--share-tool`      | 分享本地工具到中心工具仓库。 |
| `-I`, `--interactive-config` | 启动交互式配置向导：在当前配置基础上对所有可选项进行询问，默认值取自现有配置；保存后退出（需手动重新运行以使用新配置；如无配置文件则进入完整引导并退出）。 |
| `-D`, `--disable-methodology-analysis` | 禁用方法论和任务分析（覆盖配置文件设置）。适用于快速直达的指令式对话；等效于将本次会话的 use_methodology/use_analysis 设为 false。 |
| `--backup-data`     | 备份所有 Jarvis 数据（`~/.jarvis`）到 `~/jarvis_backups/` 目录。 |
| `--restore-data <路径>` | 从指定的压缩包恢复 Jarvis 数据。此操作会覆盖现有数据，请谨慎使用。 |
| `-n`, `--non-interactive` | 启用非交互模式，用于自动化脚本。详见“通用交互技巧”章节。 |

### 示例

1. 交互式对话与预定义任务
直接运行 `jvs` 会进入交互模式。如果存在预定义任务文件（`~/.jarvis/pre-command` 或 `./.jarvis/pre-command`），`jvs` 会首先列出这些任务供您选择，极大方便了日常操作的复用。
```bash
# 启动交互式会话，并可能会提示选择预定义任务
jvs
```

2. 直接执行任务
让 Jarvis 分析当前项目结构并生成一份报告。
```bash
jvs -T "分析当前目录下的代码，总结项目的主要模块和功能"
```

3. 解决环境问题
当您遇到一个复杂的环境问题时，可以请求 Jarvis 帮助。
```bash
jvs -T "我的 docker 服务无法启动，请帮我诊断问题并尝试修复。相关日志在 /var/log/docker.log"
```

4. 使用特定工具组
通过 `--tool-group` 参数临时切换到特定的工具集。
```bash
# 使用只读的受限工具组进行代码分析
jvs --tool-group restricted -T "分析这个项目的代码结构"

# 使用文档处理工具组
jvs --tool-group document -T "搜索关于 Python asyncio 的最佳实践"
```

5. 交互式配置（覆盖设置）
在启动前对所有可选项进行交互式确认，默认值取自当前配置；保存后继续启动：
```bash
# 使用默认配置文件进行交互式配置
jvs -I

# 或对指定配置文件进行交互式配置
jvs -I -f ./myconfig.yaml
```

6. 数据备份与恢复
您可以轻松地备份和恢复您的所有 Jarvis 数据，包括配置、记忆、历史记录等。

备份您的数据：
```bash
# 这将在 ~/jarvis_backups/ 目录下创建一个带时间戳的 zip 压缩包
jvs --backup-data
```

从备份恢复数据：
```bash
# 恢复操作会覆盖 ~/.jarvis 目录，请务必小心
# 程序会请求您二次确认
jvs --restore-data ~/jarvis_backups/jarvis_data_20231026_103000.zip
```

### Web 模式（浏览器交互）

Jarvis 支持通过浏览器进行交互式使用，并提供标准输入/输出的实时重定向与控制通道，适合观察执行过程、与交互式命令对话以及日常工作展示。

核心特性：
- 浏览器终端交互：内置 xterm 终端展示输出，支持清屏与自动换行优化。
- STDIO 重定向：后端的标准输出/错误（stdout/stderr）将实时通过独立通道推送到浏览器。
- STDIN 输入：在浏览器终端内输入的按键会注入后端 STDIN，交互式命令（如 Python REPL、某些 CLI）可直接在浏览器中使用。
- 每任务新建 Agent：通过“发送为新任务”提交的每一次任务，系统都会创建一个全新的 Agent 实例处理，任务之间互不干扰。
- 干预与终端尺寸：页面提供“干预”按钮，可向后端发送中断信号；浏览器会上报终端尺寸，后端据此优化输出宽度。
- 后台运行与停止：默认以后台进程方式启动，支持通过 --stop 快速停止，按端口区分多实例。

基本用法：
```bash
# 1) 在本机后台启动 Web 服务（默认 127.0.0.1:8765）
jarvis --web

# 打开浏览器访问
# http://127.0.0.1:8765

# 页面上：
# - 在下方输入区输入任务，点击“发送为新任务”
# - 任务期间输入区会禁用；若 Agent 请求输入或确认，会弹出提示/对话
# - “干预”按钮可发送中断信号（相当于在执行前打断工具调用）
```

常用参数：
```bash
# 指定服务地址与端口（默认 127.0.0.1:8765）
jarvis --web --web-host 0.0.0.0 --web-port 8888

# 停止后台 Web 服务（按端口定位，默认 8765）
jarvis --web --stop
jarvis --web --stop --web-port 8888
```

说明与建议：
- 安全性：默认仅监听本机（127.0.0.1）。如需局域网访问，请使用 --web-host 0.0.0.0，并结合防火墙/反向代理进行访问控制。
- 多实例：不同端口的实例互不影响；每个实例会在 ~/.jarvis 下维护独立的 PID 文件（jarvis_web_{port}.pid）。
- 停止机制：--stop 会优先根据 PID 文件停止；若 PID 文件丢失，也会按端口尝试停止并清理残留 PID 文件。
- 终端体验：浏览器会自动上报终端尺寸到后端，用于动态调整输出宽度，改善表格/换行显示效果。

### 启动前的可选交互

根据配置，`jvs` 在启动前可能会出现以下可选交互行为（默认关闭，可在首次运行时交互启用，或在配置文件中开启）：

1) 列出内置配置供选择（agent/multi_agent/roles）
   - 若开启，会扫描项目内置的 `builtin/agent`、`builtin/multi_agent`、`builtin/roles` 目录，展示可用清单，您可直接选择启动对应命令：
     - 选择 agent 配置将启动 `jarvis-agent -c <文件>`
     - 选择 multi_agent 配置将启动 `jarvis-multi-agent -c <文件>`
     - 选择 roles 配置将启动 `jarvis-platform-manager role -c <文件>`
   - 配置项：`JARVIS_ENABLE_STARTUP_CONFIG_SELECTOR: true`

2) Git 仓库检测并提示切换到代码开发模式（jca）
   - 若开启，且当前目录在 Git 仓库中，启动 `jvs` 时会提示是否切换到 `jca`（jarvis-code-agent），以便获得更好的代码任务体验。
   - 配置项：`JARVIS_ENABLE_GIT_JCA_SWITCH: true`

可在 `~/.jarvis/config.yaml` 中设置：
```yaml
JARVIS_ENABLE_GIT_JCA_SWITCH: false
JARVIS_ENABLE_STARTUP_CONFIG_SELECTOR: false
```

## 4.4 代码代理 (`jarvis-code-agent` / `jca`)

`jca` 是专为软件开发任务设计的代理，是您日常编码、重构和调试的得力助手。

### 核心能力
- 深度代码集成: 自动分析代码库结构、依赖关系和最近的提交历史，为任务提供全面的上下文。
- 自动化 Git 工作流:
  - 自动检查点（预处理）: 进入任务前，如检测到未提交更改，将通过 GitCommitTool 进行一次规范化提交（支持 --prefix/--suffix 自定义），或按配置仅告警继续。
  - 增量式变更（交互式补丁）: 在 AI 的每一步操作（如修改文件）后，都会生成一个包含 `diff` 的补丁，并引导您确认是否将其 commit。
  - 任务后审查（最终归并）: 整个任务完成后将列出本次会话内的提交；您可选择“接受”（系统会先重置回任务起点，然后由 GitCommitTool 生成一条统一且规范的最终提交）或直接重置回任务开始前的状态。
- 静态代码分析: 在生成代码修改后，会自动推荐并可运行 `lint` 工具进行静态分析，以确保代码质量（可由配置项开启/关闭）。

### 常用参数
| 参数                | 描述                             |
| ------------------- | -------------------------------- |
| `-r`, `--requirement` | 提供代码相关的需求描述。           |
| `-g`, `--llm-group` | 临时指定模型组，覆盖默认配置。 |
| `-G`, `--tool-group`| 临时指定工具组，覆盖默认配置。 |
| `--append-tools`    | 追加的工具列表，多个工具用逗号分隔，如: read_webpage,file_analyzer |
| `--restore-session` | 从 `.jarvis/saved_session.json` 恢复上一次的会话。 |
| `--prefix <文本>`   | 为生成的提交信息主题添加前缀（空格分隔，适合任务ID/标记）。 |
| `--suffix <文本>`   | 为生成的提交信息末尾添加后缀（换行后追加，适合签名/审阅者）。 |
| `--rule-names <名称列表>` | 指定规则名称列表，用逗号分隔，从 `rules.yaml` 文件中读取对应的规则内容。详见"项目规则"章节。 |
| `-n`, `--non-interactive` | 启用非交互模式，用于自动化脚本。详见"通用交互技巧"章节。 |

### 示例

1. 添加新功能
在项目中添加一个新功能，`jca` 会自动查找相关文件并进行修改。
```bash
jca -r "在用户认证模块中，增加一个'忘记密码'的功能。需要创建一个新的API端点 /api/forgot-password，并实现发送重置邮件的逻辑。"
```

2. 修复 Bug
根据 Bug 描述修复问题。
```bash
jca -r "修复 src/utils/calculator.py 中的除零错误。当除数为零时，应该返回一个错误提示而不是抛出异常。"
```

3. 代码重构
优化现有代码。
```bash
jca -r "重构 src/services/user_service.py 文件，将其中过长的 'create_user' 方法拆分为多个更小的私有方法，提高代码可读性。"
```

### 项目规则（.jarvis/rules 和 rules.yaml）
为了在团队或项目中统一 AI 修改行为，jca 支持两种方式定义规则：纯文本规则文件和 YAML 格式的命名规则文件。

#### 纯文本规则文件（.jarvis/rules）

- 什么是项目规则
  - 位于项目根目录的纯文本文件：`./.jarvis/rules`
  - 用于约束与指导 CodeAgent 的具体行为（如修改范围、风格规范、工具使用策略等）

- 生效机制
  - jca 启动后会先读取"全局规则"：数据目录中的 `~/.jarvis/rules`（或 `JARVIS_DATA_PATH/rules`），以及"项目规则"：当前仓库 `.jarvis/rules`
  - 系统按"先全局、后项目"的顺序将两者内容进行拼接合并
  - 合并结果以单一的 `<rules>...</rules>` 块注入到系统提示词中；项目规则用于覆盖或补充全局规则，建议在项目规则中明确覆盖条目
  - 注入后将影响"本次会话内"的所有操作与决策

- 适用范围
  - 全局规则：作用于所有项目（存放于数据目录 `~/.jarvis/rules` 或 `JARVIS_DATA_PATH/rules`）
  - 项目规则：仅作用于当前项目仓库（所在 git 根目录）；用于覆盖或补充全局规则

- 建议写法
  - 简洁、明确、可执行，优先使用条目式规则清单
  - 聚焦与当前项目相关的规范，避免冗长背景描述
  - 与团队现有规范（代码风格、提交规范、目录约定）保持一致

- 示例规则文件（`.jarvis/rules`）
  ```
  # 修改范围与约束
  - 仅允许修改 src/ 和 docs/ 目录内文件
  - 禁止创建/删除数据库表与迁移：不得编辑 migrations/、database/schema.sql
  - 对 .env、secrets/*、证书/密钥等敏感文件的一切改动一律拒绝

  # 风格与质量
  - Python 统一使用 Black 与 isort；命名遵循 PEP 8
  - 新增函数必须提供 docstring 与必要的类型标注
  - 复杂变更提供最小可复现示例与必要单元测试

  # 工具与流程
  - 文件编辑优先使用 PATCH；仅在需要整文件重写时使用 REWRITE
  - 任何修改前先使用 read_code 阅读目标文件与上下文
  - 生成补丁后优先一次性执行静态检查（如 flake8/mypy/ruff 等）

  # Git 提交
  - 使用 Angular 提交规范，必须包含 scope
  - 允许使用 --prefix/--suffix 统一注入任务ID与签名
  ```

- 使用步骤
  1) 在项目根目录创建目录与文件：`mkdir -p .jarvis && touch .jarvis/rules`
  2) 将上述或团队自定义的规则写入 `.jarvis/rules`
  3) 提交到仓库，便于团队共享与审阅
  4) 运行 `jca ...`，规则将自动生效；如修改了规则，重新运行 `jca` 以应用最新内容

- 注意事项
  - 空文件不生效；读取失败会被安全忽略（不会阻断任务）
  - 仅在本地项目级生效，不会影响全局；全局偏好可使用"记忆系统"保存
  - 路径与大小写需与项目实际一致；Windows/Linux 路径差异请按实际书写
  - 规则应避免与项目已有工具链冲突（如 pre-commit、格式化器、CI 规范）

#### 命名规则文件（rules.yaml）

除了纯文本规则文件，jca 还支持通过 YAML 格式的命名规则文件来管理多个可复用的规则集合。

- 什么是命名规则文件
  - 全局命名规则文件：位于数据目录 `~/.jarvis/rules.yaml`（或 `JARVIS_DATA_PATH/rules.yaml`）
  - 项目命名规则文件：位于 git 根目录 `./rules.yaml`
  - 文件格式为键值对（YAML），每个键代表一个规则名称，值为规则内容

- 生效机制
  - 当使用 `--rule-name <名称>` 参数时，jca 会读取全局和项目目录下的 `rules.yaml` 文件
  - 系统会合并两个文件的内容（项目配置覆盖全局配置）
  - 如果指定的规则名称存在于合并后的配置中，对应的规则内容会被添加到系统提示词中
  - 命名规则会与纯文本规则（`.jarvis/rules`）一起生效，共同注入到 `<rules>...</rules>` 块中

- 示例规则文件（`rules.yaml`）
  ```yaml
  # 全局规则文件 ~/.jarvis/rules.yaml
  python_best_practices: |
    - Python 代码必须遵循 PEP 8 规范
    - 所有函数必须包含类型注解和 docstring
    - 使用 Black 进行代码格式化
    - 使用 isort 进行导入排序
  
  security_guidelines: |
    - 禁止使用 eval() 和 exec()
    - 所有用户输入必须进行验证和转义
    - 敏感信息不得硬编码在代码中
  
  # 项目规则文件 ./rules.yaml（会覆盖全局同名规则）
  python_best_practices: |
    - Python 代码必须遵循 PEP 8 规范
    - 所有函数必须包含类型注解和 docstring
    - 使用 Black 进行代码格式化
    - 使用 isort 进行导入排序
    - 本项目额外要求：所有异步函数必须使用 asyncio.create_task() 管理任务
  ```

- 使用步骤
  1) 创建全局规则文件（可选）：`touch ~/.jarvis/rules.yaml`
  2) 创建项目规则文件（可选）：在 git 根目录创建 `rules.yaml`
  3) 在 YAML 文件中定义规则，格式为键值对
  4) 运行 `jca --rule-name <规则名称> ...` 来使用指定的规则
  ```bash
  # 使用全局定义的 python_best_practices 规则
  jca --rule-name python_best_practices -r "重构用户认证模块"
  
  # 使用 security_guidelines 规则
  jca --rule-name security_guidelines -r "修复 SQL 注入漏洞"
  ```

- 注意事项
  - 规则名称区分大小写，必须与 YAML 文件中的键完全匹配
  - 如果指定的规则名称不存在，会安全忽略（不会阻断任务）
  - 项目规则文件中的同名规则会覆盖全局规则文件中的规则
  - 规则值可以是多行字符串（使用 YAML 的 `|` 或 `>` 语法）
  - 命名规则与纯文本规则（`.jarvis/rules`）可以同时使用，它们会被合并在一起

### LSP 客户端工具（代码符号分析）

`jca` 内置了强大的 LSP（Language Server Protocol）客户端工具，能够通过符号名称快速获取代码信息，无需提供精确的行列号。这使得 AI 能够更智能地理解和分析代码结构。

#### 核心特性

- **基于符号名称的操作**：所有操作都基于符号名称（函数名、类名、变量名等），无需手动指定行列号
- **多语言支持**：支持 Python、TypeScript、JavaScript、C/C++、Rust、Go、Java 等主流语言
- **智能后备方案**：当 LSP 服务器不可用时，自动降级到 Tree-sitter 进行符号提取
- **自动工作目录检测**：自动检测 LSP 服务器所需的工作目录（如 `Cargo.toml`、`pyproject.toml`、`package.json` 等）

#### 支持的操作

LSP 客户端工具提供以下五种操作：

1. **`get_symbol_info`**：获取符号的完整信息（定义位置、悬停信息、引用数量等）
2. **`search_symbol`**：搜索符号（支持模糊匹配）
3. **`document_symbols`**：获取文件中的所有符号列表
4. **`definition`**：查找符号的定义位置
5. **`references`**：查找符号的所有引用位置

#### 使用场景

LSP 客户端工具在以下场景中特别有用：

- **代码理解**：快速了解函数、类的定义和用途
- **依赖分析**：查找某个符号在项目中的所有引用
- **代码导航**：快速跳转到符号的定义位置
- **重构支持**：在重构前了解符号的使用范围

#### 自动使用

在 `jca` 模式下，AI 会根据任务需求自动使用 LSP 客户端工具。例如：

```bash
# AI 会自动使用 lsp_client 工具来查找相关符号
jca -r "查找所有调用 user_login 函数的地方，并分析其使用模式"
```

#### 支持的 LSP 服务器

| 语言 | LSP 服务器 | 检测命令 |
|------|-----------|---------|
| Python | pylsp | `pylsp --version` |
| TypeScript/JavaScript | typescript-language-server | `typescript-language-server --version` |
| Rust | rust-analyzer | `rust-analyzer --version` |
| Go | gopls | `gopls version` |
| Java | jdtls | `jdtls --version` |
| C/C++ | clangd | `clangd --version` |

#### 安装 LSP 服务器

要使用 LSP 客户端工具，您需要安装对应语言的 LSP 服务器：

**Python (pylsp)**:
```bash
pip install python-lsp-server
```

**TypeScript/JavaScript (typescript-language-server)**:
```bash
npm install -g typescript-language-server typescript
```

**Rust (rust-analyzer)**:
```bash
# 通常随 Rust 工具链一起安装
rustup component add rust-analyzer
```

**Go (gopls)**:
```bash
go install golang.org/x/tools/gopls@latest
```

**Java (jdtls)**:
```bash
# 需要下载 Eclipse JDT Language Server
# 详见：https://github.com/eclipse/eclipse.jdt.ls
```

**C/C++ (clangd)**:
```bash
# Ubuntu/Debian
sudo apt-get install clangd

# macOS
brew install llvm

# 或从 LLVM 官网下载
```

#### 注意事项

- LSP 客户端工具仅在 `jca`（CodeAgent）模式下可用
- 如果 LSP 服务器未安装或不可用，系统会自动使用 Tree-sitter 后备方案
- LSP 客户端会自动缓存连接，提高性能
- 对于大型项目，首次连接可能需要一些时间进行索引

## 4.5 平台管理器 (`jarvis-platform-manager` / `jpm`)

`jpm` 是您与底层大模型平台交互和管理的工具。

### 子命令
- `info`: 列出所有支持的平台和模型。
- `chat`: 与指定的平台和模型进行交互式对话。
- `service`: 将指定的模型以 OpenAI 兼容的 API 形式暴露出来。
- `role`: 加载预定义的角色配置文件，选择角色后进行对话。

### 示例

1. 查看可用模型
```bash
jpm info
```

2. 与特定模型聊天
首先，使用 `jpm info` 查找您想使用的平台和模型名称。然后，通过 `-p` 和 `-m` 参数指定它们来开始对话。
```bash
# 示例：假设您通过 jpm info 查到并想使用 "zhipu" 平台的 "glm-4" 模型
jpm chat -p zhipu -m glm-4
```
在 `chat` 模式中，您还可以使用以下命令：
- `/bye`: 退出对话。
- `/clear`: 清空当前会话历史。
- `/upload <文件路径>`: 上传文件供 AI 分析（需要平台支持）。
- `/shell <命令>`: 在本地执行 Shell 命令。
- `/save <文件名>`: 将 AI 的最后一条回复保存到文件。
- `/saveall <文件名>`: 将整个对话历史保存到文件。
- `/save_session <文件名>`: 保存当前会话状态（可用于后续加载）。
- `/load_session <文件名>`: 加载之前保存的会话状态。

3. 启动本地API服务
将腾讯元宝模型封装为本地 API，供其他应用调用。当客户端请求未指定模型时，将默认使用元宝模型。
```bash
jpm service --host 0.0.0.0 --port 8000 -p yuanbao -m Tencent-HunYuan-Pro
```

4. 加载角色进行对话
使用角色配置文件（默认为 `~/.jarvis/roles.yaml`）来启动一个特定角色的对话。
```bash
# 1. jpm会首先列出 roles.yaml 中定义的所有角色
# 2. 用户选择一个角色后，jpm会使用该角色预设的平台、模型和系统提示开始对话
jpm role

# 你也可以通过参数临时覆盖角色配置中的平台和模型
# 使用 jpm info 查找可用的 platform_name 和 model_name
jpm role -c ./my_roles.yaml -p <platform_name> -m <model_name>
```

## 4.6 Git提交助手 (`jarvis-git-commit` / `jgc`)

`jgc` 能自动分析您的代码变更，并生成符合规范的 Git 提交信息。

### 核心能力
- 自动分析 `git diff`: `jgc` 会自动暂存 (`git add .`) 您工作区中的所有变更，并分析其 `diff` 内容。
- 智能处理大型变更: 如果代码变更非常大，`jgc` 会自动将 `diff` 保存为临时文件并上传，而不是直接注入到提示词中，避免超出模型上下文限制。
- 生成规范的提交信息: 基于代码变更，AI 会生成符合约定式提交规范的提交信息。
- 完全可定制: 您可以通过配置文件自定义 `jgc` 的所有行为，包括提交信息模板和前后缀。

### 常用参数
| 参数 | 描述 |
|---|---|
| `--prefix <文本>` | 在生成的提交信息主题前添加一个固定的前缀。 |
| `--suffix <文本>` | 在生成的提交信息末尾添加一个固定的后缀（换行后追加）。 |
| `--root-dir <路径>` | 指定要操作的 Git 仓库根目录（默认为当前目录）。 |
| `-g/--llm-group <组名>` | 使用的模型组，覆盖配置文件中的设置。 |

### 示例与定制

1. 基本用法
当您完成了一些代码修改后，只需在项目根目录运行：
```bash
# jgc 会自动暂存所有变更，无需手动 git add
jgc
```
Jarvis 将会分析变更，生成一条类似 `feat(auth): add password reset endpoint` 的提交信息，并自动执行 `git commit`。

2. 添加前缀和后缀
如果您希望在提交信息中包含任务ID或特定的标记，可以使用 `--prefix` 和 `--suffix`：
```bash
jgc --prefix "JIRA-123:" --suffix "Reviewed-by: @YourName"
```
生成的提交信息会变成类似：
```
JIRA-123: feat(auth): add password reset endpoint

Reviewed-by: @YourName
```

3. 自定义提交模板 (高级)
`jgc` 最强大的功能之一是允许您完全重写用于生成提交信息的提示词模板。您可以在 `~/.jarvis/config.yaml` 文件中通过设置 `JARVIS_GIT_COMMIT_PROMPT` 变量来定义自己的模板。

首先，通过 `jvs -e` 打开配置文件，然后添加 `JARVIS_GIT_COMMIT_PROMPT` 变量：
```yaml
# ~/.jarvis/config.yaml

# ... 其他配置 ...

JARVIS_GIT_COMMIT_PROMPT: |
  请为以下代码变更生成一条符合【Angular提交规范】的中文提交信息。

  # 规则
  1. 必须包含类型、范围和主题。
  2. 类型只能是：'新功能', '修复', '文档', '格式', '重构', '测试', '构建', '持续集成'。
  3. 范围必须是代码中被修改的模块名。
  4. 详细描述部分要解释修改的原因和带来的好处。

  # 变更内容
  {diff}
```
通过自定义此模板，您可以让 `jgc` 完全遵循您团队的特定提交规范。

## 4.7 本地知识库 (`jarvis-rag` / `jrg`)

`jrg` 用于构建和查询基于您自己文档的本地知识库。

### 工作原理
`jrg` 会读取您指定的文本文件，使用嵌入模型（Embedding Model）将其内容转换为向量，并存储在本地的向量数据库中。当您提问时，它会：
1. 将您的问题也转换为向量。
2. 在数据库中检索与问题向量最相关的文档片段。
3. 将这些文档片段和您的原始问题一起提交给大语言模型（LLM），由 LLM 生成最终的、基于上下文的答案。

### 子命令
- `add`: 添加文档（文件、目录、通配符）到知识库。
- `list-docs`: 列出知识库中的所有文档。
- `retrieve`: 仅从知识库检索相关文档，不生成答案。支持 --rewrite/--no-rewrite 控制查询重写（默认开启）。
- `query`: 向您的知识库提问。

### 核心功能与定制

1. 智能文件过滤
在添加文档时，`jrg` 会自动执行以下操作：
- 递归扫描: 自动遍历您指定的目录。
- 二进制文件检测: 自动跳过图片、可执行文件等非文本内容。
- 忽略规则: 默认情况下，`jrg` 会遵循项目根目录下的 `.gitignore` 规则。为了更精细地控制，您可以在项目根目录创建 `.jarvis/rag/.ragignore` 文件，其优先级高于 `.gitignore`。这对于排除测试数据、大型日志文件或不想被索引的文档非常有用。

2. 构建知识库
`jrg add` 命令支持递归地添加整个目录和多个文件。
```bash
# 添加 src 和 docs 目录，以及根目录的 README.md
# jrg 会自动应用 .gitignore 或 .ragignore 规则
jrg add ./src ./docs README.md
```
您还可以使用 `--collection` 参数来管理多个独立的知识库，例如：
```bash
# 为项目A创建一个专门的知识库
jrg add ./project-a/src --collection project-a-docs

# 为项目B创建另一个知识库
jrg add ./project-b/src --collection project-b-docs
```

3. 查询知识库
使用 `jrg query` 向知识库提问。默认情况下，它会查询名为 `jarvis_rag_collection` 的主知识库。
```bash
jrg query "在我们的项目中，'PlatformRegistry' 这个类是用来做什么的？"
```
如果要查询特定知识库，或使用特定的 LLM（而非默认配置的思考模型）来生成答案，可以使用相应参数：
```bash
# 查询 project-a-docs 知识库，并指定使用 zhipu 平台的 glm-4 模型来生成答案
jrg query --collection project-a-docs -p zhipu -m glm-4 "介绍一下 project-a 的认证流程"
```

4. 仅检索模式（retrieve）
当你只需要查看与问题相关的“检索结果”（文档片段），而不需要由 LLM 生成答案时，使用 `retrieve` 更轻量，适合调试与验证召回质量。

```bash
# 仅检索，不生成答案。默认会对查询做一次 LLM 重写以提升召回
jrg retrieve "如何配置 RAG 的嵌入模型？"

# 禁用查询重写（保持原始查询词）
jrg retrieve --no-rewrite "如何配置 RAG 的嵌入模型？"

# 控制检索条数（默认为 5）
jrg retrieve --top-n 8 "Jarvis RAG 支持的忽略规则是什么？"
```

参数说明：
- --rewrite/--no-rewrite：是否对查询进行 LLM 重写以提升召回，默认开启。
  - 建议在无可用 LLM 平台、离线环境或需要严格保持原始关键字检索时使用 --no-rewrite。
- --top-n：返回的文档数量，默认 5。
- 其他参数与 query 相同：--collection、--embedding-model、--db-path。

输出说明：`retrieve` 会直接打印每条检索到的文档内容及其来源路径（source），不调用 LLM 生成答案。

5. 列出已索引文档
使用 `jrg list-docs` 可以查看指定知识库中包含了哪些源文件。
```bash
jrg list-docs --collection project-a-docs
```

6. 自定义 RAG 模型
`jrg` 默认使用 `BAAI/bge-m3` 作为嵌入模型和 `BAAI/bge-reranker-v2-m3` 作为重排模型。您可以通过 `config.yaml` 文件来覆盖这些默认设置，以使用更适合您数据或硬件的模型。

例如，要切换到 `moka-ai/m3e-base` 嵌入模型，可以这样配置：
```yaml
# ~/.jarvis/config.yaml

# ... 其他配置 ...

JARVIS_RAG:
  embedding_model: "moka-ai/m3e-base"
  # 如果您也想更换重排模型，可以在这里添加 rerank_model 键
  # rerank_model: "some-other-reranker"
  use_bm25: true  # 是否启用 BM25 稀疏检索，默认为 true
  use_rerank: true # 是否启用重排模型，默认为 true
```
这个配置会让 `jrg` 在下一次构建或查询知识库时使用您指定的新模型。

与模型配置类似，RAG 也支持通过 `JARVIS_RAG_GROUPS` 和 `JARVIS_RAG_GROUP` 来定义和切换不同的 RAG 配置组合。这对于在不同类型的知识库（例如，代码库 vs. 文档库）之间切换，或者测试不同嵌入/重排模型的效果非常有用。

示例：定义和使用 RAG 组

```yaml
# ~/.jarvis/config.yaml

# 1. 定义不同的 RAG 配置组
JARVIS_RAG_GROUPS:
  - text: # "text" 是组名
      embedding_model: BAAI/bge-m3
      rerank_model: BAAI/bge-reranker-v2-m3
      use_bm25: true
      use_rerank: true
  - code: # "code" 是组名
      embedding_model: Qodo/Qodo-Embed-1-1.5B
      use_bm25: false
      use_rerank: false

# 2. 选择要使用的 RAG 组
JARVIS_RAG_GROUP: code

# 3. (可选) 顶层配置会覆盖组配置
# 如果取消下面这行的注释，即使激活了 code 组，
# use_bm25 仍然会是 true。
# JARVIS_RAG:
#   use_bm25: true
```

### 工具配置组

Jarvis 支持通过 `JARVIS_TOOL_GROUPS` 和 `JARVIS_TOOL_GROUP` 来定义和切换不同的工具组合。这对于不同类型的任务（例如，代码开发 vs. 文档处理 vs. 系统管理）非常有用，可以通过配置快速切换可用的工具集。

示例：定义和使用工具组

```yaml
# ~/.jarvis/config.yaml

# 1. 定义不同的工具配置组
JARVIS_TOOL_GROUPS:
  - coding:  # 代码开发组
      use:  # 只使用这些工具
        - execute_script
        - read_code
        - clear_memory
        - save_memory
        - retrieve_memory
  - document:  # 文档处理组
      use:
        - search_web
        - save_memory
        - retrieve_memory
  - system:  # 系统管理组
      dont_use:  # 排除这些工具
        - search_web
  - restricted:  # 受限组
      use:
        - read_code
      # 只允许使用read_code，适合只读场景

# 2. 选择要使用的工具组
JARVIS_TOOL_GROUP: coding

# 注意：
# - 如果配置了 use 列表，则只有列表中的工具可用
# - 如果配置了 dont_use 列表，则排除列表中的工具
# - 如果同时配置了 use 和 dont_use，use 优先级更高
# - 默认情况下（不设置工具组），所有工具都可用
```

通过工具配置组，您可以：
- 提高安全性：在某些场景下限制可用工具，避免误操作
- 优化体验：为特定任务类型提供精简的工具集
- 快速切换：通过修改 `JARVIS_TOOL_GROUP` 快速切换工作模式

## 4.8 智能Shell (`jarvis-smart-shell` / `jss`)

`jss` 是一个强大的工具，可以将您的自然语言指令转换为可执行的 Shell 命令，极大降低了在终端中执行复杂操作的门槛。

### 子命令
- `request [需求]`: 将自然语言需求转换为 Shell 命令。如果未提供需求，则进入交互式输入模式。
- `install`: 为 `fish` shell 安装“命令未找到”处理器。
- `uninstall`: 卸载 `fish` shell 的处理器。

### 示例

1. 直接转换命令
当您不确定某个操作的命令时，可以直接向 `jss` 提问。它会打印出对应的 Shell 命令，但不会执行。
```bash
jss request "查找当前目录下所有大于1MB的.log文件"
# 输出: find . -type f -name "*.log" -size +1M
```

2. 交互式执行命令
如果您直接运行 `jss request` 而不带任何参数，它会启动一个交互式输入界面。在这种模式下，您输入需求后，生成的命令将被立即执行。
```bash
# 启动交互模式
jss request

# 在提示符后输入: 查找当前目录下所有大于1MB的.log文件，然后按 Ctrl+J
# jss 会打印并执行 find 命令
```

3. 安装“命令未找到”处理器 (仅支持 Fish Shell)
这是 `jss` 的一个强大功能，它能让您像使用自然语言一样操作终端。
```bash
# 1. 安装处理器
jss install

# 2. 使配置生效 (只需执行一次)
source ~/.config/fish/config.fish
```
安装后，当您在 `fish` 终端中输入一个系统不认识的命令（且长度大于10个字符，以防误触）时，`jss` 会自动拦截这个输入，将其转换为有效的 Shell 命令并执行。
```fish
# 在安装了处理器的 fish shell 中，直接输入:
> 在当前目录创建一个名为 'backup' 的文件夹

# jss 会自动将其转换为并执行: mkdir backup
```

4. 卸载处理器
```bash
# 1. 卸载处理器
jss uninstall

# 2. 使配置生效
source ~/.config/fish/config.fish
```

## 4.9 代码审查 (`jarvis-code-review` / `jcr`)

`jcr` 是您的自动化代码审查员，可以针对单个提交、文件或当前工作区的变更提供深入的分析和改进建议。

### 工作原理
`jcr` 的审查流程高度自动化和智能化：
1. 变更提取: 根据您指定的模式（如单个提交、范围或文件），`jcr` 会自动提取相应的代码 `diff`。
2. 语言检测: 它会分析变更文件的扩展名，自动识别涉及的编程语言（如 Python, Go, Java, TypeScript 等）。
3. 注入审查清单: 对于每种识别出的语言，`jcr` 会加载一个专门的审查清单（Checklist），并将其与代码变更一起注入到提示词中。
4. 全面审查框架 (SCRIPPPS): AI 会遵循一个名为 SCRIPPPS 的内置框架进行审查，该框架覆盖七个维度：Security、Correctness、Reliability、Interface、Performance、Portability、Structure。
5. 生成报告: 最终，AI 会生成一份详细的 Markdown 格式的审查报告，其中包含对每个问题的分类、严重程度评级、详细描述和具体的修复建议。

### 子命令
- `commit <commit-sha>`: 审查指定的单个提交。
- `current`: 审查您当前 `git` 工作区中已暂存和未暂存的变更。
- `range <commit1>..<commit2>`: 审查指定范围内的所有提交。
- `file <文件路径...>`: 审查一个或多个文件。

### 通用参数
所有子命令都支持以下参数：

| 参数 | 描述 |
|---|---|
| `--root-dir <路径>` | 指定要操作的代码仓库根目录（默认为当前目录）。 |
| `-g/--llm-group <组名>` | 使用的模型组，覆盖配置文件中的设置。 |

### 示例

1. 审查上一个提交
```bash
jcr commit HEAD~1
```

2. 审查当前所有变更
在提交代码前，进行一次自我审查。`jcr` 会自动分析 `git diff HEAD` 的结果。
```bash
# 无需手动暂存，jcr 会自动处理
jcr current
```

3. 审查指定范围的提交
审查从 `main` 分支切出新功能分支以来的所有变更。
```bash
jcr range main..HEAD
```

4. 审查单个或多个文件
```bash
jcr file src/jarvis/jarvis_agent/jarvis.py src/jarvis/jarvis_utils/config.py
```

## 4.10 高级Git工具

除了 `jgc`，Jarvis 还提供了一系列高级 Git 工具来简化复杂操作。

### 交互式 Squash (`jarvis-git-squash` / `jgs`)

`jgs` 可以帮助您将从某个指定提交之后的所有提交，自动合并（squash）成一个全新的、独立的提交，并为其生成一条清晰的、总结性的提交信息。这在合并多个小的功能提交或修复提交时非常有用。

#### 工作原理
1. 确认操作: `jgs` 会首先请求您确认 squash 操作。
2. 重置（Reset）: 它会执行 `git reset --mixed <您指定的基础提交>`。这个操作会将 `HEAD` 指针移回您指定的提交，同时保留这期间所有的代码变更在您的工作区。
3. 重新提交: 最后，`jgs` 会调用 `jgc` (Git 提交助手)，将工作区中所有的变更作为一个全新的提交，并由 AI 分析这些变更，生成一条高质量的总结性提交信息。

#### 参数
| 参数 | 描述 |
|---|---|
| `commit_hash` | 必需。您希望作为合并基础的提交哈希。此提交之后的所有提交都将被合并。|
| `--lang` | 指定生成提交信息时使用的语言（默认为中文）。 |

#### 示例
假设您的提交历史如下，您想将 `feat-a`, `feat-b`, `fix-c` 这三个提交合并成一个。
```
* 2d3d4d5 (HEAD -> main) fix-c
* a1b2c3d feat-b
* f9e8d7c feat-a
* c1a2b3d (base-commit) initial structure  <-- 这是我们的合并基础
```

运行以下命令，其中 `c1a2b3d` 是您希望保留的最后一个提交的哈希值：
```bash
jgs c1a2b3d
```
`jgs` 会自动完成上述的 `reset` 和重新提交工作，最终您的提交历史会变成：
```
* 3e4f5g6 (HEAD -> main) feat(new-feature): add a, b and fix c
* c1a2b3d (base-commit) initial structure
```

## 4.11 多智能体协作 (`jarvis-multi-agent` / `jma`)

`jma` 是一个强大的多智能体（Multi-Agent）协作框架，它允许您定义一组具有不同角色和能力的 AI 智能体，并通过自动化的消息路由机制，让它们协同工作以完成复杂任务。

### 工作原理
`jma` 的核心是一个基于 YAML 配置的协作系统：
1. 定义智能体: 您在一个 YAML 文件中定义多个智能体，每个智能体都有自己的 `name`（名称）、`description`（描述）和 `system_prompt`（系统提示词），这决定了它的角色和能力。
2. 指定主智能体: 在配置中，您需要指定一个 `main_agent`，作为整个任务的入口和协调者。
3. 消息驱动的协作: 当一个智能体需要另一个智能体的帮助时，它会生成一个特殊的 `<SEND_MESSAGE>` 消息块。`jma` 框架会自动捕获此消息，并将其路由给指定的目标智能体。
4. 自主运行: 这个过程会持续进行，直到主智能体认为任务完成，不再发送新的消息为止。

### 核心参数
| 参数 | 描述 |
|---|---|
| `-c`, `--config` | 必需。指定定义了智能体角色和工作流的 YAML 配置文件。|
| `-i`, `--input` | 提供给智能体系统的初始任务输入。如果未提供，则会进入交互式输入模式。|
| `-n`, `--non-interactive` | 启用非交互模式，用于自动化脚本。详见“通用交互技巧”章节。|

### 示例：构建一个市场研究团队

假设我们想创建一个由“市场研究员”和“报告撰写者”组成的团队，来分析一个产品的市场潜力。

1. 创建配置文件 `market_research.yaml`
首先，我们定义两个智能体和它们的工作流程：
```yaml
# market_research.yaml

# 定义主智能体，任务将从这里开始
main_agent: MarketResearcher

# 定义所有可用的智能体
agents:
  - name: MarketResearcher
    description: "一个专业的市场研究员，擅长使用工具进行网络搜索和数据分析。"
    # system_prompt 定义了该智能体的角色和可用工具
    system_prompt: |
      你是一名市场研究员。你的任务是分析给定产品的市场潜力和竞争格局。
      你需要使用 `search_web` 工具来收集信息。
      在收集到足够的信息后，将你的发现总结并发送给 'ReportWriter'。
    # 为该智能体配置可用的工具
    use_tools:
      - search_web

  - name: ReportWriter
    description: "一个专业的分析报告撰写者，擅长将零散的信息整合成结构化的报告。"
    system_prompt: |
      你是一名报告撰写者。你的任务是接收来自 'MarketResearcher' 的研究结果，
      并基于这些结果撰写一份条理清晰、格式专业的市场分析报告。
      这是你最终需要交付的成果，请确保报告的完整性。
```

2. 运行 jma
现在，我们可以使用这个配置文件来启动多智能体系统，并给它分配一个任务：
```bash
jma --config ./market_research.yaml --input "分析 'AI代码助手' 这个产品的市场潜力和主要竞争对手"
```
执行流程:
1. 任务首先被发送给 `MarketResearcher`。
2. `MarketResearcher` 会调用 `search_web` 工具搜索“AI代码助手”的相关信息。
3. 完成研究后，`MarketResearcher` 会生成一条 `<SEND_MESSAGE>` 发送给 `ReportWriter`，内容是它的研究总结。
4. `ReportWriter` 接收到信息后，会撰写并输出最终的市场分析报告。

## 4.12 工具管理 (`jarvis-tool` / `jt`)

`jt` 是与 Jarvis 工具系统交互的命令行界面，它不仅能让您查看和调用现有工具，更是您扩展 Jarvis 能力的重要入口。

### 子命令
- `list`: 列出所有AI可用的工具。
- `call <工具名>`: 直接从命令行调用一个工具。
- `stat`: 显示每个工具被AI调用的频率统计。

### 核心功能与示例

1. 查看工具
`list` 命令是探索 Jarvis 能力的起点。
```bash
# 查看所有工具的名称和描述
jt list

# 以 JSON 格式输出，方便脚本处理
jt list --json

# 显示工具的详细信息，包括其参数定义
jt list --detailed
```

2. 调用工具
`call` 命令允许您直接测试或使用任何一个工具。
```bash
# 示例：调用网页搜索工具
jt call search_web --args '{"query": "Jarvis AI assistant on GitHub"}'

# 对于复杂参数，可以从文件加载
# 1. 创建 a.json 文件，内容为: {"query": "How to use Jarvis RAG?"}
# 2. 通过 --args-file 参数调用
jt call search_web --args-file ./a.json
```

3. 查看工具使用统计
`stat` 命令可以帮助您了解哪些工具被 AI 使用得最频繁。
```bash
jt stat
```

### 扩展 Jarvis 工具

`jt` 真正的强大之处在于其可扩展性。Jarvis 会从以下位置自动加载工具，让您可以轻松添加新功能：

方式一：通过 Python 文件添加工具
您可以将自定义的工具脚本（遵循特定的类结构）放置在以下目录中，Jarvis 启动时会自动加载它们：
- `~/.jarvis/tools/`
- 在 `config.yaml` 中由 `JARVIS_TOOL_LOAD_DIRS` 变量指定的其他目录。

如果这些目录是 Git 仓库，Jarvis 还会每日自动执行 `git pull` 来保持工具更新。

方式二：通过 MCP (Model Context Protocol) 添加工具
MCP (模型上下文协议) 是一种更高级的集成方式，它允许 Jarvis 与外部服务（如另一个AI模型、API服务等）进行通信，并将该服务的能力封装为 Jarvis 工具。您可以通过在 `~/.jarvis/mcp/` 目录下创建 `.yaml` 配置文件，或直接在主 `config.yaml` 中定义 `JARVIS_MCP` 列表来注册 MCP 工具。

通过这两种方式，您可以不断地为 Jarvis 赋予新的能力，使其能解决更多领域的问题。

## 4.13 记忆系统

Jarvis 内置了强大的记忆系统，帮助您在多次交互中保持上下文连续性，并积累知识和经验。记忆系统通过 `save_memory` 和 `retrieve_memory` 两个核心工具提供服务。

### 记忆类型

Jarvis 支持三种不同的记忆类型，每种都有其特定用途：

1. 短期记忆 (short_term)
- 用途：存储当前任务相关的临时信息
- 生命周期：仅在当前会话期间有效，不会持久化
- 适用场景：任务执行过程中的中间结果、临时决策、当前上下文

2. 项目长期记忆 (project_long_term)
- 用途：存储与当前项目相关的持久信息
- 存储位置：`.jarvis/memory/` 目录
- 适用场景：项目架构说明、技术栈信息、项目特定约定、API文档等

3. 全局长期记忆 (global_long_term)
- 用途：存储跨项目的通用知识和偏好
- 存储位置：`~/.jarvis/data/memory/global_long_term/` 目录
- 适用场景：编程最佳实践、个人偏好设置、通用解决方案、技术笔记等

### 使用示例

保存记忆
```bash
# 在交互过程中，告诉 Jarvis 保存重要信息
jvs -T "这个项目使用 FastAPI 框架，数据库是 PostgreSQL，请记住这个信息"
# Jarvis 会自动调用 save_memory 工具，选择合适的记忆类型

# 保存编程技巧到全局记忆
jvs -T "记住这个 Python 性能优化技巧：使用列表推导式比 for 循环更快"
```

检索记忆
```bash
# 查询项目相关信息
jvs -T "这个项目使用什么技术栈？"
# Jarvis 会自动从项目长期记忆中检索相关信息

# 查询编程知识
jvs -T "我之前保存过哪些 Python 性能优化的技巧？"
```

### 高级用法

批量导入知识
```bash
# 将文档内容导入为记忆
jvs -T "请阅读 ./docs/api_reference.md 文件，并将重要的 API 信息保存到项目记忆中"
```

记忆关联
```bash
# 建立相关概念之间的联系
jvs -T "记住：当使用 Redis 缓存时，要考虑数据一致性问题，可以使用发布订阅模式同步缓存"
```

记忆总结
```bash
# 让 Jarvis 总结某个主题的所有相关记忆
jvs -T "总结一下我保存的所有关于数据库优化的记忆"
```

通过有效使用记忆系统，您可以让 Jarvis 成为一个真正了解您和您的项目的智能助手，大大提升工作效率。

### 记忆整理工具 (`jarvis-memory-organizer` / `jmo`)

随着时间推移，记忆系统中可能会积累大量相似或重复的记忆。`jmo` 工具提供了整理、合并、导入导出等功能，帮助您高效管理记忆库。

功能特点
- 自动识别具有相似标签的记忆并智能合并
- 支持记忆的导入导出，便于备份和迁移
- 使用 AI 智能合并相关记忆，保留所有重要信息
- 优先保留最新的记忆内容（时间权重）
- 支持项目长期记忆和全局长期记忆的管理

子命令

1. organize - 整理和合并记忆
```bash
# 整理项目长期记忆（默认）
jmo organize

# 整理全局长期记忆
jmo organize --type global_long_term

# 设置最小标签重叠数为 3
jmo organize --min-overlap 3

# 模拟运行，查看将要合并的记忆但不实际执行
jmo organize --dry-run
```

2. export - 导出记忆
```bash
# 导出所有记忆到文件
jmo export memories.json

# 只导出项目长期记忆
jmo export project_memories.json -t project_long_term

# 导出带特定标签的记忆
jmo export python_memories.json --tag Python --tag API

# 导出多种类型的记忆
jmo export all_memories.json -t project_long_term -t global_long_term
```

3. import - 导入记忆
```bash
# 导入记忆文件
jmo import memories.json

# 导入并覆盖已存在的记忆
jmo import memories.json --overwrite
```

工作原理

整理功能：
1. 扫描指定类型的所有记忆文件
2. 找出标签重叠度高的记忆组
3. 使用 AI 将相似记忆合并成一个综合性记忆
4. 删除原始记忆，保存合并后的新记忆

导入导出功能：
1. 导出：将指定类型和标签的记忆序列化为 JSON 文件
2. 导入：从 JSON 文件恢复记忆到相应的存储位置

最佳实践
- 定期运行整理功能（如每周一次）以保持记忆库整洁
- 在整理前使用 export 功能备份重要记忆
- 首次整理建议使用 `--dry-run` 预览效果
- 可以根据项目特点调整 `--min-overlap` 参数
- 使用导入导出功能在不同环境间迁移记忆

## 4.14 方法论管理 (`jarvis-methodology` / `jm`)

`jm` 是用于管理和维护 Jarvis 方法论库的工具。

### 什么是方法论？
在 Jarvis 中，方法论（Methodology）是一套针对特定 问题类型（Problem Type） 的、标准化的、可复用的解决方案流程。当 Jarvis 遇到一个新任务时，它会首先尝试匹配已有的方法论。如果找到匹配项，它就会参考这个方法论来制定计划，而不是从零开始思考，从而大大提高解决问题的效率和成功率。

所有的方法论都以“问题类型”为核心，存储在 `~/.jarvis/methodologies` 目录下的独立 JSON 文件中。

### 子命令
- `import <文件>`: 从一个导出的 JSON 文件中导入方法论，它会与现有的方法论进行合并（新的会覆盖同名的旧的）。
- `export <文件>`: 将当前所有的方法论导出到一个单一的 JSON 文件中，方便备份和分享。
- `list`: 列出当前所有方法论的“问题类型”。
- `extract <文件>`: 从本地的一个文本文件（如一篇技术文章、教程）中，利用 AI 提取并生成新的方法论。
- `extract-url <URL>`: 从一个网页链接中，利用 AI 读取内容、提取并生成新的方法论。

### 示例

1. 让 Jarvis 从外部知识中学习
假设您找到一篇非常好的关于“排查 Kubernetes Pod 启动失败”的博客文章，您可以让 Jarvis 从中学习，并形成自己的方法论。
```bash
# Jarvis 会读取该 URL 的内容，并自动提取和保存相关的解决方案流程
jm extract-url "https://some-blog.com/k8s-pod-troubleshooting"
```
执行后，如果您再次向 Jarvis 提出类似“我的 Pod 启动不了”的问题，它就会优先参考刚刚学到的这套方法论来解决问题。

2. 查看、备份和分享方法论
```bash
# 查看您已经积累了哪些方法论
jm list

# 将所有方法论备份到一个文件中
jm export my_methodologies.json

# 在另一台机器上，或者分享给同事后，可以轻松导入
jm import my_methodologies.json
```

3. 分享方法论到中心仓库

Jarvis 支持将本地的方法论分享到团队的中心方法论仓库，实现知识共享：

```bash
# 分享本地方法论到中心仓库
jarvis --share-methodology
```

这个功能需要先配置中心方法论仓库地址（参见 [5.功能扩展](5.功能扩展.md) 中的方法论共享配置）。执行后会：
- 自动克隆/更新中心方法论仓库
- 检测并排除已存在的重复方法论
- 允许您选择要分享的方法论（支持批量选择）
- 自动提交并推送到远程仓库

### 中心方法论库使用场景

1. 团队知识沉淀
```bash
# 场景：团队成员解决了一个复杂的性能问题，想将解决方案分享给全团队
# 步骤1：先让 Jarvis 学习这个解决方案
jm extract performance_optimization.md

# 步骤2：分享到中心库
jarvis --share-methodology
# 选择刚才生成的"性能优化"方法论
```

2. 新人快速上手
```bash
# 场景：新加入的团队成员需要快速了解项目的最佳实践
# 配置中心方法论库后，Jarvis 会自动加载所有团队方法论
export JARVIS_CENTRAL_METHODOLOGY_REPO="https://github.com/team/methodologies.git"

# 新人可以直接使用团队积累的所有方法论
jvs -T "如何进行代码审查？"  # Jarvis 会自动应用团队的代码审查方法论
```

3. 跨项目经验复用
```bash
# 场景：在新项目中遇到类似问题，想复用之前项目的解决方案
# 中心库中已有"微服务部署"、"数据库迁移"等方法论
jvs -T "我需要将这个单体应用拆分为微服务"
# Jarvis 会自动匹配并应用"微服务拆分"方法论
```

### 中心工具库使用场景

1. 企业内部工具集成
```bash
# 场景：企业有内部的发布系统、监控平台等
# 步骤1：开发适配工具并测试
# 创建 ~/.jarvis/tools/deploy_tool.py

# 步骤2：分享到中心工具库
jarvis --share-tool
# 选择 deploy_tool.py，工具会被移动到中心库

# 团队其他成员配置中心工具库后即可使用
export JARVIS_CENTRAL_TOOL_REPO="https://github.com/company/jarvis-tools.git"
jvs -T "部署应用到生产环境"  # 可以直接调用内部部署工具
```

2. 领域专用工具包
```bash
# 场景：数据科学团队需要专门的数据处理工具
# 中心工具库包含：data_cleaning, model_evaluation, dataset_split 等工具

# 配置数据科学工具库
export JARVIS_CENTRAL_TOOL_REPO="https://github.com/team/ml-tools.git"

# 使用专用工具进行数据处理
jvs -T "清洗 dataset.csv 中的异常数据并划分训练集"
```

3. 安全合规场景
```bash
# 场景：某些环境需要限制工具使用，只允许经过审核的工具

# 步骤1：配置只使用中心工具库的工具
cat >> ~/.jarvis/config.yaml << EOF
JARVIS_CENTRAL_TOOL_REPO: "https://github.com/company/approved-tools.git"
JARVIS_TOOL_GROUPS:
  - secure:
      use: []  # 不使用任何内置工具
      # 只使用中心工具库中经过审核的工具
JARVIS_TOOL_GROUP: secure
EOF

# 步骤2：这样配置后，Jarvis 只能使用中心库中的受信任工具
```

4. 工具版本管理
```bash
# 场景：需要确保团队使用统一版本的工具

# 中心工具库使用 Git 标签管理版本
cd ~/.jarvis/central_tool_repo
git tag -l  # 查看所有版本
# v1.0.0
# v1.1.0
# v2.0.0

# 切换到特定版本
git checkout v1.1.0

# 或者在 CI/CD 中锁定版本
git clone --branch v1.1.0 $JARVIS_CENTRAL_TOOL_REPO
```

### 最佳实践建议

1. 建立审核机制：中心库应有代码审核流程，确保质量
2. 文档规范：每个方法论和工具都应有清晰的文档
3. 定期更新：利用 Jarvis 的自动更新功能保持同步
4. 分类管理：使用目录结构对方法论和工具进行分类
5. 版本控制：使用 Git 标签标记重要版本，便于回滚

---

## 4.15 安全分析套件 (`jarvis-sec` / `jsec`)

`jsec` 是 Jarvis 的安全分析套件，专门用于对代码工程进行安全扫描和分析。它结合了启发式扫描和 AI 深度验证，能够识别潜在的安全漏洞和风险。

### 核心特性

- **启发式快速扫描**：基于正则表达式的快速扫描，支持 C/C++ 和 Rust 语言，无需依赖外部服务
- **AI 深度分析**：使用 Agent 对候选问题进行深度分析，推导完整的漏洞触发路径
- **多阶段验证流程**：直扫 → 聚类 → 分析 → 验证 → 复核，确保结果准确性
- **结构化报告**：生成 JSON + Markdown/CSV 格式的详细报告，包含问题分类、严重程度、修复建议等
- **断点续跑支持**：支持从检查点恢复分析流程，适合大规模代码库

### 工作流程

```
直扫（direct_scan）→ 聚类（Cluster Agent）→ 分析（Analysis Agent）→ 
验证（Verification Agent）→ 复核（Review Agent）→ 报告聚合
```

1. **直扫（Direct Scan）**：使用预定义的正则表达式模式快速识别潜在安全问题
2. **聚类（Clustering）**：使用 LLM 将相似的安全问题聚类，减少重复分析
3. **分析（Analysis）**：为每个候选问题创建独立的 Agent 任务进行深度分析
4. **验证（Verification）**：使用独立的验证 Agent 对分析结果进行二次验证
5. **复核（Review）**：最终复核和报告聚合

### 子命令

`jsec` 提供 `agent` 子命令，用于执行 Agent 模式的安全分析。

#### `agent` - Agent 模式（单Agent逐条子任务分析）

**参数**：

| 参数 | 描述 |
|------|------|
| `-p/--path <路径>` | 待分析的根目录（默认当前目录） |
| `-g/--llm-group <组名>` | 使用的模型组（仅对本次运行生效，不修改全局配置） |
| `-o/--output <路径>` | 最终报告输出路径（默认 ./report.md）。如果后缀为 .csv，则输出 CSV 格式；否则输出 Markdown 格式 |
| `-c/--cluster-limit <数量>` | 聚类每批最多处理的告警数（按文件分批聚类，默认50） |
| `--enable-verification/--no-verification` | 是否启用二次验证（默认开启） |
| `--force-save-memory/--no-force-save-memory` | 强制使用记忆（默认关闭） |

**使用示例**：

```bash
# 基本安全扫描（扫描当前目录）
jsec agent

# 扫描指定目录
jsec agent --path /path/to/project

# 指定输出文件（Markdown 格式）
jsec agent --output security_report.md

# 指定输出文件（CSV 格式）
jsec agent --output security_report.csv

# 禁用二次验证（快速模式）
jsec agent --no-verification

# 指定模型组
jsec agent -g deep_seek_v3

# 调整聚类批次大小
jsec agent --cluster-limit 100

# 启用强制记忆保存
jsec agent --force-save-memory

# 组合使用多个参数
jsec agent --path /path/to/project --output report.md --no-verification -g deep_seek_v3
```

### 输出说明

`jsec agent` 会生成以下输出：

- **Markdown 报告**（默认）：人类可读的详细报告，包含问题描述、严重程度、修复建议等
- **CSV 报告**（当输出文件后缀为 .csv 时）：结构化的 CSV 格式报告，便于导入 Excel 等工具分析
- **控制台输出**：分析过程的实时输出和最终报告摘要

### 注意事项

- 首次运行可能需要较长时间，特别是对于大型代码库
- 建议在 CI/CD 流程中集成，定期进行安全扫描
- 对于误报，可以通过复核流程进行过滤
- 支持 C/C++ 和 Rust 语言的安全分析
- 如果 Agent 分析过程出错或无输出，会自动回退到直扫基线（fast 模式）
- 断点续跑功能通过内部机制自动处理，无需手动指定检查点文件

## 4.16 C→Rust 迁移套件 (`jarvis-c2rust` / `jc2r`)

`jc2r` 是 Jarvis 的 C→Rust 迁移套件，专门用于将 C/C++ 代码智能迁移到 Rust。它采用渐进式迁移策略，支持断点续跑，确保迁移过程安全可控。

### 核心特性

- **智能代码扫描**：基于 libclang 的精确 AST 解析，提取函数、类型和调用关系
- **库替代评估**：使用 LLM 评估 C 函数是否可用 Rust 标准库或第三方 crate 替代
- **模块规划**：使用 Agent 智能规划 Rust crate 的模块结构
- **代码转译**：使用 CodeAgent 进行代码生成和修复，支持依赖检查和自动实现
- **保守优化**：在确保代码正确性的前提下进行优化
- **渐进式迁移**：支持断点续跑，可以分批次完成迁移
- **可回退机制**：构建检测与 git_guard 确保迁移过程可回退

### 工作流程

```
扫描（scan）→ 库替代（lib-replace）→ 模块规划（prepare）→ 
转译（transpile）→ 优化（optimize）
```

1. **扫描（scan）**：使用 libclang 解析 C/C++ 代码，生成符号表和调用图
2. **库替代（lib-replace）**：评估哪些 C 函数可以用 Rust 库替代
3. **模块规划（prepare）**：使用 Agent 规划 Rust crate 的模块结构
4. **转译（transpile）**：使用 CodeAgent 进行代码生成和修复
5. **优化（optimize）**：在确保正确性的前提下进行保守优化

### 子命令

`jc2r` 提供两个主要子命令：

#### 1. `config` - 管理转译配置文件

管理转译配置文件（`.jarvis/c2rust/config.json`），可以设置根符号列表、禁用库列表和附加说明。

**参数**：

| 参数 | 描述 |
|------|------|
| `--files <文件...>` | 头文件（.h/.hh/.hpp/.hxx）或函数名列表文件（每行一个函数名，忽略空行与以#开头的注释） |
| `--root-list-syms <符号列表>` | 根符号列表内联（逗号分隔） |
| `--disabled-libs <库列表>` | 禁用库列表（逗号分隔） |
| `--additional-notes <说明>` | 附加说明（将在所有 agent 的提示词中追加） |
| `--show` | 显示当前配置内容 |
| `--clear` | 清空配置（重置为默认值） |

**使用示例**：

```bash
# 从头文件自动提取函数名并设置根符号列表
jc2r config --files bzlib.h

# 从多个头文件提取函数名
jc2r config --files a.h b.hpp c.hxx

# 从函数名列表文件设置根符号列表
jc2r config --files roots.txt

# 从命令行设置根符号列表
jc2r config --root-list-syms "func1,func2,func3"

# 设置禁用库列表
jc2r config --disabled-libs "libc,libm"

# 设置附加说明
jc2r config --additional-notes "注意：所有函数必须处理错误情况，避免 panic"

# 同时设置多个参数
jc2r config --files bzlib.h --disabled-libs "libc" --additional-notes "特殊要求说明"

# 查看当前配置
jc2r config --show

# 清空配置
jc2r config --clear
```

#### 2. `run` - 执行完整的转译流水线

依次执行流水线：scan → lib-replace → prepare → transpile → optimize，支持断点续跑。

**参数**：

| 参数 | 描述 |
|------|------|
| `-g/--llm-group <组名>` | 用于 LLM 相关阶段（lib-replace/prepare/transpile/optimize）的模型组 |
| `-m/--max-retries <次数>` | transpile 构建/修复与审查的最大重试次数（0 表示不限制） |
| `--interactive` | 启用交互模式（默认非交互模式） |
| `--reset` | 重置状态，从头开始执行所有阶段 |

**使用示例**：

```bash
# 执行完整的转译流水线（使用默认配置）
jc2r run

# 指定模型组
jc2r run -g deep_seek_v3

# 设置最大重试次数
jc2r run -m 3

# 启用交互模式
jc2r run --interactive

# 重置状态，从头开始执行
jc2r run --reset

# 组合使用多个参数
jc2r run -g deep_seek_v3 -m 5 --interactive
```

### 断点续跑机制

`jc2r run` 支持断点续跑，根据状态文件（`.jarvis/c2rust/run_state.json`）自动跳过已完成的阶段：

- 如果某个阶段已完成，会自动跳过并继续下一个阶段
- 使用 `--reset` 可以重置状态，从头开始执行所有阶段
- 状态文件记录每个阶段的完成状态和时间戳

### 配置文件说明

转译配置保存在 `.jarvis/c2rust/config.json`，包含：

- **root_symbols**：根符号列表，用于确定转译的入口函数
- **disabled_libraries**：禁用库列表，指定不使用哪些库进行替代
- **additional_notes**：附加说明，会在所有 agent 的提示词中追加

### 技术特点

- **精确解析**：使用 libclang 提供准确的 AST 解析，保留完整的类型信息
- **依赖管理**：自动提取函数调用关系，确保转译顺序符合依赖关系
- **测试保护**：基于事件订阅机制，确保测试代码不会被意外删除
- **记忆保存**：代码生成 Agent 启用强制保存记忆，记录关键信息
- **依赖检查**：在实现函数时自动检查并补齐依赖函数的实现

### 输出说明

`jc2r` 会在 `.jarvis/c2rust/` 目录下生成以下文件：

- **symbols.jsonl**：统一符号表（后续流程的主输入）
- **symbols_raw.jsonl**：原始符号表
- **translation_order.jsonl**：函数转译的先后顺序
- **library_replacements.jsonl**：库替代映射关系
- **run_state.json**：运行状态文件（用于断点续跑）
- **config.json**：转译配置文件
- **symbol_map.jsonl**：符号映射关系

### 注意事项

- 需要安装 libclang（clang.cindex），支持 libclang 16-21 版本
- 建议使用 compile_commands.json 提高解析准确性
- 迁移过程会自动进行构建检测，确保代码可编译
- 支持大规模项目的分批转译，可以中断后继续
- 迁移后的代码需要人工审查和测试
- 根符号列表和禁用库列表需要先通过 `config` 命令设置

## 4.17 使用统计 (`jarvis-stats` / `jst`)

`jst` 是 Jarvis 的通用统计模块，提供灵活的指标记录和可视化功能。它可以追踪任意类型的数据，包括代码变更、API调用、响应时间等，并提供丰富的查询和展示功能。

### 核心功能
- 灵活的指标管理: 支持添加任意指标，可设置单位和标签
- 多维度查询: 按时间范围、标签过滤查询数据
- 可视化展示: 支持表格、图表、摘要等多种展示格式
- 数据聚合: 支持按小时或天聚合数据
- 历史数据管理: 自动存储历史数据，支持清理旧数据

### 主要命令

| 命令    | 描述                           | 示例                                     |
| ------- | ------------------------------ | ---------------------------------------- |
| `add`   | 添加统计数据                   | `jst add response_time 1.5 -u seconds`  |
| `inc`   | 增加计数型指标                 | `jst inc api_calls -a 1`                |
| `show`  | 显示统计数据                   | `jst show response_time -a daily`       |
| `plot`  | 绘制指标折线图                 | `jst plot api_calls -a hourly`          |
| `list`  | 列出所有指标                   | `jst list`                              |
| `clean` | 清理旧数据                     | `jst clean -d 30`                       |
| `export`| 导出统计数据（CSV 到标准输出） | `jst export api_calls > out.csv`        |
| `remove`| 删除指定指标                   | `jst remove api_calls -y`               |
| `demo`  | 运行演示                       | `jst demo`                              |

### 常用参数

| 参数                | 描述                                    | 适用命令                       |
| ------------------- | --------------------------------------- | ------------------------------ |
| `-a`, `--agg`       | 聚合方式 (hourly/daily)                 | show, plot                     |
| `-t`, `--tag`       | 标签过滤，格式: key=value               | add, inc, show, plot, export   |
| `-u`, `--unit`      | 指标单位                                | add                            |
| `-w`, `--width`     | 图表宽度                                | plot                           |
| `-H`, `--height`    | 图表高度                                | plot                           |
| `-d`, `--days`      | 保留最近 N 天（清理旧数据）             | clean                          |

注意：当前 CLI 暂不支持通过 --hours/--days 对 show/plot/export 进行时间范围筛选，也不支持 --format 选择输出格式；export 仅以 CSV 输出到标准输出。如需摘要/JSON 等格式，可在代码中直接调用 StatsManager.show(format=...) 等接口实现。

### 示例

1. 添加和查看代码变更统计
```bash
# 添加代码行数变更
jst add code_lines_added 150 -u lines -t "file=main.py" -t "type=feature"
jst add code_lines_deleted 30 -u lines -t "file=main.py" -t "type=refactor"

# 查看代码变更（按天聚合）
jst show code_lines_added -a daily
```

2. 追踪API响应时间
```bash
# 记录API响应时间
jst add api_response_time 0.5 -u seconds -t "endpoint=/api/users" -t "status=200"
jst add api_response_time 2.1 -u seconds -t "endpoint=/api/posts" -t "status=500"

# 绘制响应时间图表（可选设置尺寸）
jst plot api_response_time -a hourly -w 80 -H 20
```

3. 统计模型调用次数
```bash
# 增加模型调用计数
jst inc llm_calls -t "provider=kimi" -t "model=moonshot-v1"
jst inc llm_calls -t "provider=yuanbao" -t "model=hunyuan-lite"

# 查看各模型的调用统计（按天聚合）
jst show llm_calls -a daily
```

4. 导出数据进行分析
```bash
# 导出为CSV格式（当前仅支持 CSV 到标准输出）
jst export api_response_time > response_times.csv

# 导出包含标签信息（同样为 CSV）
jst export llm_calls > llm_usage.csv
```

5. 查看所有指标概览
```bash
# 列出所有指标，显示单位、最后更新时间和数据点数
jst list

# 显示所有指标的摘要（不指定指标名）
jst show
```

6. 删除指标
```bash
# 删除指定指标（会提示确认）
jst remove llm_calls

# 跳过确认
jst remove llm_calls -y
```

### 数据存储
统计数据按日期分片存储在 `~/.jarvis/stats/` 目录下，每天的数据保存为独立的 JSON 文件。这种设计确保了：
- 数据安全：每日独立存储，避免数据损坏影响
- 查询效率：按需加载特定日期的数据
- 易于备份：可以选择性备份重要时期的数据

### 使用场景
1. 效率评估: 定期查看统计，了解 AI 助手的实际贡献
2. 成本分析: 统计各平台的使用量，优化模型选择
3. 工作汇报: 用数据展示 AI 辅助开发的成果
4. 优化建议: 根据使用模式调整工作习惯