# 4. 使用指南

本章是 Jarvis 的实用操作手册，将详细介绍主要命令的用法、参数和常见场景示例。

在阅读本章之前，我们建议您先通过 [快速开始](./2.快速开始.md) 了解 Jarvis 的基本安装和配置。

## 4.1 首次运行配置

在您第一次运行任何 `jarvis` 命令之前，需要进行一次简单的配置，以连接到 AI 大模型平台。

### 生成配置文件

首次运行任何 jarvis 命令（例如 `jarvis` 或 `jpm info`），系统会自动在您的用户主目录下创建 `~/.jarvis/` 文件夹，以及一个默认的配置文件 `config.yaml`。

### 编辑配置文件

打开 `~/.jarvis/config.yaml` 文件。您会看到类似如下的结构：

```yaml
# yaml-language-server: $schema=...
JARVIS_PLATFORM: yuanbao
JARVIS_MODEL: deep_seek_v3
# ... 其他配置 ...
ENV:
  YUANBAO_COOKIES: ''
  KIMI_API_KEY: ''
  TONGYI_COOKIES: ''
```

### 填入凭证

Jarvis 默认推荐使用腾讯元宝平台，因为它免费且功能强大。您需要填入其凭证：

1. 登录腾讯元宝网页版。
2. 打开浏览器开发者工具（通常按 F12），切换到"网络(Network)"标签页。
3. 找到任意一个发往 `yuanbao.tencent.com` 的请求，在请求头(Request Headers)中找到 `Cookie` 字段，并复制其**完整**的值。
4. 将复制的 Cookie 字符串粘贴到 `YUANBAO_COOKIES: ''` 的引号中。

配置完成后，文件应如下所示：
```yaml
# ...
ENV:
  YUANBAO_COOKIES: '复制到此处的长长的Cookie字符串...'
  KIMI_API_KEY: ''
  TONGYI_COOKIES: ''
```

> 如果您希望使用其他平台（如 Kimi、通义或 OpenAI），请相应地填入它们的 `API_KEY` 或 `COOKIES`。

保存文件后，Jarvis 便已配置完成，可以正常使用了。

## 4.2 通用交互技巧

无论您使用哪个 Jarvis 工具，掌握以下交互技巧都将极大提升您的效率。

### 1. 快捷键 (多行输入模式)

在需要您输入多行文本（如 `jvs` 或 `jca` 的交互模式）时，可以使用以下快捷键：

| 快捷键        | 功能                                               |
|---------------|----------------------------------------------------|
| `@`           | 触发“Git 文件模式”的文件/指令补全；若安装 fzf，将弹出 Git 文件选择器。 |
| `#`           | 触发“全量文件模式”的文件补全（排除 .git）；若安装 fzf，将弹出全量文件选择器。 |
| `Tab`         | 在弹出的补全建议列表中进行选择。                   |
| `Enter`       | 在补全列表打开时应用选中项，否则用于换行。         |
| `Ctrl + J`    | 提交您的多行输入，开始执行任务。                   |
| `Ctrl + C`    | 取消当前的输入操作。                               |
| `Ctrl + O`    | 复制AI的上一条回复到系统剪贴板，方便您使用。     |

### 2. 提示词技巧 (Prompting)

编写高质量的提示词是让 Jarvis 发挥最大潜能的关键。

- **明确角色与目标**: 在任务开始时，清晰地告诉Jarvis它应该扮演什么角色，以及最终要达成的目标是什么。
  > **例**: "你现在是一个资深的运维专家。我的目标是排查并解决一个 Kubernetes Pod 启动失败的问题。"
- **提供上下文与特殊指令 (`@`/`#`)**: 使用 `@` 或 `#` 符号可以触发强大的上下文补全和快捷指令功能。
  - **提供文件上下文**: 输入 `@` 或 `#` 后跟文件名（支持模糊搜索和自动补全），可将文件内容注入到对话中，为 AI 提供充足的分析背景。
    - `@` Git 文件模式：仅在 Git 跟踪的文件中进行补全/选择，列表干净、速度更快。
    - `#` 全量文件模式：在整个工作目录中进行补全/选择，自动排除 `.git`，适合未纳入 Git 的文件。
    - 若系统安装了 fzf，按下 `@`/`#` 会弹出对应的文件选择器；否则使用内置补全列表。
    - 选择后会将路径以单引号包裹插入；若光标前存在以该前导符开头、且不含空格的片段，会被整体替换为所选路径。
    > **例**: "请分析 `@./src/main.py` 这个文件中的代码，并找出潜在的性能瓶颈。"
    > **例**: "请分析 `#./logs/latest.log` 这个文件中的内容，定位错误栈来源。"
  - **执行特殊指令**: 输入 `@` 或 `#` 后，补全菜单还会显示一系列内置指令，用于快速控制对话或执行常用操作。
    > **例**: 输入 `'<Summary>'` 并提交，可以要求 Jarvis 对之前的对话进行总结。

    以下是所有可用的内置特殊指令：

    | 指令 | 功能描述 |
    |---|---|
    | `'<Summary>'` | 让 AI 总结当前的对话历史，并将摘要作为新的上下文，这有助于在长对话中保持焦点。 |
    | `'<Clear>'` | 清空当前的对话历史记录，开始一个全新的对话。 |
    | `'<ToolUsage>'` | 显示所有可用工具的列表和详细说明，帮助你了解 AI 能做什么。 |
    | `'<ReloadConfig>'` | 重新加载 Jarvis 的配置文件。如果你在运行时修改了配置，可以使用此指令使其生效。 |
    | `'<SaveSession>'` | 保存当前的对话状态（包括历史记录）。之后可以通过 `jvs --restore-session` 来恢复。 |
    | `'<自定义标签>'` | 你可以在 `~/.jarvis/config.yaml` 中通过 `JARVIS_REPLACE_MAP` 定义自己的标签，用于插入预设的模板文本。这对于重复性的输入非常有用。 |
- **分解复杂任务**: 对于复杂的任务，将其分解为更小、更具体的步骤，并引导 Jarvis 逐步完成。

### 3. 人工介入与控制 (Human-in-the-Loop)

Jarvis 的一个核心特性是支持在任务执行的任意阶段进行人工介入。

- **执行前确认**: 在执行可能产生影响的操作（如运行脚本、修改文件）之前，Jarvis 会暂停并请求您的确认 `[Y/n]`。这是第一层防护。

- **思考后介入 (`Ctrl+C`)**: 这是最关键的介入方式。
  - 当 AI 正在“思考”（即大模型正在生成下一步计划）时，您可以随时按下 `Ctrl+C`。
  - Jarvis **不会立即打断**模型的思考，而是会**等待当前思考步骤完成**（即API返回结果）。
  - 在**执行**模型生成的计划（如调用工具）**之前**，系统会检测到中断信号，暂停执行并提示您：`"模型交互期间被中断，请输入用户干预信息："`。
  - 这为您提供了一个审查并否决 AI 下一步行动的宝贵机会。您可以输入新指令来纠正它，或直接拒绝它即将执行的工具调用。

- **工具调用裁决**: 这是“思考后介入”的具体体现。当您中断了一个即将发生的工具调用时，系统会询问您是否继续处理该工具。这让您拥有对每一步具体操作的最终决定权。

- **强制退出 (多次`Ctrl+C`)**: 如果您希望立即终止整个 Jarvis 程序，而不想等待当前思考步骤完成，可以**快速连续按下 `Ctrl+C` 五次以上（或长按）**。这将触发系统的强制退出机制。

### 4. 非交互模式 (自动化)

对于需要在自动化环境（如 CI/CD 流水线、定时任务脚本）中运行 Jarvis 的场景，可以使用 `-n` 或 `--non-interactive` 参数来启用非交互模式。

该模式具有以下特点：

- **无用户提示**: 在此模式下，Jarvis 不会提出任何需要用户输入 `[Y/n]` 确认或进行选择的问题。所有交互式环节都会被跳过。
- **强制任务输入**: 由于无法在运行时交互式地输入任务，因此必须在启动命令中通过参数（如 `jvs -T "..."`, `jca -r "..."`, `jma -i "..."`）提供初始任务。如果未提供，程序将报错退出。
- **禁用交互功能**: 会自动禁用一些纯交互式的功能，例如 `jvs` 启动时检测 Git 仓库并询问是否切换到 `jca` 的功能。
- **脚本执行超时**: 为了防止自动化脚本被意外挂起，在非交互模式下，由 `execute_script` 工具执行的脚本默认有 **5分钟** 的超时限制。

此参数是实现 Jarvis 自动化的关键，适用于所有需要无人值守执行的场景。

---

## 4.3 通用代理 (`jarvis` / `jvs`)

`jvs` 是您的通用AI助手，适用于各种开放式、非特异性的任务。

### 核心能力
-   **任务分析与规划**: 理解复杂目标并拆解为执行步骤。
-   **多工具协同**: 智能选择并组合使用文件读写、代码执行、网页搜索等工具。
-   **系统交互**: 能够执行 Shell 命令与您的操作系统进行交互。
-   **预定义任务**: 支持从配置文件加载预设任务，简化重复性工作。

### 常用参数
| 参数                | 描述                             |
| ------------------- | -------------------------------- |
| `-T`, `--task`      | 直接从命令行提供初始任务。         |
| `-f`, `--config`    | 指定自定义配置文件的路径。         |
| `-g`, `--llm-group` | 临时指定模型组，覆盖默认配置。 |
| `-G`, `--tool-group`| 临时指定工具组，覆盖默认配置。 |
| `--restore-session` | 从 `.jarvis/saved_session.json` 恢复上一次的会话。 |
| `-e`, `--edit`      | 快速编辑默认的 `~/.jarvis/config.yaml` 配置文件。|
| `--share-methodology` | 分享本地方法论到中心方法论仓库。 |
| `--share-tool`      | 分享本地工具到中心工具仓库。 |
| `-I`, `--interactive-config` | 启动交互式配置向导：在当前配置基础上对所有可选项进行询问，默认值取自现有配置；保存后继续启动（如无配置文件则进入完整引导并退出）。 |
| `-D`, `--disable-methodology-analysis` | 禁用方法论和任务分析（覆盖配置文件设置）。适用于快速直达的指令式对话；等效于将本次会话的 use_methodology/use_analysis 设为 false。 |
| `--backup-data`     | 备份所有 Jarvis 数据（`~/.jarvis`）到 `~/jarvis_backups/` 目录。 |
| `--restore-data <路径>` | 从指定的压缩包恢复 Jarvis 数据。此操作会覆盖现有数据，请谨慎使用。 |
| `-n`, `--non-interactive` | 启用非交互模式，用于自动化脚本。详见“通用交互技巧”章节。 |

### 示例

**1. 交互式对话与预定义任务**
直接运行 `jvs` 会进入交互模式。如果存在预定义任务文件（`~/.jarvis/pre-command` 或 `./.jarvis/pre-command`），`jvs` 会首先列出这些任务供您选择，极大方便了日常操作的复用。
```bash
# 启动交互式会话，并可能会提示选择预定义任务
jvs
```

**2. 直接执行任务**
让 Jarvis 分析当前项目结构并生成一份报告。
```bash
jvs -T "分析当前目录下的代码，总结项目的主要模块和功能"
```

**3. 解决环境问题**
当您遇到一个复杂的环境问题时，可以请求 Jarvis 帮助。
```bash
jvs -T "我的 docker 服务无法启动，请帮我诊断问题并尝试修复。相关日志在 /var/log/docker.log"
```

**4. 使用特定工具组**
通过 `--tool-group` 参数临时切换到特定的工具集。
```bash
# 使用只读的受限工具组进行代码分析
jvs --tool-group restricted -T "分析这个项目的代码结构"

# 使用文档处理工具组
jvs --tool-group document -T "搜索关于 Python asyncio 的最佳实践"
```

**5. 交互式配置（覆盖设置）**
在启动前对所有可选项进行交互式确认，默认值取自当前配置；保存后继续启动：
```bash
# 使用默认配置文件进行交互式配置
jvs -I

# 或对指定配置文件进行交互式配置
jvs -I -f ./myconfig.yaml
```

**6. 数据备份与恢复**
您可以轻松地备份和恢复您的所有 Jarvis 数据，包括配置、记忆、历史记录等。

备份您的数据：
```bash
# 这将在 ~/jarvis_backups/ 目录下创建一个带时间戳的 zip 压缩包
jvs --backup-data
```

从备份恢复数据：
```bash
# 恢复操作会覆盖 ~/.jarvis 目录，请务必小心
# 程序会请求您二次确认
jvs --restore-data ~/jarvis_backups/jarvis_data_20231026_103000.zip
```

### Web 模式（浏览器交互）

Jarvis 支持通过浏览器进行交互式使用，并提供标准输入/输出的实时重定向与控制通道，适合观察执行过程、与交互式命令对话以及日常工作展示。

核心特性：
- 浏览器终端交互：内置 xterm 终端展示输出，支持清屏与自动换行优化。
- STDIO 重定向：后端的标准输出/错误（stdout/stderr）将实时通过独立通道推送到浏览器。
- STDIN 输入：在浏览器终端内输入的按键会注入后端 STDIN，交互式命令（如 Python REPL、某些 CLI）可直接在浏览器中使用。
- 每任务新建 Agent：通过“发送为新任务”提交的每一次任务，系统都会创建一个全新的 Agent 实例处理，任务之间互不干扰。
- 干预与终端尺寸：页面提供“干预”按钮，可向后端发送中断信号；浏览器会上报终端尺寸，后端据此优化输出宽度。
- 后台运行与停止：默认以后台进程方式启动，支持通过 --stop 快速停止，按端口区分多实例。

基本用法：
```bash
# 1) 在本机后台启动 Web 服务（默认 127.0.0.1:8765）
jarvis --web

# 打开浏览器访问
# http://127.0.0.1:8765

# 页面上：
# - 在下方输入区输入任务，点击“发送为新任务”
# - 任务期间输入区会禁用；若 Agent 请求输入或确认，会弹出提示/对话
# - “干预”按钮可发送中断信号（相当于在执行前打断工具调用）
```

常用参数：
```bash
# 指定服务地址与端口（默认 127.0.0.1:8765）
jarvis --web --web-host 0.0.0.0 --web-port 8888

# 停止后台 Web 服务（按端口定位，默认 8765）
jarvis --web --stop
jarvis --web --stop --web-port 8888
```

说明与建议：
- 安全性：默认仅监听本机（127.0.0.1）。如需局域网访问，请使用 --web-host 0.0.0.0，并结合防火墙/反向代理进行访问控制。
- 多实例：不同端口的实例互不影响；每个实例会在 ~/.jarvis 下维护独立的 PID 文件（jarvis_web_{port}.pid）。
- 停止机制：--stop 会优先根据 PID 文件停止；若 PID 文件丢失，也会按端口尝试停止并清理残留 PID 文件。
- 终端体验：浏览器会自动上报终端尺寸到后端，用于动态调整输出宽度，改善表格/换行显示效果。

### 启动前的可选交互

根据配置，`jvs` 在启动前可能会出现以下可选交互行为（默认关闭，可在首次运行时交互启用，或在配置文件中开启）：

1) 列出内置配置供选择（agent/multi_agent/roles）
   - 若开启，会扫描项目内置的 `builtin/agent`、`builtin/multi_agent`、`builtin/roles` 目录，展示可用清单，您可直接选择启动对应命令：
     - 选择 agent 配置将启动 `jarvis-agent -c <文件>`
     - 选择 multi_agent 配置将启动 `jarvis-multi-agent -c <文件>`
     - 选择 roles 配置将启动 `jarvis-platform-manager role -c <文件>`
   - 配置项：`JARVIS_ENABLE_STARTUP_CONFIG_SELECTOR: true`

2) Git 仓库检测并提示切换到代码开发模式（jca）
   - 若开启，且当前目录在 Git 仓库中，启动 `jvs` 时会提示是否切换到 `jca`（jarvis-code-agent），以便获得更好的代码任务体验。
   - 配置项：`JARVIS_ENABLE_GIT_JCA_SWITCH: true`

可在 `~/.jarvis/config.yaml` 中设置：
```yaml
JARVIS_ENABLE_GIT_JCA_SWITCH: false
JARVIS_ENABLE_STARTUP_CONFIG_SELECTOR: false
```

## 4.4 代码代理 (`jarvis-code-agent` / `jca`)

`jca` 是专为软件开发任务设计的代理，是您日常编码、重构和调试的得力助手。

### 核心能力
-   **深度代码集成**: 自动分析代码库结构、依赖关系和最近的提交历史，为任务提供全面的上下文。
-   **自动化 Git 工作流**:
    -   **自动检查点（预处理）**: 进入任务前，如检测到未提交更改，将通过 GitCommitTool 进行一次规范化提交（支持 --prefix/--suffix 自定义），或按配置仅告警继续。
    -   **增量式变更（交互式补丁）**: 在 AI 的每一步操作（如修改文件）后，都会生成一个包含 `diff` 的补丁，并引导您确认是否将其 commit。
    -   **任务后审查（最终归并）**: 整个任务完成后将列出本次会话内的提交；您可选择“接受”（系统会先重置回任务起点，然后由 GitCommitTool 生成一条统一且规范的最终提交）或直接重置回任务开始前的状态。
-   **静态代码分析**: 在生成代码修改后，会自动推荐并可运行 `lint` 工具进行静态分析，以确保代码质量（可由配置项开启/关闭）。

### 常用参数
| 参数                | 描述                             |
| ------------------- | -------------------------------- |
| `-r`, `--requirement` | 提供代码相关的需求描述。           |
| `-g`, `--llm-group` | 临时指定模型组，覆盖默认配置。 |
| `-G`, `--tool-group`| 临时指定工具组，覆盖默认配置。 |
| `--append-tools`    | 追加的工具列表，多个工具用逗号分隔，如: read_icenter_page,get_weather |
| `--restore-session` | 从 `.jarvis/saved_session.json` 恢复上一次的会话。 |
| `--prefix <文本>`   | 为生成的提交信息主题添加前缀（空格分隔，适合任务ID/标记）。 |
| `--suffix <文本>`   | 为生成的提交信息末尾添加后缀（换行后追加，适合签名/审阅者）。 |
| `-n`, `--non-interactive` | 启用非交互模式，用于自动化脚本。详见“通用交互技巧”章节。 |

### 示例

**1. 添加新功能**
在项目中添加一个新功能，`jca` 会自动查找相关文件并进行修改。
```bash
jca -r "在用户认证模块中，增加一个'忘记密码'的功能。需要创建一个新的API端点 /api/forgot-password，并实现发送重置邮件的逻辑。"
```

**2. 修复 Bug**
根据 Bug 描述修复问题。
```bash
jca -r "修复 src/utils/calculator.py 中的除零错误。当除数为零时，应该返回一个错误提示而不是抛出异常。"
```

**3. 代码重构**
优化现有代码。
```bash
jca -r "重构 src/services/user_service.py 文件，将其中过长的 'create_user' 方法拆分为多个更小的私有方法，提高代码可读性。"
```

## 4.5 平台管理器 (`jarvis-platform-manager` / `jpm`)

`jpm` 是您与底层大模型平台交互和管理的工具。

### 子命令
-   `info`: 列出所有支持的平台和模型。
-   `chat`: 与指定的平台和模型进行交互式对话。
-   `service`: 将指定的模型以 OpenAI 兼容的 API 形式暴露出来。
-   `role`: 加载预定义的角色配置文件，选择角色后进行对话。

### 示例

**1. 查看可用模型**
```bash
jpm info
```

**2. 与特定模型聊天**
首先，使用 `jpm info` 查找您想使用的平台和模型名称。然后，通过 `-p` 和 `-m` 参数指定它们来开始对话。
```bash
# 示例：假设您通过 jpm info 查到并想使用 "zhipu" 平台的 "glm-4" 模型
jpm chat -p zhipu -m glm-4
```
在 `chat` 模式中，您还可以使用以下命令：
-   `/bye`: 退出对话。
-   `/clear`: 清空当前会话历史。
-   `/upload <文件路径>`: 上传文件供 AI 分析（需要平台支持）。
-   `/shell <命令>`: 在本地执行 Shell 命令。
-   `/save <文件名>`: 将 AI 的最后一条回复保存到文件。
-   `/saveall <文件名>`: 将整个对话历史保存到文件。
-   `/save_session <文件名>`: 保存当前会话状态（可用于后续加载）。
-   `/load_session <文件名>`: 加载之前保存的会话状态。

**3. 启动本地API服务**
将腾讯元宝模型封装为本地 API，供其他应用调用。当客户端请求未指定模型时，将默认使用元宝模型。
```bash
jpm service --host 0.0.0.0 --port 8000 -p yuanbao -m Tencent-HunYuan-Pro
```


**4. 加载角色进行对话**
使用角色配置文件（默认为 `~/.jarvis/roles.yaml`）来启动一个特定角色的对话。
```bash
# 1. jpm会首先列出 roles.yaml 中定义的所有角色
# 2. 用户选择一个角色后，jpm会使用该角色预设的平台、模型和系统提示开始对话
jpm role

# 你也可以通过参数临时覆盖角色配置中的平台和模型
# 使用 jpm info 查找可用的 platform_name 和 model_name
jpm role -c ./my_roles.yaml -p <platform_name> -m <model_name>
```

## 4.6 Git提交助手 (`jarvis-git-commit` / `jgc`)

`jgc` 能自动分析您的代码变更，并生成符合规范的 Git 提交信息。

### 核心能力
-   **自动分析 `git diff`**: `jgc` 会自动暂存 (`git add .`) 您工作区中的所有变更，并分析其 `diff` 内容。
-   **智能处理大型变更**: 如果代码变更非常大，`jgc` 会自动将 `diff` 保存为临时文件并上传，而不是直接注入到提示词中，避免超出模型上下文限制。
-   **生成规范的提交信息**: 基于代码变更，AI 会生成符合[约定式提交（Conventional Commits）](https://www.conventionalcommits.org/)规范的提交信息。
-   **完全可定制**: 您可以通过配置文件自定义 `jgc` 的所有行为，包括提交信息模板和前后缀。

### 常用参数
| 参数 | 描述 |
|---|---|
| `--prefix <文本>` | 在生成的提交信息主题前添加一个固定的前缀。 |
| `--suffix <文本>` | 在生成的提交信息末尾添加一个固定的后缀（换行后追加）。 |
| `--root-dir <路径>` | 指定要操作的 Git 仓库根目录（默认为当前目录）。 |
| `-t/--llm-type <类型>` | 使用的LLM类型，可选值：'normal'（普通）或 'thinking'（思考模式），默认为 'normal'。 |
| `-g/--llm-group <组名>` | 使用的模型组，覆盖配置文件中的设置。 |

### 示例与定制

**1. 基本用法**
当您完成了一些代码修改后，只需在项目根目录运行：
```bash
# jgc 会自动暂存所有变更，无需手动 git add
jgc
```
Jarvis 将会分析变更，生成一条类似 `feat(auth): add password reset endpoint` 的提交信息，并自动执行 `git commit`。

**2. 添加前缀和后缀**
如果您希望在提交信息中包含任务ID或特定的标记，可以使用 `--prefix` 和 `--suffix`：
```bash
jgc --prefix "JIRA-123:" --suffix "Reviewed-by: @YourName"
```
生成的提交信息会变成类似：
```
JIRA-123: feat(auth): add password reset endpoint

Reviewed-by: @YourName
```

**3. 自定义提交模板 (高级)**
`jgc` 最强大的功能之一是允许您完全重写用于生成提交信息的提示词模板。您可以在 `~/.jarvis/config.yaml` 文件中通过设置 `JARVIS_GIT_COMMIT_PROMPT` 变量来定义自己的模板。

首先，通过 `jvs -e` 打开配置文件，然后添加 `JARVIS_GIT_COMMIT_PROMPT` 变量：
```yaml
# ~/.jarvis/config.yaml

# ... 其他配置 ...

JARVIS_GIT_COMMIT_PROMPT: |
  请为以下代码变更生成一条符合【Angular提交规范】的中文提交信息。

  # 规则
  1. 必须包含类型、范围和主题。
  2. 类型只能是：'新功能', '修复', '文档', '格式', '重构', '测试', '构建', '持续集成'。
  3. 范围必须是代码中被修改的模块名。
  4. 详细描述部分要解释修改的原因和带来的好处。

  # 变更内容
  {diff}
```
通过自定义此模板，您可以让 `jgc` 完全遵循您团队的特定提交规范。

## 4.7 本地知识库 (`jarvis-rag` / `jrg`)

`jrg` 用于构建和查询基于您自己文档的本地知识库。

### 工作原理
`jrg` 会读取您指定的文本文件，使用**嵌入模型（Embedding Model）** 将其内容转换为向量，并存储在本地的**向量数据库**中。当您提问时，它会：
1.  将您的问题也转换为向量。
2.  在数据库中检索与问题向量最相关的文档片段。
3.  将这些文档片段和您的原始问题一起提交给**大语言模型（LLM）**，由 LLM 生成最终的、基于上下文的答案。

### 子命令
-   `add`: 添加文档（文件、目录、通配符）到知识库。
-   `list-docs`: 列出知识库中的所有文档。
-   `retrieve`: 仅从知识库检索相关文档，不生成答案。支持 --rewrite/--no-rewrite 控制查询重写（默认开启）。
-   `query`: 向您的知识库提问。

### 核心功能与定制

**1. 智能文件过滤**
在添加文档时，`jrg` 会自动执行以下操作：
- **递归扫描**: 自动遍历您指定的目录。
- **二进制文件检测**: 自动跳过图片、可执行文件等非文本内容。
- **忽略规则**: 默认情况下，`jrg` 会遵循项目根目录下的 `.gitignore` 规则。为了更精细地控制，您可以在项目根目录创建 `.jarvis/rag/.ragignore` 文件，其优先级高于 `.gitignore`。这对于排除测试数据、大型日志文件或不想被索引的文档非常有用。

**2. 构建知识库**
`jrg add` 命令支持递归地添加整个目录和多个文件。
```bash
# 添加 src 和 docs 目录，以及根目录的 README.md
# jrg 会自动应用 .gitignore 或 .ragignore 规则
jrg add ./src ./docs README.md
```
您还可以使用 `--collection` 参数来管理多个独立的知识库，例如：
```bash
# 为项目A创建一个专门的知识库
jrg add ./project-a/src --collection project-a-docs

# 为项目B创建另一个知识库
jrg add ./project-b/src --collection project-b-docs
```

**3. 查询知识库**
使用 `jrg query` 向知识库提问。默认情况下，它会查询名为 `jarvis_rag_collection` 的主知识库。
```bash
jrg query "在我们的项目中，'PlatformRegistry' 这个类是用来做什么的？"
```
如果要查询特定知识库，或使用特定的 LLM（而非默认配置的思考模型）来生成答案，可以使用相应参数：
```bash
# 查询 project-a-docs 知识库，并指定使用 zhipu 平台的 glm-4 模型来生成答案
jrg query --collection project-a-docs -p zhipu -m glm-4 "介绍一下 project-a 的认证流程"
```

**4. 仅检索模式（retrieve）**
当你只需要查看与问题相关的“检索结果”（文档片段），而不需要由 LLM 生成答案时，使用 `retrieve` 更轻量，适合调试与验证召回质量。

```bash
# 仅检索，不生成答案。默认会对查询做一次 LLM 重写以提升召回
jrg retrieve "如何配置 RAG 的嵌入模型？"

# 禁用查询重写（保持原始查询词）
jrg retrieve --no-rewrite "如何配置 RAG 的嵌入模型？"

# 控制检索条数（默认为 5）
jrg retrieve --top-n 8 "Jarvis RAG 支持的忽略规则是什么？"
```

参数说明：
- --rewrite/--no-rewrite：是否对查询进行 LLM 重写以提升召回，默认开启。
  - 建议在无可用 LLM 平台、离线环境或需要严格保持原始关键字检索时使用 --no-rewrite。
- --top-n：返回的文档数量，默认 5。
- 其他参数与 query 相同：--collection、--embedding-model、--db-path。

输出说明：`retrieve` 会直接打印每条检索到的文档内容及其来源路径（source），不调用 LLM 生成答案。

**5. 列出已索引文档**
使用 `jrg list-docs` 可以查看指定知识库中包含了哪些源文件。
```bash
jrg list-docs --collection project-a-docs
```

**6. 自定义 RAG 模型**
`jrg` 默认使用 `BAAI/bge-m3` 作为嵌入模型和 `BAAI/bge-reranker-v2-m3` 作为重排模型。您可以通过 `config.yaml` 文件来覆盖这些默认设置，以使用更适合您数据或硬件的模型。

例如，要切换到 `moka-ai/m3e-base` 嵌入模型，可以这样配置：
```yaml
# ~/.jarvis/config.yaml

# ... 其他配置 ...

JARVIS_RAG:
  embedding_model: "moka-ai/m3e-base"
  # 如果您也想更换重排模型，可以在这里添加 rerank_model 键
  # rerank_model: "some-other-reranker"
  use_bm25: true  # 是否启用 BM25 稀疏检索，默认为 true
  use_rerank: true # 是否启用重排模型，默认为 true
```
这个配置会让 `jrg` 在下一次构建或查询知识库时使用您指定的新模型。

与模型配置类似，RAG 也支持通过 `JARVIS_RAG_GROUPS` 和 `JARVIS_RAG_GROUP` 来定义和切换不同的 RAG 配置组合。这对于在不同类型的知识库（例如，代码库 vs. 文档库）之间切换，或者测试不同嵌入/重排模型的效果非常有用。

**示例：定义和使用 RAG 组**

```yaml
# ~/.jarvis/config.yaml

# 1. 定义不同的 RAG 配置组
JARVIS_RAG_GROUPS:
  - text: # "text" 是组名
      embedding_model: BAAI/bge-m3
      rerank_model: BAAI/bge-reranker-v2-m3
      use_bm25: true
      use_rerank: true
  - code: # "code" 是组名
      embedding_model: Qodo/Qodo-Embed-1-1.5B
      use_bm25: false
      use_rerank: false

# 2. 选择要使用的 RAG 组
JARVIS_RAG_GROUP: code

# 3. (可选) 顶层配置会覆盖组配置
# 如果取消下面这行的注释，即使激活了 code 组，
# use_bm25 仍然会是 true。
# JARVIS_RAG:
#   use_bm25: true
```

### 工具配置组

Jarvis 支持通过 `JARVIS_TOOL_GROUPS` 和 `JARVIS_TOOL_GROUP` 来定义和切换不同的工具组合。这对于不同类型的任务（例如，代码开发 vs. 文档处理 vs. 系统管理）非常有用，可以通过配置快速切换可用的工具集。

**示例：定义和使用工具组**

```yaml
# ~/.jarvis/config.yaml

# 1. 定义不同的工具配置组
JARVIS_TOOL_GROUPS:
  - coding:  # 代码开发组
      use:  # 只使用这些工具
        - execute_script
        - read_code
        - rewrite_file
        - ask_user
        - save_memory
        - retrieve_memory
  - document:  # 文档处理组
      use:
        - search_web
        - ask_user
        - save_memory
        - retrieve_memory
  - system:  # 系统管理组
      dont_use:  # 排除这些工具
        - search_web
  - restricted:  # 受限组
      use:
        - ask_user
        - read_code
      # 只允许使用ask_user和read_code，适合只读场景

# 2. 选择要使用的工具组
JARVIS_TOOL_GROUP: coding

# 注意：
# - 如果配置了 use 列表，则只有列表中的工具可用
# - 如果配置了 dont_use 列表，则排除列表中的工具
# - 如果同时配置了 use 和 dont_use，use 优先级更高
# - 默认情况下（不设置工具组），所有工具都可用
```

通过工具配置组，您可以：
- **提高安全性**：在某些场景下限制可用工具，避免误操作
- **优化体验**：为特定任务类型提供精简的工具集
- **快速切换**：通过修改 `JARVIS_TOOL_GROUP` 快速切换工作模式

## 4.8 智能Shell (`jarvis-smart-shell` / `jss`)

`jss` 是一个强大的工具，可以将您的自然语言指令转换为可执行的 Shell 命令，极大降低了在终端中执行复杂操作的门槛。

### 子命令
-   `request [需求]`: 将自然语言需求转换为 Shell 命令。如果未提供需求，则进入交互式输入模式。
-   `install`: 为 `fish` shell 安装“命令未找到”处理器。
-   `uninstall`: 卸载 `fish` shell 的处理器。

### 示例

**1. 直接转换命令**
当您不确定某个操作的命令时，可以直接向 `jss` 提问。它会打印出对应的 Shell 命令，但**不会执行**。
```bash
jss request "查找当前目录下所有大于1MB的.log文件"
# 输出: find . -type f -name "*.log" -size +1M
```

**2. 交互式执行命令**
如果您直接运行 `jss request` 而不带任何参数，它会启动一个交互式输入界面。在这种模式下，您输入需求后，生成的命令将**被立即执行**。
```bash
# 启动交互模式
jss request

# 在提示符后输入: 查找当前目录下所有大于1MB的.log文件，然后按 Ctrl+J
# jss 会打印并执行 find 命令
```

**3. 安装“命令未找到”处理器 (仅支持 Fish Shell)**
这是 `jss` 的一个强大功能，它能让您像使用自然语言一样操作终端。
```bash
# 1. 安装处理器
jss install

# 2. 使配置生效 (只需执行一次)
source ~/.config/fish/config.fish
```
安装后，当您在 `fish` 终端中输入一个系统不认识的命令（且长度大于10个字符，以防误触）时，`jss` 会自动拦截这个输入，将其转换为有效的 Shell 命令并执行。
```fish
# 在安装了处理器的 fish shell 中，直接输入:
> 在当前目录创建一个名为 'backup' 的文件夹

# jss 会自动将其转换为并执行: mkdir backup
```

**4. 卸载处理器**
```bash
# 1. 卸载处理器
jss uninstall

# 2. 使配置生效
source ~/.config/fish/config.fish
```

## 4.9 代码审查 (`jarvis-code-review` / `jcr`)

`jcr` 是您的自动化代码审查员，可以针对单个提交、文件或当前工作区的变更提供深入的分析和改进建议。

### 工作原理
`jcr` 的审查流程高度自动化和智能化：
1.  **变更提取**: 根据您指定的模式（如单个提交、范围或文件），`jcr` 会自动提取相应的代码 `diff`。
2.  **语言检测**: 它会分析变更文件的扩展名，自动识别涉及的编程语言（如 Python, Go, Java, TypeScript 等）。
3.  **注入审查清单**: 对于每种识别出的语言，`jcr` 会加载一个专门的**审查清单**（Checklist），并将其与代码变更一起注入到提示词中。
4.  **全面审查框架 (SCRIPPPS)**: AI 会遵循一个名为 **SCRIPPPS** 的内置框架进行审查，该框架覆盖七个维度：**S**ecurity（安全）、**C**orrectness（正确性）、**R**eliability（可靠性）、**I**nterface（接口）、**P**erformance（性能）、**P**ortability（可移植性）和 **S**tructure（结构）。
5.  **生成报告**: 最终，AI 会生成一份详细的 Markdown 格式的审查报告，其中包含对每个问题的分类、严重程度评级、详细描述和具体的修复建议。

### 子命令
-   `commit <commit-sha>`: 审查指定的单个提交。
-   `current`: 审查您当前 `git` 工作区中已暂存和未暂存的变更。
-   `range <commit1>..<commit2>`: 审查指定范围内的所有提交。
-   `file <文件路径...>`: 审查一个或多个文件。

### 通用参数
所有子命令都支持以下参数：

| 参数 | 描述 |
|---|---|
| `--root-dir <路径>` | 指定要操作的代码仓库根目录（默认为当前目录）。 |
| `-t/--llm-type <类型>` | 使用的LLM类型，可选值：'normal'（普通）或 'thinking'（思考模式），默认为 'normal'。 |
| `-g/--llm-group <组名>` | 使用的模型组，覆盖配置文件中的设置。 |

### 示例

**1. 审查上一个提交**
```bash
jcr commit HEAD~1
```

**2. 审查当前所有变更**
在提交代码前，进行一次自我审查。`jcr` 会自动分析 `git diff HEAD` 的结果。
```bash
# 无需手动暂存，jcr 会自动处理
jcr current
```

**3. 审查指定范围的提交**
审查从 `main` 分支切出新功能分支以来的所有变更。
```bash
jcr range main..HEAD
```

**4. 审查单个或多个文件**
```bash
jcr file src/jarvis/jarvis_agent/jarvis.py src/jarvis/jarvis_utils/config.py
```

## 4.10 高级Git工具

除了 `jgc`，Jarvis 还提供了一系列高级 Git 工具来简化复杂操作。

### 交互式 Squash (`jarvis-git-squash` / `jgs`)

`jgs` 可以帮助您将从某个指定提交之后的所有提交，自动合并（squash）成一个全新的、独立的提交，并为其生成一条清晰的、总结性的提交信息。这在合并多个小的功能提交或修复提交时非常有用。

#### 工作原理
1.  **确认操作**: `jgs` 会首先请求您确认 squash 操作。
2.  **重置（Reset）**: 它会执行 `git reset --mixed <您指定的基础提交>`。这个操作会将 `HEAD` 指针移回您指定的提交，同时保留这期间所有的代码变更在您的工作区。
3.  **重新提交**: 最后，`jgs` 会调用 `jgc` (Git 提交助手)，将工作区中所有的变更作为一个全新的提交，并由 AI 分析这些变更，生成一条高质量的总结性提交信息。

#### 参数
| 参数 | 描述 |
|---|---|
| `commit_hash` | **必需**。您希望作为合并基础的提交哈希。此提交**之后**的所有提交都将被合并。|
| `--lang` | 指定生成提交信息时使用的语言（默认为中文）。 |

#### 示例
假设您的提交历史如下，您想将 `feat-a`, `feat-b`, `fix-c` 这三个提交合并成一个。
```
* 2d3d4d5 (HEAD -> main) fix-c
* a1b2c3d feat-b
* f9e8d7c feat-a
* c1a2b3d (base-commit) initial structure  <-- 这是我们的合并基础
```

运行以下命令，其中 `c1a2b3d` 是您希望保留的最后一个提交的哈希值：
```bash
jgs c1a2b3d
```
`jgs` 会自动完成上述的 `reset` 和重新提交工作，最终您的提交历史会变成：
```
* 3e4f5g6 (HEAD -> main) feat(new-feature): add a, b and fix c
* c1a2b3d (base-commit) initial structure
```

## 4.11 多智能体协作 (`jarvis-multi-agent` / `jma`)

`jma` 是一个强大的多智能体（Multi-Agent）协作框架，它允许您定义一组具有不同角色和能力的 AI 智能体，并通过自动化的消息路由机制，让它们协同工作以完成复杂任务。

### 工作原理
`jma` 的核心是一个基于 YAML 配置的协作系统：
1.  **定义智能体**: 您在一个 YAML 文件中定义多个智能体，每个智能体都有自己的 `name`（名称）、`description`（描述）和 `system_prompt`（系统提示词），这决定了它的角色和能力。
2.  **指定主智能体**: 在配置中，您需要指定一个 `main_agent`，作为整个任务的入口和协调者。
3.  **消息驱动的协作**: 当一个智能体需要另一个智能体的帮助时，它会生成一个特殊的 `<SEND_MESSAGE>` 消息块。`jma` 框架会自动捕获此消息，并将其路由给指定的目标智能体。
4.  **自主运行**: 这个过程会持续进行，直到主智能体认为任务完成，不再发送新的消息为止。

### 核心参数
| 参数 | 描述 |
|---|---|
| `-c`, `--config` | **必需**。指定定义了智能体角色和工作流的 YAML 配置文件。|
| `-i`, `--input` | 提供给智能体系统的初始任务输入。如果未提供，则会进入交互式输入模式。|
| `-n`, `--non-interactive` | 启用非交互模式，用于自动化脚本。详见“通用交互技巧”章节。|

### 示例：构建一个市场研究团队

假设我们想创建一个由“市场研究员”和“报告撰写者”组成的团队，来分析一个产品的市场潜力。

**1. 创建配置文件 `market_research.yaml`**
首先，我们定义两个智能体和它们的工作流程：
```yaml
# market_research.yaml

# 定义主智能体，任务将从这里开始
main_agent: MarketResearcher

# 定义所有可用的智能体
agents:
  - name: MarketResearcher
    description: "一个专业的市场研究员，擅长使用工具进行网络搜索和数据分析。"
    # system_prompt 定义了该智能体的角色和可用工具
    system_prompt: |
      你是一名市场研究员。你的任务是分析给定产品的市场潜力和竞争格局。
      你需要使用 `search_web` 工具来收集信息。
      在收集到足够的信息后，将你的发现总结并发送给 'ReportWriter'。
    # 为该智能体配置可用的工具
    use_tools:
      - search_web

  - name: ReportWriter
    description: "一个专业的分析报告撰写者，擅长将零散的信息整合成结构化的报告。"
    system_prompt: |
      你是一名报告撰写者。你的任务是接收来自 'MarketResearcher' 的研究结果，
      并基于这些结果撰写一份条理清晰、格式专业的市场分析报告。
      这是你最终需要交付的成果，请确保报告的完整性。
```

**2. 运行 jma**
现在，我们可以使用这个配置文件来启动多智能体系统，并给它分配一个任务：
```bash
jma --config ./market_research.yaml --input "分析 'AI代码助手' 这个产品的市场潜力和主要竞争对手"
```
**执行流程**:
1.  任务首先被发送给 `MarketResearcher`。
2.  `MarketResearcher` 会调用 `search_web` 工具搜索“AI代码助手”的相关信息。
3.  完成研究后，`MarketResearcher` 会生成一条 `<SEND_MESSAGE>` 发送给 `ReportWriter`，内容是它的研究总结。
4.  `ReportWriter` 接收到信息后，会撰写并输出最终的市场分析报告。

## 4.12 工具管理 (`jarvis-tool` / `jt`)

`jt` 是与 Jarvis 工具系统交互的命令行界面，它不仅能让您查看和调用现有工具，更是您扩展 Jarvis 能力的重要入口。

### 子命令
-   `list`: 列出所有AI可用的工具。
-   `call <工具名>`: 直接从命令行调用一个工具。
-   `stat`: 显示每个工具被AI调用的频率统计。

### 核心功能与示例

**1. 查看工具**
`list` 命令是探索 Jarvis 能力的起点。
```bash
# 查看所有工具的名称和描述
jt list

# 以 JSON 格式输出，方便脚本处理
jt list --json

# 显示工具的详细信息，包括其参数定义
jt list --detailed
```

**2. 调用工具**
`call` 命令允许您直接测试或使用任何一个工具。
```bash
# 示例：调用网页搜索工具
jt call search_web --args '{"query": "Jarvis AI assistant on GitHub"}'

# 对于复杂参数，可以从文件加载
# 1. 创建 a.json 文件，内容为: {"query": "How to use Jarvis RAG?"}
# 2. 通过 --args-file 参数调用
jt call search_web --args-file ./a.json
```

**3. 查看工具使用统计**
`stat` 命令可以帮助您了解哪些工具被 AI 使用得最频繁。
```bash
jt stat
```

### 扩展 Jarvis 工具

`jt` 真正的强大之处在于其可扩展性。Jarvis 会从以下位置自动加载工具，让您可以轻松添加新功能：

**方式一：通过 Python 文件添加工具**
您可以将自定义的工具脚本（遵循特定的类结构）放置在以下目录中，Jarvis 启动时会自动加载它们：
-   `~/.jarvis/tools/`
-   在 `config.yaml` 中由 `JARVIS_TOOL_LOAD_DIRS` 变量指定的其他目录。

如果这些目录是 Git 仓库，Jarvis 还会每日自动执行 `git pull` 来保持工具更新。

**方式二：通过 MCP (Model Context Protocol) 添加工具**
MCP (模型上下文协议) 是一种更高级的集成方式，它允许 Jarvis 与外部服务（如另一个AI模型、API服务等）进行通信，并将该服务的能力封装为 Jarvis 工具。您可以通过在 `~/.jarvis/mcp/` 目录下创建 `.yaml` 配置文件，或直接在主 `config.yaml` 中定义 `JARVIS_MCP` 列表来注册 MCP 工具。

通过这两种方式，您可以不断地为 Jarvis 赋予新的能力，使其能解决更多领域的问题。

## 4.13 记忆系统

Jarvis 内置了强大的记忆系统，帮助您在多次交互中保持上下文连续性，并积累知识和经验。记忆系统通过 `save_memory` 和 `retrieve_memory` 两个核心工具提供服务。

### 记忆类型

Jarvis 支持三种不同的记忆类型，每种都有其特定用途：

**1. 短期记忆 (short_term)**
- **用途**：存储当前任务相关的临时信息
- **生命周期**：仅在当前会话期间有效，不会持久化
- **适用场景**：任务执行过程中的中间结果、临时决策、当前上下文

**2. 项目长期记忆 (project_long_term)**
- **用途**：存储与当前项目相关的持久信息
- **存储位置**：`.jarvis/memory/` 目录
- **适用场景**：项目架构说明、技术栈信息、项目特定约定、API文档等

**3. 全局长期记忆 (global_long_term)**
- **用途**：存储跨项目的通用知识和偏好
- **存储位置**：`~/.jarvis/data/memory/global_long_term/` 目录
- **适用场景**：编程最佳实践、个人偏好设置、通用解决方案、技术笔记等

### 使用示例

**保存记忆**
```bash
# 在交互过程中，告诉 Jarvis 保存重要信息
jvs -T "这个项目使用 FastAPI 框架，数据库是 PostgreSQL，请记住这个信息"
# Jarvis 会自动调用 save_memory 工具，选择合适的记忆类型

# 保存编程技巧到全局记忆
jvs -T "记住这个 Python 性能优化技巧：使用列表推导式比 for 循环更快"
```

**检索记忆**
```bash
# 查询项目相关信息
jvs -T "这个项目使用什么技术栈？"
# Jarvis 会自动从项目长期记忆中检索相关信息

# 查询编程知识
jvs -T "我之前保存过哪些 Python 性能优化的技巧？"
```

### 高级用法



**批量导入知识**
```bash
# 将文档内容导入为记忆
jvs -T "请阅读 ./docs/api_reference.md 文件，并将重要的 API 信息保存到项目记忆中"
```

**记忆关联**
```bash
# 建立相关概念之间的联系
jvs -T "记住：当使用 Redis 缓存时，要考虑数据一致性问题，可以使用发布订阅模式同步缓存"
```

**记忆总结**
```bash
# 让 Jarvis 总结某个主题的所有相关记忆
jvs -T "总结一下我保存的所有关于数据库优化的记忆"
```

通过有效使用记忆系统，您可以让 Jarvis 成为一个真正了解您和您的项目的智能助手，大大提升工作效率。

### 记忆整理工具 (`jarvis-memory-organizer` / `jmo`)

随着时间推移，记忆系统中可能会积累大量相似或重复的记忆。`jmo` 工具提供了整理、合并、导入导出等功能，帮助您高效管理记忆库。

**功能特点**
- 自动识别具有相似标签的记忆并智能合并
- 支持记忆的导入导出，便于备份和迁移
- 使用 AI 智能合并相关记忆，保留所有重要信息
- 优先保留最新的记忆内容（时间权重）
- 支持项目长期记忆和全局长期记忆的管理

**子命令**

#### 1. organize - 整理和合并记忆
```bash
# 整理项目长期记忆（默认）
jmo organize

# 整理全局长期记忆
jmo organize --type global_long_term

# 设置最小标签重叠数为 3
jmo organize --min-overlap 3

# 模拟运行，查看将要合并的记忆但不实际执行
jmo organize --dry-run
```

#### 2. export - 导出记忆
```bash
# 导出所有记忆到文件
jmo export memories.json

# 只导出项目长期记忆
jmo export project_memories.json -t project_long_term

# 导出带特定标签的记忆
jmo export python_memories.json --tag Python --tag API

# 导出多种类型的记忆
jmo export all_memories.json -t project_long_term -t global_long_term
```

#### 3. import - 导入记忆
```bash
# 导入记忆文件
jmo import memories.json

# 导入并覆盖已存在的记忆
jmo import memories.json --overwrite
```

**工作原理**

*整理功能*：
1. 扫描指定类型的所有记忆文件
2. 找出标签重叠度高的记忆组
3. 使用 AI 将相似记忆合并成一个综合性记忆
4. 删除原始记忆，保存合并后的新记忆

*导入导出功能*：
1. 导出：将指定类型和标签的记忆序列化为 JSON 文件
2. 导入：从 JSON 文件恢复记忆到相应的存储位置

**最佳实践**
- 定期运行整理功能（如每周一次）以保持记忆库整洁
- 在整理前使用 export 功能备份重要记忆
- 首次整理建议使用 `--dry-run` 预览效果
- 可以根据项目特点调整 `--min-overlap` 参数
- 使用导入导出功能在不同环境间迁移记忆

## 4.14 方法论管理 (`jarvis-methodology` / `jm`)

`jm` 是用于管理和维护 Jarvis 方法论库的工具。

### 什么是方法论？
在 Jarvis 中，**方法论（Methodology）** 是一套针对特定 **问题类型（Problem Type）** 的、标准化的、可复用的解决方案流程。当 Jarvis 遇到一个新任务时，它会首先尝试匹配已有的方法论。如果找到匹配项，它就会参考这个方法论来制定计划，而不是从零开始思考，从而大大提高解决问题的效率和成功率。

所有的方法论都以“问题类型”为核心，存储在 `~/.jarvis/methodologies` 目录下的独立 JSON 文件中。

### 子命令
-   `import <文件>`: 从一个导出的 JSON 文件中导入方法论，它会与现有的方法论进行合并（新的会覆盖同名的旧的）。
-   `export <文件>`: 将当前所有的方法论导出到一个单一的 JSON 文件中，方便备份和分享。
-   `list`: 列出当前所有方法论的“问题类型”。
-   `extract <文件>`: 从本地的一个文本文件（如一篇技术文章、教程）中，利用 AI 提取并生成新的方法论。
-   `extract-url <URL>`: 从一个网页链接中，利用 AI 读取内容、提取并生成新的方法论。

### 示例

**1. 让 Jarvis 从外部知识中学习**
假设您找到一篇非常好的关于“排查 Kubernetes Pod 启动失败”的博客文章，您可以让 Jarvis 从中学习，并形成自己的方法论。
```bash
# Jarvis 会读取该 URL 的内容，并自动提取和保存相关的解决方案流程
jm extract-url "https://some-blog.com/k8s-pod-troubleshooting"
```
执行后，如果您再次向 Jarvis 提出类似“我的 Pod 启动不了”的问题，它就会优先参考刚刚学到的这套方法论来解决问题。

**2. 查看、备份和分享方法论**
```bash
# 查看您已经积累了哪些方法论
jm list

# 将所有方法论备份到一个文件中
jm export my_methodologies.json

# 在另一台机器上，或者分享给同事后，可以轻松导入
jm import my_methodologies.json
```

**3. 分享方法论到中心仓库**

Jarvis 支持将本地的方法论分享到团队的中心方法论仓库，实现知识共享：

```bash
# 分享本地方法论到中心仓库
jarvis --share-methodology
```

这个功能需要先配置中心方法论仓库地址（参见 [5.功能扩展](5.功能扩展.md) 中的方法论共享配置）。执行后会：
- 自动克隆/更新中心方法论仓库
- 检测并排除已存在的重复方法论
- 允许您选择要分享的方法论（支持批量选择）
- 自动提交并推送到远程仓库

### 中心方法论库使用场景

**1. 团队知识沉淀**
```bash
# 场景：团队成员解决了一个复杂的性能问题，想将解决方案分享给全团队
# 步骤1：先让 Jarvis 学习这个解决方案
jm extract performance_optimization.md

# 步骤2：分享到中心库
jarvis --share-methodology
# 选择刚才生成的"性能优化"方法论
```

**2. 新人快速上手**
```bash
# 场景：新加入的团队成员需要快速了解项目的最佳实践
# 配置中心方法论库后，Jarvis 会自动加载所有团队方法论
export JARVIS_CENTRAL_METHODOLOGY_REPO="https://github.com/team/methodologies.git"

# 新人可以直接使用团队积累的所有方法论
jvs -T "如何进行代码审查？"  # Jarvis 会自动应用团队的代码审查方法论
```

**3. 跨项目经验复用**
```bash
# 场景：在新项目中遇到类似问题，想复用之前项目的解决方案
# 中心库中已有"微服务部署"、"数据库迁移"等方法论
jvs -T "我需要将这个单体应用拆分为微服务"
# Jarvis 会自动匹配并应用"微服务拆分"方法论
```

### 中心工具库使用场景

**1. 企业内部工具集成**
```bash
# 场景：企业有内部的发布系统、监控平台等
# 步骤1：开发适配工具并测试
# 创建 ~/.jarvis/tools/deploy_tool.py

# 步骤2：分享到中心工具库
jarvis --share-tool
# 选择 deploy_tool.py，工具会被移动到中心库

# 团队其他成员配置中心工具库后即可使用
export JARVIS_CENTRAL_TOOL_REPO="https://github.com/company/jarvis-tools.git"
jvs -T "部署应用到生产环境"  # 可以直接调用内部部署工具
```

**2. 领域专用工具包**
```bash
# 场景：数据科学团队需要专门的数据处理工具
# 中心工具库包含：data_cleaning, model_evaluation, dataset_split 等工具

# 配置数据科学工具库
export JARVIS_CENTRAL_TOOL_REPO="https://github.com/team/ml-tools.git"

# 使用专用工具进行数据处理
jvs -T "清洗 dataset.csv 中的异常数据并划分训练集"
```

**3. 安全合规场景**
```bash
# 场景：某些环境需要限制工具使用，只允许经过审核的工具

# 步骤1：配置只使用中心工具库的工具
cat >> ~/.jarvis/config.yaml << EOF
JARVIS_CENTRAL_TOOL_REPO: "https://github.com/company/approved-tools.git"
JARVIS_TOOL_GROUPS:
  - secure:
      use: []  # 不使用任何内置工具
      # 只使用中心工具库中经过审核的工具
JARVIS_TOOL_GROUP: secure
EOF

# 步骤2：这样配置后，Jarvis 只能使用中心库中的受信任工具
```

**4. 工具版本管理**
```bash
# 场景：需要确保团队使用统一版本的工具

# 中心工具库使用 Git 标签管理版本
cd ~/.jarvis/central_tool_repo
git tag -l  # 查看所有版本
# v1.0.0
# v1.1.0
# v2.0.0

# 切换到特定版本
git checkout v1.1.0

# 或者在 CI/CD 中锁定版本
git clone --branch v1.1.0 $JARVIS_CENTRAL_TOOL_REPO
```

### 最佳实践建议

1. **建立审核机制**：中心库应有代码审核流程，确保质量
2. **文档规范**：每个方法论和工具都应有清晰的文档
3. **定期更新**：利用 Jarvis 的自动更新功能保持同步
4. **分类管理**：使用目录结构对方法论和工具进行分类
5. **版本控制**：使用 Git 标签标记重要版本，便于回滚

---

## 4.15 使用统计 (`jarvis-stats` / `jst`)

`jst` 是 Jarvis 的通用统计模块，提供灵活的指标记录和可视化功能。它可以追踪任意类型的数据，包括代码变更、API调用、响应时间等，并提供丰富的查询和展示功能。

### 核心功能
- **灵活的指标管理**: 支持添加任意指标，可设置单位和标签
- **多维度查询**: 按时间范围、标签过滤查询数据
- **可视化展示**: 支持表格、图表、摘要等多种展示格式
- **数据聚合**: 支持按小时或天聚合数据
- **历史数据管理**: 自动存储历史数据，支持清理旧数据

### 主要命令

| 命令    | 描述                           | 示例                                     |
| ------- | ------------------------------ | ---------------------------------------- |
| `add`   | 添加统计数据                   | `jst add response_time 1.5 -u seconds`  |
| `inc`   | 增加计数型指标                 | `jst inc api_calls -a 1`                |
| `show`  | 显示统计数据                   | `jst show response_time -a daily`       |
| `plot`  | 绘制指标折线图                 | `jst plot api_calls -a hourly`          |
| `list`  | 列出所有指标                   | `jst list`                              |
| `clean` | 清理旧数据                     | `jst clean -d 30`                       |
| `export`| 导出统计数据（CSV 到标准输出） | `jst export api_calls > out.csv`        |
| `remove`| 删除指定指标                   | `jst remove api_calls -y`               |
| `demo`  | 运行演示                       | `jst demo`                              |

### 常用参数

| 参数                | 描述                                    | 适用命令                       |
| ------------------- | --------------------------------------- | ------------------------------ |
| `-a`, `--agg`       | 聚合方式 (hourly/daily)                 | show, plot                     |
| `-t`, `--tag`       | 标签过滤，格式: key=value               | add, inc, show, plot, export   |
| `-u`, `--unit`      | 指标单位                                | add                            |
| `-w`, `--width`     | 图表宽度                                | plot                           |
| `-H`, `--height`    | 图表高度                                | plot                           |
| `-d`, `--days`      | 保留最近 N 天（清理旧数据）             | clean                          |

注意：当前 CLI 暂不支持通过 --hours/--days 对 show/plot/export 进行时间范围筛选，也不支持 --format 选择输出格式；export 仅以 CSV 输出到标准输出。如需摘要/JSON 等格式，可在代码中直接调用 StatsManager.show(format=...) 等接口实现。

### 示例

**1. 添加和查看代码变更统计**
```bash
# 添加代码行数变更
jst add code_lines_added 150 -u lines -t "file=main.py" -t "type=feature"
jst add code_lines_deleted 30 -u lines -t "file=main.py" -t "type=refactor"

# 查看代码变更（按天聚合）
jst show code_lines_added -a daily
```

**2. 追踪API响应时间**
```bash
# 记录API响应时间
jst add api_response_time 0.5 -u seconds -t "endpoint=/api/users" -t "status=200"
jst add api_response_time 2.1 -u seconds -t "endpoint=/api/posts" -t "status=500"

# 绘制响应时间图表（可选设置尺寸）
jst plot api_response_time -a hourly -w 80 -H 20
```

**3. 统计模型调用次数**
```bash
# 增加模型调用计数
jst inc llm_calls -t "provider=kimi" -t "model=moonshot-v1"
jst inc llm_calls -t "provider=yuanbao" -t "model=hunyuan-lite"

# 查看各模型的调用统计（按天聚合）
jst show llm_calls -a daily
```

**4. 导出数据进行分析**
```bash
# 导出为CSV格式（当前仅支持 CSV 到标准输出）
jst export api_response_time > response_times.csv

# 导出包含标签信息（同样为 CSV）
jst export llm_calls > llm_usage.csv
```

**5. 查看所有指标概览**
```bash
# 列出所有指标，显示单位、最后更新时间和数据点数
jst list

# 显示所有指标的摘要（不指定指标名）
jst show

**6. 删除指标**
```bash
# 删除指定指标（会提示确认）
jst remove llm_calls

# 跳过确认
jst remove llm_calls -y
```
### 数据存储
统计数据按日期分片存储在 `~/.jarvis/stats/` 目录下，每天的数据保存为独立的 JSON 文件。这种设计确保了：
- 数据安全：每日独立存储，避免数据损坏影响
- 查询效率：按需加载特定日期的数据
- 易于备份：可以选择性备份重要时期的数据

### 使用场景
1. **效率评估**: 定期查看统计，了解 AI 助手的实际贡献
2. **成本分析**: 统计各平台的使用量，优化模型选择
3. **工作汇报**: 用数据展示 AI 辅助开发的成果
4. **优化建议**: 根据使用模式调整工作习惯

