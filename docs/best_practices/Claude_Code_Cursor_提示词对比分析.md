# Claude Code 和 Cursor 提示词对比分析

## 一、Claude Code 的提示词设计特点

### 1.1 核心元素与模式

#### Prompt 模板 + 变量
- **特点**：支持固定内容（static instructions）与可变内容（变量）组合，使用 `{{variable}}` 占位符管理动态输入
- **优势**：标准化 prompt 结构，方便替换与测试
- **参考**：Claude 官方文档支持 prompt templates 和 variables

#### Prompt Generator
- **特点**：内置工具帮助生成高质量、结构化的 prompt 模板
- **优势**：解决"一片空白"的起步难题，自动生成符合最佳实践的提示词

#### 文档化稳定上下文
- **特点**：使用类似 `CLAUDE.md` 的文件保存项目上下文
- **内容**：包括 frameworks、风格约定、技术栈、设计系统、测试策略等
- **优势**：每次交互时读取这些文档来保持一致性

#### 分步骤规划与迭代
- **特点**：先要求 Claude "规划步骤"，再执行
- **流程**：生成测试用例或模块结构 → 实现代码 → 分解任务
- **优势**：避免一次性给出太大笼统的任务

#### 精细上下文与约束
- **特点**：
  - 引用具体文件（如 `@ContactForm.js` 或带行号）以缩小作用范围
  - 指明风格、命名规范、现有模式、设计 tokens、已有组件样式等
  - 设定输出格式、边界（只改某个函数、不修改其他文件等）
- **优势**：确保模型理解正确且不引入不必要的改动

#### 检测与纠错提示
- **特点**：包括"仅显示差异 diff，不解释"或"先审查需求再开始编码"等指令
- **优势**：确保模型理解正确且不引入不必要的改动

---

## 二、Cursor 的提示词体系与规则系统

### 2.1 核心机制与设计

#### Rules（规则）持续上下文系统
- **Project Rules**：项目内 `.cursor/rules/` 下的 `.mdc` 文件，可通过文件路径 globs 或手动调用指定
- **User Rules**：全局习惯与偏好，如编程风格、语言语气等（Settings → Rules）
- **优势**：规则文件在整个对话过程中保持有效，不会因为上下文压缩而丢失

#### AGENTS.md 文件
- **特点**：对于简单项目，可以在项目根目录下放一个 `AGENTS.md` 来定义 instructions
- **优势**：比复杂的 rules 更简单易启用

#### 项目 instructions.md
- **特点**：预先定义项目 "instructions.md" 或类似文件来提供项目整体背景
- **内容**：包括特性、结构、技术栈、约束、依赖等
- **优势**：让 AI 快速理解上下文

#### Prompt 写作原则
- **原则**：
  1. 给清晰上下文
  2. 指定输出格式
  3. 设置约束与边界
  4. 分步操作，而不是一次性大任务

#### Scoped Prompt 与文件级关联
- **特点**：`.mdc` 规则可以设置 glob patterns，只在特定文件被引用时才激活规则
- **优势**：prompt 更相关、更节省 token

#### 确认理解阶段
- **特点**：在写代码之前，先让 Cursor 概要说明它将执行哪些步骤、是否理解任务，检查有没有遗漏
- **优势**：避免误解和跑偏

---

## 三、Claude Code 与 Cursor 的异同点对比

| 项目 | Claude Code | Cursor | Jarvis（当前） |
|------|-------------|--------|----------------|
| **持续上下文存储** | CLAUDE.md、prompt 模板、变量 | `.cursor/rules/` + AGENTS.md + project rules + memories | `.jarvis/rule` + `builtin/rules/` + 规则系统 |
| **模板化与变量占位** | 正式支持 `{{}}` 模板；官方 generator 工具 | `.mdc` 文件 + rule 类型 + globs | Jinja2 模板（`{{variable}}`） |
| **分步计划与确认理解** | "Plan first then code"、测试先行 | 确认阶段 + step wise 指令 | ARCHER 工作流（ANALYZE → RULE → COLLECT → HYPOTHESIZE → EXECUTE → REVIEW） |
| **精细上下文与约束** | 引用文件、技术栈、已有模式、设计系统 | Rules 文件 + instructions md + scoped规则 | load_rule 工具 + 规则系统 |
| **避免 scope 拖延** | 明确文件路径、限定改动范围 | 通过规则、指令设定边界 | 系统提示词中的禁止项和约束 |
| **项目级文档** | CLAUDE.md | AGENTS.md / instructions.md | ❌ 暂无 |
| **Scoped Rules** | ❌ 不支持 | ✅ 支持（glob patterns） | ❌ 不支持 |
| **上下文引用** | 手动上传 | `@file` / `@folder` 引用 | ❌ 不支持 |
| **规则优先级** | ❌ 不支持 | ✅ 支持（Project Rules > User Rules） | ✅ 支持（中心仓库 > 项目 > 全局 > 内置） |

---

## 四、Jarvis 当前提示词系统分析

### 4.1 已有优势

#### ✅ 强大的规则系统
- **多层次规则**：全局规则、项目规则、内置规则、中心规则仓库
- **模板支持**：Jinja2 模板变量，支持动态渲染
- **规则索引**：通过索引文件管理规则，支持灵活引用
- **规则共享**：支持中心规则仓库，实现规则共享

#### ✅ ARCHER 工作流
- **结构化流程**：ANALYZE → RULE → COLLECT → HYPOTHESIZE → EXECUTE → REVIEW
- **灵活执行**：准备阶段灵活，执行阶段强制顺序
- **模式声明**：每次响应开头声明模式，清晰明确

#### ✅ 系统提示词设计
- **角色定义**：明确 Agent 的角色和职责
- **工具指导**：详细的工具使用说明
- **禁止项**：明确的约束和边界

### 4.2 可以借鉴的改进点

#### 🔄 项目级说明文档（类似 CLAUDE.md / AGENTS.md）
- **现状**：暂无项目级说明文档机制
- **建议**：支持在项目根目录创建 `JARVIS.md` 或 `.jarvis/project_context.md`，自动加载到系统提示词
- **内容**：项目技术栈、架构设计、编码规范、依赖关系、特殊约定等

#### 🔄 Scoped Rules（作用域规则）
- **现状**：规则是全局生效的，无法针对特定文件/目录/类型生效
- **建议**：支持规则文件中的 glob patterns，只在匹配的文件被操作时才激活
- **示例**：
  ```markdown
  # .jarvis/rules/python_style.md
  [scope: "**/*.py"]
  
  # Python 代码规范
  ...
  ```

#### 🔄 上下文引用机制（@file / @folder）
- **现状**：用户需要手动指定文件路径
- **建议**：支持 `@filename` 或 `@folder` 语法，自动将文件/目录内容注入到上下文中
- **优势**：更直观、更便捷

#### 🔄 确认理解阶段增强
- **现状**：HYPOTHESIZE 阶段有确认机制，但可以更明确
- **建议**：
  - 在 HYPOTHESIZE 阶段强制输出"任务概览"和"执行计划"
  - 明确要求用户确认后才能进入 EXECUTE
  - 支持"仅显示差异 diff"模式

#### 🔄 Prompt 模板库
- **现状**：规则系统可以复用，但没有专门的 prompt 模板库
- **建议**：
  - 创建 `.jarvis/prompts/` 目录，存储常用 prompt 模板
  - 支持模板变量和复用
  - 提供 prompt generator 工具

#### 🔄 更细粒度的约束和边界
- **现状**：系统提示词中有禁止项，但可以更细化
- **建议**：
  - 支持在规则文件中定义"禁止项"和"允许项"
  - 支持任务级别的约束（如"只修改指定文件"）
  - 支持输出格式约束（如"仅显示 diff"）

---

## 五、具体借鉴建议

### 5.1 短期改进（高优先级）

#### 1. 项目级说明文档支持
**实现方案**：
- 支持在项目根目录创建 `JARVIS.md` 或 `.jarvis/project_context.md`
- 在系统提示词构建时自动加载并注入
- 优先级：项目文档 > 全局规则 > 内置规则

**示例结构**：
```markdown
# JARVIS.md

## 项目概述
这是一个基于 FastAPI 的微服务项目...

## 技术栈
- Python 3.12
- FastAPI
- PostgreSQL
- Redis

## 编码规范
- 使用 Black 格式化代码
- 所有函数必须有类型注解
- 必须编写单元测试

## 目录结构
- `src/`: 源代码
- `tests/`: 测试代码
- `docs/`: 文档

## 特殊约定
- API 路径必须以 `/api/v1/` 开头
- 数据库迁移使用 Alembic
```

#### 2. 确认理解阶段增强
**实现方案**：
- 在 HYPOTHESIZE 阶段强制输出结构化概览：
  - 任务理解
  - 执行计划（步骤列表）
  - 影响范围
  - 风险评估
- 明确要求用户确认后才能进入 EXECUTE
- 支持"仅显示 diff"模式

**示例输出格式**：
```
[MODE: HYPOTHESIZE]

## 任务理解
...

## 执行计划
1. ...
2. ...

## 影响范围
- 修改文件：...
- 新增文件：...

## 风险评估
- 风险点：...
- 缓解措施：...

请确认以上计划是否正确，确认后我将开始执行。
```

### 5.2 中期改进（中优先级）

#### 3. Scoped Rules 支持
**实现方案**：
- 在规则文件头部支持 `[scope: "glob_pattern"]` 元数据
- 在文件操作时检查规则的作用域
- 只激活匹配的规则

**示例**：
```markdown
# .jarvis/rules/python_style.md
[scope: "**/*.py"]

# Python 代码规范
...
```

#### 4. 上下文引用机制（@file / @folder）
**实现方案**：
- 解析用户输入中的 `@filename` 或 `@folder` 标记
- 自动读取对应文件/目录内容
- 注入到用户输入的上下文中

**示例**：
```
用户输入：修改 @user_service.py 中的登录逻辑
系统处理：读取 user_service.py 内容，注入到上下文中
```

### 5.3 长期改进（低优先级）

#### 5. Prompt 模板库
**实现方案**：
- 创建 `.jarvis/prompts/` 目录
- 支持模板变量和复用
- 提供命令行工具管理模板

#### 6. Prompt Generator
**实现方案**：
- 提供交互式 prompt generator
- 根据任务类型自动生成符合最佳实践的提示词
- 支持模板变量填充

---

## 六、实施优先级建议

### 优先级 1（立即实施）
1. ✅ **项目级说明文档支持**：快速提升项目上下文理解
2. ✅ **确认理解阶段增强**：减少误解和错误执行

### 优先级 2（近期实施）
3. ✅ **Scoped Rules 支持**：提升规则系统的灵活性
4. ✅ **上下文引用机制**：提升用户体验

### 优先级 3（长期规划）
5. ✅ **Prompt 模板库**：提升提示词复用性
6. ✅ **Prompt Generator**：降低使用门槛

---

## 七、总结

### Jarvis 当前优势
- ✅ 强大的规则系统（多层次、模板支持、共享机制）
- ✅ 结构化的 ARCHER 工作流
- ✅ 清晰的系统提示词设计
- ✅ 灵活的工具系统

### 可以借鉴的改进
- 🔄 项目级说明文档（类似 CLAUDE.md）
- 🔄 Scoped Rules（作用域规则）
- 🔄 上下文引用机制（@file / @folder）
- 🔄 确认理解阶段增强
- 🔄 Prompt 模板库和 Generator

### 核心价值
通过借鉴 Claude Code 和 Cursor 的优秀实践，Jarvis 可以进一步提升：
1. **上下文理解能力**：项目级文档 + 上下文引用
2. **规则系统灵活性**：Scoped Rules + 更细粒度约束
3. **用户体验**：确认机制 + Prompt 模板库
4. **可维护性**：标准化文档 + 模板复用

这些改进将使 Jarvis 在保持自身优势的同时，吸收业界最佳实践，成为更强大的 AI 应用开发 SDK。
