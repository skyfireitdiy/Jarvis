{"language": "c/cpp", "category": "memory_mgmt", "pattern": "smart_ptr_get_unsafe", "file": "frameworks/js/napi/src/asset_napi_post_query.cpp", "line": 90, "evidence": "return CreateSyncWork(env, info, context.get());", "confidence": 0.65, "severity": "high", "gid": 30, "verify": "验证context.get()返回的指针在使用前非空", "preconditions": "context指针在传递过程中被意外修改或释放", "trigger_path": "调用路径推导：NapiPostQuery() -> CreateSyncWork()。数据流：context指针通过std::unique_ptr创建并检查非空后传递给CreateSyncWork()。关键调用点：CreateSyncWork()函数未对传入的context指针进行二次校验，直接使用其成员。", "consequences": "可能导致空指针解引用，引发程序崩溃", "suggestions": "在CreateSyncWork()函数开头添加context指针的null检查，或确保所有调用路径都经过NAPI_THROW检查", "has_risk": true, "verification_notes": "分析结论正确，前置条件合理（context指针确实可能被意外修改），触发路径清晰（NapiPostQuery->CreateSyncWork），后果评估准确（可能导致空指针解引用），建议合适（应添加null检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 78, "evidence": "ret = HksAddParams(*paramSet, params, paramCount);", "confidence": 0.6, "severity": "high", "gid": 122, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 86, "evidence": "ret = AddSpecificUserIdParams(*paramSet, userId);", "confidence": 0.6, "severity": "high", "gid": 123, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 111, "evidence": "{ .tag = HKS_TAG_AUTH_STORAGE_LEVEL, .uint32Param = AccessibilityToHksAuthStorageLevel(keyId->accessibility) },", "confidence": 0.6, "severity": "high", "gid": 124, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 147, "evidence": "if (keyId->userId > ASSET_ROOT_USER_UPPERBOUND) {", "confidence": 0.6, "severity": "high", "gid": 125, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 148, "evidence": "ret = AddSpecificUserIdParams(paramSet, keyId->userId);", "confidence": 0.6, "severity": "high", "gid": 126, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 178, "evidence": "ret = HksGenerateKey(&keyId->alias, paramSet, NULL);", "confidence": 0.6, "severity": "high", "gid": 127, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 191, "evidence": "{ .tag = HKS_TAG_AUTH_STORAGE_LEVEL, .uint32Param = AccessibilityToHksAuthStorageLevel(keyId->accessibility) },", "confidence": 0.6, "severity": "high", "gid": 128, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 194, "evidence": "int32_t ret = BuildParamSet(&paramSet, params, ARRAY_SIZE(params), keyId->userId);", "confidence": 0.6, "severity": "high", "gid": 129, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 199, "evidence": "ret = HksDeleteKey(&keyId->alias, paramSet);", "confidence": 0.6, "severity": "high", "gid": 130, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 207, "evidence": "{ .tag = HKS_TAG_AUTH_STORAGE_LEVEL, .uint32Param = AccessibilityToHksAuthStorageLevel(keyId->accessibility) },", "confidence": 0.6, "severity": "high", "gid": 131, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 210, "evidence": "int32_t ret = BuildParamSet(&paramSet, params, ARRAY_SIZE(params), keyId->userId);", "confidence": 0.6, "severity": "high", "gid": 132, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 215, "evidence": "ret = HksKeyExist(&keyId->alias, paramSet);", "confidence": 0.6, "severity": "high", "gid": 133, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 229, "evidence": "{ .tag = HKS_TAG_ASSOCIATED_DATA, .blob = *aad },", "confidence": 0.6, "severity": "high", "gid": 134, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 230, "evidence": "{ .tag = HKS_TAG_AUTH_STORAGE_LEVEL, .uint32Param = AccessibilityToHksAuthStorageLevel(keyId->accessibility) },", "confidence": 0.6, "severity": "high", "gid": 135, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 233, "evidence": "int32_t ret = BuildParamSet(&encryptParamSet, encryptParams, ARRAY_SIZE(encryptParams), keyId->userId);", "confidence": 0.6, "severity": "high", "gid": 136, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 240, "evidence": "ret = HksInit(&keyId->alias, encryptParamSet, &handleBlob, NULL);", "confidence": 0.6, "severity": "high", "gid": 137, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 258, "evidence": "struct HksBlob cipher = { inData->size - NONCE_SIZE - TAG_SIZE, inData->data };", "confidence": 0.6, "severity": "high", "gid": 138, "verify": "验证缓冲区操作长度不超过目标容量", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 259, "evidence": "struct HksBlob tag = { TAG_SIZE, inData->data + (inData->size - NONCE_SIZE - TAG_SIZE) };", "confidence": 0.6, "severity": "high", "gid": 139, "verify": "验证缓冲区操作长度不超过目标容量", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 260, "evidence": "struct HksBlob nonce = { NONCE_SIZE, inData->data + (inData->size - NONCE_SIZE) };", "confidence": 0.6, "severity": "high", "gid": 140, "verify": "验证缓冲区操作长度不超过目标容量", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 269, "evidence": "{ .tag = HKS_TAG_ASSOCIATED_DATA, .blob = *aad },", "confidence": 0.6, "severity": "high", "gid": 141, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 272, "evidence": "{ .tag = HKS_TAG_AUTH_STORAGE_LEVEL, .uint32Param = AccessibilityToHksAuthStorageLevel(keyId->accessibility) },", "confidence": 0.6, "severity": "high", "gid": 142, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 275, "evidence": "int32_t ret = BuildParamSet(&decryptParamSet, decryptParams, ARRAY_SIZE(decryptParams), keyId->userId);", "confidence": 0.6, "severity": "high", "gid": 143, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 282, "evidence": "ret = HksInit(&keyId->alias, decryptParamSet, &handleBlob, NULL);", "confidence": 0.6, "severity": "high", "gid": 144, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 305, "evidence": "{ .tag = HKS_TAG_AUTH_STORAGE_LEVEL, .uint32Param = AccessibilityToHksAuthStorageLevel(keyId->accessibility) },", "confidence": 0.6, "severity": "high", "gid": 145, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 308, "evidence": "int32_t ret = BuildParamSet(&paramSet, initParams, ARRAY_SIZE(initParams), keyId->userId);", "confidence": 0.6, "severity": "high", "gid": 146, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 313, "evidence": "ret = HksInit(&keyId->alias, paramSet, handle, challenge);", "confidence": 0.6, "severity": "high", "gid": 147, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 324, "evidence": "struct HksBlob tag = { TAG_SIZE, inData->data + (inData->size - NONCE_SIZE - TAG_SIZE) };", "confidence": 0.6, "severity": "high", "gid": 148, "verify": "验证缓冲区操作长度不超过目标容量", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 325, "evidence": "struct HksBlob nonce = { NONCE_SIZE, inData->data + (inData->size - NONCE_SIZE) };", "confidence": 0.6, "severity": "high", "gid": 149, "verify": "验证缓冲区操作长度不超过目标容量", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 333, "evidence": "{ .tag = HKS_TAG_ASSOCIATED_DATA, .blob = { .size = aad->size, .data = aad->data } },", "confidence": 0.6, "severity": "high", "gid": 150, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 336, "evidence": "{ .tag = HKS_TAG_AUTH_TOKEN, .blob = *authToken },", "confidence": 0.6, "severity": "high", "gid": 151, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 345, "evidence": "struct HksBlob cipher = { inData->size - NONCE_SIZE - TAG_SIZE, inData->data };", "confidence": 0.6, "severity": "high", "gid": 152, "verify": "验证缓冲区操作长度不超过目标容量", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 376, "evidence": "{ .tag = HKS_TAG_AUTH_STORAGE_LEVEL, .uint32Param = AccessibilityToHksAuthStorageLevel(keyId->accessibility) },", "confidence": 0.6, "severity": "high", "gid": 153, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 380, "evidence": "int32_t ret = BuildParamSet(&paramSet, params, ARRAY_SIZE(params), keyId->userId);", "confidence": 0.6, "severity": "high", "gid": 154, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 385, "evidence": "ret = HksRenameKeyAlias(&keyId->alias, paramSet, newKeyAlias);", "confidence": 0.6, "severity": "high", "gid": 155, "verify": "验证指针在解引用前非空", "preconditions": "调用者传入的 keyId 或相关指针参数为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GenerateKey/DeleteKey/IsKeyExist/EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias。数据流：外部调用者直接调用这些函数并传入 keyId 或其他相关指针参数，这些函数内部未对指针进行NULL检查就直接解引用。关键调用点：所有涉及指针解引用的函数入口处都缺少NULL指针检查。", "consequences": "NULL指针解引用导致程序崩溃", "suggestions": "在每个函数入口处添加NULL指针检查，对于缓冲区操作还应添加长度验证", "has_risk": true, "verification_notes": "分析结论正确，所有函数确实缺少对输入指针的NULL检查，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 258, "evidence": "struct HksBlob cipher = { inData->size - NONCE_SIZE - TAG_SIZE, inData->data };", "confidence": 0.6, "severity": "high", "gid": 138, "verify": "验证缓冲区操作长度不超过目标容量", "preconditions": "输入数据 inData->size 小于 NONCE_SIZE + TAG_SIZE", "trigger_path": "调用路径推导：Rust层调用 -> DecryptData/ExecCrypt -> 缓冲区操作。数据流：Rust层传入加密数据 -> C层直接进行指针运算和内存访问。关键调用点：Rust层未检查输入数据长度是否足够，C层直接使用 inData->size 进行计算和指针运算。", "consequences": "缓冲区越界访问，可能导致内存破坏或程序崩溃", "suggestions": "1. 在DecryptData和ExecCrypt函数开头添加输入长度校验；2. 在Rust层调用前确保数据长度足够", "has_risk": true, "verification_notes": "分析结论正确，代码确实存在当inData->size小于NONCE_SIZE+TAG_SIZE时会导致负长度或无效指针运算的风险，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 259, "evidence": "struct HksBlob tag = { TAG_SIZE, inData->data + (inData->size - NONCE_SIZE - TAG_SIZE) };", "confidence": 0.6, "severity": "high", "gid": 139, "verify": "验证缓冲区操作长度不超过目标容量", "preconditions": "输入数据 inData->size 小于 NONCE_SIZE + TAG_SIZE", "trigger_path": "调用路径推导：Rust层调用 -> DecryptData/ExecCrypt -> 缓冲区操作。数据流：Rust层传入加密数据 -> C层直接进行指针运算和内存访问。关键调用点：Rust层未检查输入数据长度是否足够，C层直接使用 inData->size 进行计算和指针运算。", "consequences": "缓冲区越界访问，可能导致内存破坏或程序崩溃", "suggestions": "1. 在DecryptData和ExecCrypt函数开头添加输入长度校验；2. 在Rust层调用前确保数据长度足够", "has_risk": true, "verification_notes": "分析结论正确，代码确实存在当inData->size小于NONCE_SIZE+TAG_SIZE时会导致负长度或无效指针运算的风险，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 260, "evidence": "struct HksBlob nonce = { NONCE_SIZE, inData->data + (inData->size - NONCE_SIZE) };", "confidence": 0.6, "severity": "high", "gid": 140, "verify": "验证缓冲区操作长度不超过目标容量", "preconditions": "输入数据 inData->size 小于 NONCE_SIZE + TAG_SIZE", "trigger_path": "调用路径推导：Rust层调用 -> DecryptData/ExecCrypt -> 缓冲区操作。数据流：Rust层传入加密数据 -> C层直接进行指针运算和内存访问。关键调用点：Rust层未检查输入数据长度是否足够，C层直接使用 inData->size 进行计算和指针运算。", "consequences": "缓冲区越界访问，可能导致内存破坏或程序崩溃", "suggestions": "1. 在DecryptData和ExecCrypt函数开头添加输入长度校验；2. 在Rust层调用前确保数据长度足够", "has_risk": true, "verification_notes": "分析结论正确，代码确实存在当inData->size小于NONCE_SIZE+TAG_SIZE时会导致负长度或无效指针运算的风险，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 324, "evidence": "struct HksBlob tag = { TAG_SIZE, inData->data + (inData->size - NONCE_SIZE - TAG_SIZE) };", "confidence": 0.6, "severity": "high", "gid": 148, "verify": "验证缓冲区操作长度不超过目标容量", "preconditions": "输入数据 inData->size 小于 NONCE_SIZE + TAG_SIZE", "trigger_path": "调用路径推导：Rust层调用 -> DecryptData/ExecCrypt -> 缓冲区操作。数据流：Rust层传入加密数据 -> C层直接进行指针运算和内存访问。关键调用点：Rust层未检查输入数据长度是否足够，C层直接使用 inData->size 进行计算和指针运算。", "consequences": "缓冲区越界访问，可能导致内存破坏或程序崩溃", "suggestions": "1. 在DecryptData和ExecCrypt函数开头添加输入长度校验；2. 在Rust层调用前确保数据长度足够", "has_risk": true, "verification_notes": "分析结论正确，代码确实存在当inData->size小于NONCE_SIZE+TAG_SIZE时会导致负长度或无效指针运算的风险，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 325, "evidence": "struct HksBlob nonce = { NONCE_SIZE, inData->data + (inData->size - NONCE_SIZE) };", "confidence": 0.6, "severity": "high", "gid": 149, "verify": "验证缓冲区操作长度不超过目标容量", "preconditions": "输入数据 inData->size 小于 NONCE_SIZE + TAG_SIZE", "trigger_path": "调用路径推导：Rust层调用 -> DecryptData/ExecCrypt -> 缓冲区操作。数据流：Rust层传入加密数据 -> C层直接进行指针运算和内存访问。关键调用点：Rust层未检查输入数据长度是否足够，C层直接使用 inData->size 进行计算和指针运算。", "consequences": "缓冲区越界访问，可能导致内存破坏或程序崩溃", "suggestions": "1. 在DecryptData和ExecCrypt函数开头添加输入长度校验；2. 在Rust层调用前确保数据长度足够", "has_risk": true, "verification_notes": "分析结论正确，代码确实存在当inData->size小于NONCE_SIZE+TAG_SIZE时会导致负长度或无效指针运算的风险，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/crypto_manager/src/huks_wrapper.c", "line": 345, "evidence": "struct HksBlob cipher = { inData->size - NONCE_SIZE - TAG_SIZE, inData->data };", "confidence": 0.6, "severity": "high", "gid": 152, "verify": "验证缓冲区操作长度不超过目标容量", "preconditions": "输入数据 inData->size 小于 NONCE_SIZE + TAG_SIZE", "trigger_path": "调用路径推导：Rust层调用 -> DecryptData/ExecCrypt -> 缓冲区操作。数据流：Rust层传入加密数据 -> C层直接进行指针运算和内存访问。关键调用点：Rust层未检查输入数据长度是否足够，C层直接使用 inData->size 进行计算和指针运算。", "consequences": "缓冲区越界访问，可能导致内存破坏或程序崩溃", "suggestions": "1. 在DecryptData和ExecCrypt函数开头添加输入长度校验；2. 在Rust层调用前确保数据长度足够", "has_risk": true, "verification_notes": "分析结论正确，代码确实存在当inData->size小于NONCE_SIZE+TAG_SIZE时会导致负长度或无效指针运算的风险，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "wild_pointer_deref", "file": "services/crypto_manager/src/huks_wrapper.h", "line": 51, "evidence": "struct HksBlob *outData);", "confidence": 0.65, "severity": "high", "gid": 156, "verify": "验证所有HksBlob指针参数在解引用前非空", "preconditions": "传入的HksBlob指针参数为NULL", "trigger_path": "调用路径推导：外部调用者 -> 各加密操作函数（EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias）。数据流：外部传入的HksBlob指针参数直接传递给HKS库函数。关键调用点：所有涉及HksBlob指针参数的函数均未进行空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃或拒绝服务", "suggestions": "在所有使用HksBlob指针参数的函数入口处添加空指针检查，确保指针有效后再进行解引用操作", "has_risk": true, "verification_notes": "分析结论正确，huks_wrapper.h文件中所有涉及HksBlob指针参数的函数确实缺少空指针检查，前置条件合理（传入NULL指针可能导致解引用），触发路径清晰（外部调用直接传递指针），后果评估准确（可能导致程序崩溃），建议合适（应添加指针有效性检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "wild_pointer_deref", "file": "services/crypto_manager/src/huks_wrapper.h", "line": 54, "evidence": "const struct HksBlob *inData, struct HksBlob *outData);", "confidence": 0.65, "severity": "high", "gid": 157, "verify": "验证所有HksBlob指针参数在解引用前非空", "preconditions": "传入的HksBlob指针参数为NULL", "trigger_path": "调用路径推导：外部调用者 -> 各加密操作函数（EncryptData/DecryptData/InitKey/ExecCrypt/Drop/RenameKeyAlias）。数据流：外部传入的HksBlob指针参数直接传递给HKS库函数。关键调用点：所有涉及HksBlob指针参数的函数均未进行空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃或拒绝服务", "suggestions": "在所有使用HksBlob指针参数的函数入口处添加空指针检查，确保指针有效后再进行解引用操作", "has_risk": true, "verification_notes": "分析结论正确，huks_wrapper.h文件中所有涉及HksBlob指针参数的函数确实缺少空指针检查，前置条件合理（传入NULL指针可能导致解引用），触发路径清晰（外部调用直接传递指针），后果评估准确（可能导致程序崩溃），建议合适（应添加指针有效性检查）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/os_dependency/src/os_account_wrapper.cpp", "line": 31, "evidence": "*userId = userIdTmp;", "confidence": 0.6, "severity": "high", "gid": 163, "verify": "验证指针在解引用前是否非空", "preconditions": "调用者传入的指针参数为NULL", "trigger_path": "调用路径推导：外部调用者 -> GetUserIdByUid()/IsUserIdExist()/GetUserIds()/GetFirstUnlockUserIds()/GetUsersSize() -> 直接解引用指针。数据流：指针参数直接传递给函数，函数内部未进行判空检查即解引用。关键调用点：所有函数都未对输入指针进行校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在函数入口处添加指针判空检查，返回错误码或抛出异常", "has_risk": true, "verification_notes": "分析结论正确，所有函数均未对输出指针参数进行NULL检查，存在空指针解引用风险，前置条件合理，触发路径清晰，后果评估准确，建议添加指针判空检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/os_dependency/src/os_account_wrapper.cpp", "line": 43, "evidence": "*exist = isUserIdExist;", "confidence": 0.6, "severity": "high", "gid": 164, "verify": "验证指针在解引用前是否非空", "preconditions": "调用者传入的指针参数为NULL", "trigger_path": "调用路径推导：外部调用者 -> GetUserIdByUid()/IsUserIdExist()/GetUserIds()/GetFirstUnlockUserIds()/GetUsersSize() -> 直接解引用指针。数据流：指针参数直接传递给函数，函数内部未进行判空检查即解引用。关键调用点：所有函数都未对输入指针进行校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在函数入口处添加指针判空检查，返回错误码或抛出异常", "has_risk": true, "verification_notes": "分析结论正确，所有函数均未对输出指针参数进行NULL检查，存在空指针解引用风险，前置条件合理，触发路径清晰，后果评估准确，建议添加指针判空检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/os_dependency/src/os_account_wrapper.cpp", "line": 69, "evidence": "*userIdsSize = static_cast<uint32_t>(userIdsVec.size());", "confidence": 0.6, "severity": "high", "gid": 165, "verify": "验证指针在解引用前是否非空", "preconditions": "调用者传入的指针参数为NULL", "trigger_path": "调用路径推导：外部调用者 -> GetUserIdByUid()/IsUserIdExist()/GetUserIds()/GetFirstUnlockUserIds()/GetUsersSize() -> 直接解引用指针。数据流：指针参数直接传递给函数，函数内部未进行判空检查即解引用。关键调用点：所有函数都未对输入指针进行校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在函数入口处添加指针判空检查，返回错误码或抛出异常", "has_risk": true, "verification_notes": "分析结论正确，所有函数均未对输出指针参数进行NULL检查，存在空指针解引用风险，前置条件合理，触发路径清晰，后果评估准确，建议添加指针判空检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/os_dependency/src/os_account_wrapper.cpp", "line": 89, "evidence": "*userIdsSize = static_cast<uint32_t>(userIdsVec.size());", "confidence": 0.6, "severity": "high", "gid": 166, "verify": "验证指针在解引用前是否非空", "preconditions": "调用者传入的指针参数为NULL", "trigger_path": "调用路径推导：外部调用者 -> GetUserIdByUid()/IsUserIdExist()/GetUserIds()/GetFirstUnlockUserIds()/GetUsersSize() -> 直接解引用指针。数据流：指针参数直接传递给函数，函数内部未进行判空检查即解引用。关键调用点：所有函数都未对输入指针进行校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在函数入口处添加指针判空检查，返回错误码或抛出异常", "has_risk": true, "verification_notes": "分析结论正确，所有函数均未对输出指针参数进行NULL检查，存在空指针解引用风险，前置条件合理，触发路径清晰，后果评估准确，建议添加指针判空检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/os_dependency/src/os_account_wrapper.cpp", "line": 109, "evidence": "*userIdsSize = static_cast<uint32_t>(userIdsVec.size());", "confidence": 0.6, "severity": "high", "gid": 167, "verify": "验证指针在解引用前是否非空", "preconditions": "调用者传入的指针参数为NULL", "trigger_path": "调用路径推导：外部调用者 -> GetUserIdByUid()/IsUserIdExist()/GetUserIds()/GetFirstUnlockUserIds()/GetUsersSize() -> 直接解引用指针。数据流：指针参数直接传递给函数，函数内部未进行判空检查即解引用。关键调用点：所有函数都未对输入指针进行校验。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在函数入口处添加指针判空检查，返回错误码或抛出异常", "has_risk": true, "verification_notes": "分析结论正确，所有函数均未对输出指针参数进行NULL检查，存在空指针解引用风险，前置条件合理，触发路径清晰，后果评估准确，建议添加指针判空检查是合理的"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/os_dependency/src/file_operator_wrapper.cpp", "line": 41, "evidence": "*partitionSize = (static_cast<double>(stat.f_bfree) / units) * (static_cast<double>(stat.f_bsize) / units);", "confidence": 0.6, "severity": "high", "gid": 174, "verify": "验证候选 174 的安全风险", "preconditions": "调用者传入的 partitionSize 指针为 NULL", "trigger_path": "调用路径推导：外部调用者 -> GetRemainPartitionSize() -> 缺陷代码。数据流：外部调用者直接调用 GetRemainPartitionSize() 函数，未对 partitionSize 参数进行校验。关键调用点：GetRemainPartitionSize() 函数未对 partitionSize 指针进行 NULL 检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在 GetRemainPartitionSize() 函数开始处添加对 partitionSize 的 NULL 检查，并返回适当的错误码（如 ASSET_INVALID_ARGUMENT）", "has_risk": true, "verification_notes": "分析结论正确，前置条件合理（确实存在partitionSize指针未进行NULL检查的问题），触发路径成立（外部调用者可以直接传入NULL指针），后果评估准确（会导致空指针解引用引发程序崩溃），建议合适（添加NULL检查并返回错误码是正确做法）"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "frameworks/os_dependency/file/src/de_operator.rs", "line": 40, "evidence": "let _ = fs::set_permissions(path, fs::Permissions::from_mode(0o700));", "confidence": 0.55, "severity": "low", "gid": 221, "verify": "验证fs::set_permissions的返回值是否被正确处理", "preconditions": "fs::set_permissions调用失败但被忽略", "trigger_path": "调用路径推导：create_user_de_dir() -> fs::set_permissions()。数据流：user_id参数用于构造路径，传递给fs::set_permissions设置权限。关键调用点：create_user_de_dir函数未检查set_permissions的返回值。", "consequences": "可能导致目录权限设置失败而不被发现，存在潜在的安全风险", "suggestions": "应处理fs::set_permissions的返回值，在失败时返回错误或记录日志", "has_risk": true, "verification_notes": "分析结论正确：\n1. 前置条件合理：确实存在忽略fs::set_permissions返回值的情况\n2. 触发路径成立：create_user_de_dir函数确实调用了fs::set_permissions且未检查返回值\n3. 后果评估准确：权限设置失败可能导致安全风险\n4. 建议合适：应处理返回值或记录错误\n验证依据：\n- 代码中确实使用let _ =忽略返回值\n- 项目记忆也指出这是常见安全风险模式\n- Rust最佳实践要求处理安全敏感操作的返回值"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "frameworks/os_dependency/file/src/de_operator.rs", "line": 44, "evidence": "let _ = fs::set_permissions(path, fs::Permissions::from_mode(0o700));", "confidence": 0.55, "severity": "low", "gid": 222, "verify": "验证fs::set_permissions的返回值是否被正确处理", "preconditions": "fs::set_permissions调用失败但被忽略", "trigger_path": "调用路径推导：create_user_de_dir() -> fs::set_permissions()。数据流：user_id参数用于构造路径，传递给fs::set_permissions设置权限。关键调用点：create_user_de_dir函数未检查set_permissions的返回值。", "consequences": "可能导致目录权限设置失败而不被发现，存在潜在的安全风险", "suggestions": "应处理fs::set_permissions的返回值，在失败时返回错误或记录日志", "has_risk": true, "verification_notes": "分析结论正确：\n1. 前置条件合理：确实存在忽略fs::set_permissions返回值的情况\n2. 触发路径成立：create_user_de_dir函数确实调用了fs::set_permissions且未检查返回值\n3. 后果评估准确：权限设置失败可能导致安全风险\n4. 建议合适：应处理返回值或记录错误\n验证依据：\n- 代码中确实使用let _ =忽略返回值\n- 项目记忆也指出这是常见安全风险模式\n- Rust最佳实践要求处理安全敏感操作的返回值"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "frameworks/os_dependency/file/src/ce_operator.rs", "line": 41, "evidence": "let _ = fs::set_permissions(path, fs::Permissions::from_mode(0o640));", "confidence": 0.55, "severity": "low", "gid": 223, "verify": "检查是否应该处理文件权限设置失败的情况", "preconditions": "文件权限设置操作失败", "trigger_path": "调用路径推导：外部调用者 -> read_db_key_cipher()/write_db_key_cipher() -> fs::set_permissions()。数据流：用户ID作为输入参数传递给函数，函数构造文件路径后直接调用set_permissions()。关键调用点：read_db_key_cipher()和write_db_key_cipher()都未检查set_permissions()的返回结果。", "consequences": "无法及时发现和记录文件权限设置失败的情况，可能影响安全审计能力", "suggestions": "检查set_permissions()的结果，并在失败时记录日志或返回错误", "has_risk": true, "verification_notes": "分析结论正确：\n1. 前置条件合理：文件权限设置操作确实可能失败\n2. 触发路径成立：代码确实忽略了fs::set_permissions()的返回结果\n3. 后果评估准确：权限设置失败未被记录确实影响安全审计能力\n4. 建议合适：应检查并处理set_permissions()的返回结果\n验证依据：\n- 代码中确实使用let _ =忽略返回值\n- 项目长期记忆表明安全敏感操作不应忽略返回值\n- 该文件处理的是数据库密钥等敏感数据"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "frameworks/os_dependency/file/src/ce_operator.rs", "line": 58, "evidence": "let _ = fs::set_permissions(path, fs::Permissions::from_mode(0o640));", "confidence": 0.55, "severity": "low", "gid": 224, "verify": "检查是否应该处理文件权限设置失败的情况", "preconditions": "文件权限设置操作失败", "trigger_path": "调用路径推导：外部调用者 -> read_db_key_cipher()/write_db_key_cipher() -> fs::set_permissions()。数据流：用户ID作为输入参数传递给函数，函数构造文件路径后直接调用set_permissions()。关键调用点：read_db_key_cipher()和write_db_key_cipher()都未检查set_permissions()的返回结果。", "consequences": "无法及时发现和记录文件权限设置失败的情况，可能影响安全审计能力", "suggestions": "检查set_permissions()的结果，并在失败时记录日志或返回错误", "has_risk": true, "verification_notes": "分析结论正确：\n1. 前置条件合理：文件权限设置操作确实可能失败\n2. 触发路径成立：代码确实忽略了fs::set_permissions()的返回结果\n3. 后果评估准确：权限设置失败未被记录确实影响安全审计能力\n4. 建议合适：应检查并处理set_permissions()的返回结果\n验证依据：\n- 代码中确实使用let _ =忽略返回值\n- 项目长期记忆表明安全敏感操作不应忽略返回值\n- 该文件处理的是数据库密钥等敏感数据"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "services/crypto_manager/src/db_key_operator.rs", "line": 85, "evidence": "let _lock = GEN_KEY_MUTEX.lock().unwrap();", "confidence": 0.65, "severity": "medium", "gid": 292, "verify": "确认unwrap是否有替代的错误处理方式或保证不会panic", "preconditions": "互斥锁被中毒(poisoned)时调用unwrap()", "trigger_path": "调用路径推导：\n1. 对于gid 292:\n- 入口函数: generate_secret_key_if_needed()\n- 调用链: generate_secret_key_if_needed() -> GEN_KEY_MUTEX.lock().unwrap()\n- 数据流: 无外部输入，内部互斥锁操作\n- 关键调用点: 直接调用unwrap()未处理可能的锁中毒错误\n\n2. 对于gid 293:\n- 入口函数: get_db_key()\n- 调用链: get_db_key() -> GET_DB_KEY_MUTEX.lock().unwrap()\n- 数据流: 无外部输入，内部互斥锁操作\n- 关键调用点: 直接调用unwrap()未处理可能的锁中毒错误", "consequences": "可能导致线程panic，影响系统稳定性", "suggestions": "使用expect()提供更有意义的错误信息，或使用match处理可能的错误情况", "has_risk": true, "verification_notes": "分析结论正确：\n1. 前置条件合理：确实存在互斥锁中毒时调用unwrap()的风险\n2. 触发路径成立：代码中确实直接调用了unwrap()而没有处理可能的锁中毒错误\n3. 后果评估准确：确实可能导致线程panic，影响系统稳定性\n4. 建议合适：使用expect()或match处理错误是更安全的做法\n两个gid的情况相似，都是互斥锁操作中的unwrap使用问题"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "services/crypto_manager/src/db_key_operator.rs", "line": 149, "evidence": "let _lock = GET_DB_KEY_MUTEX.lock().unwrap();", "confidence": 0.65, "severity": "medium", "gid": 293, "verify": "确认unwrap是否有替代的错误处理方式或保证不会panic", "preconditions": "互斥锁被中毒(poisoned)时调用unwrap()", "trigger_path": "调用路径推导：\n1. 对于gid 292:\n- 入口函数: generate_secret_key_if_needed()\n- 调用链: generate_secret_key_if_needed() -> GEN_KEY_MUTEX.lock().unwrap()\n- 数据流: 无外部输入，内部互斥锁操作\n- 关键调用点: 直接调用unwrap()未处理可能的锁中毒错误\n\n2. 对于gid 293:\n- 入口函数: get_db_key()\n- 调用链: get_db_key() -> GET_DB_KEY_MUTEX.lock().unwrap()\n- 数据流: 无外部输入，内部互斥锁操作\n- 关键调用点: 直接调用unwrap()未处理可能的锁中毒错误", "consequences": "可能导致线程panic，影响系统稳定性", "suggestions": "使用expect()提供更有意义的错误信息，或使用match处理可能的错误情况", "has_risk": true, "verification_notes": "分析结论正确：\n1. 前置条件合理：确实存在互斥锁中毒时调用unwrap()的风险\n2. 触发路径成立：代码中确实直接调用了unwrap()而没有处理可能的锁中毒错误\n3. 后果评估准确：确实可能导致线程panic，影响系统稳定性\n4. 建议合适：使用expect()或match处理错误是更安全的做法\n两个gid的情况相似，都是互斥锁操作中的unwrap使用问题"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "services/common/src/calling_info.rs", "line": 143, "evidence": "match owner_info_vec.last().unwrap().parse::<u32>() {", "confidence": 0.55, "severity": "low", "gid": 340, "verify": "验证候选 340 的安全风险", "preconditions": "owner_info字段格式不正确（缺少下划线分隔符）", "trigger_path": "调用路径推导：app_index() -> owner_info() -> owner_info_vec.last().unwrap()。数据流：owner_info字段通过owner_info()方法获取，被分割为owner_info_vec数组，当数组为空时调用unwrap()会导致panic。关键调用点：app_index()方法未对owner_info字段格式进行校验。", "consequences": "程序panic，可能导致服务中断", "suggestions": "使用unwrap_or_default()替代unwrap()，或添加格式验证确保owner_info包含下划线分隔符", "has_risk": true, "verification_notes": "分析结论正确：\n1. 前置条件合理：owner_info字段确实需要下划线分隔符格式（如\"xxx_yyy\"），否则split('_')可能产生空数组\n2. 触发路径成立：app_index() -> owner_info() -> owner_info_vec.last().unwrap() 的调用路径正确\n3. 后果评估准确：当owner_info格式不正确时，last().unwrap()确实会导致panic\n4. 建议合适：使用unwrap_or_default()或添加格式验证都是合理的改进方案\n代码中确实存在owner_info_vec.last().unwrap()的风险调用，且缺乏对owner_info格式的显式验证"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "services/common/src/counter.rs", "line": 79, "evidence": "counter.lock().unwrap().increase_count();", "confidence": 0.65, "severity": "medium", "gid": 343, "verify": "验证counter.lock()是否可能失败导致unwrap() panic", "preconditions": "当Mutex处于中毒状态(持有锁的线程panic)或系统资源耗尽时", "trigger_path": "调用路径推导：Counter::get_instance() -> lock().unwrap()。数据流：Counter::get_instance()使用OnceLock保证单例初始化，返回Arc<Mutex<Counter>>实例。关键调用点：在AutoCounter::new()和AutoCounter::drop()中直接调用counter.lock().unwrap()，未处理可能的锁获取失败情况。", "consequences": "线程panic或程序意外终止", "suggestions": "1. 使用lock().expect()提供更有意义的错误信息；2. 处理可能的错误情况而不是直接panic；3. 考虑使用Mutex::try_lock()进行非阻塞尝试", "has_risk": true, "verification_notes": "分析结论正确：\n1. 前置条件合理：Mutex确实可能在中毒状态或系统资源耗尽时导致lock()失败\n2. 触发路径成立：代码确实在AutoCounter::new()和Drop实现中直接使用unwrap()\n3. 后果评估准确：确实会导致线程panic或程序意外终止\n4. 建议合适：提供了三种可行的改进方案\n验证依据：\n- 代码检查确认存在unwrap()直接使用\n- 项目记忆确认这是已知的潜在风险点\n- Rust标准库文档确认Mutex::lock()可能失败的情况"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "services/common/src/counter.rs", "line": 88, "evidence": "counter.lock().unwrap().decrease_count();", "confidence": 0.65, "severity": "medium", "gid": 344, "verify": "验证counter.lock()是否可能失败导致unwrap() panic", "preconditions": "当Mutex处于中毒状态(持有锁的线程panic)或系统资源耗尽时", "trigger_path": "调用路径推导：Counter::get_instance() -> lock().unwrap()。数据流：Counter::get_instance()使用OnceLock保证单例初始化，返回Arc<Mutex<Counter>>实例。关键调用点：在AutoCounter::new()和AutoCounter::drop()中直接调用counter.lock().unwrap()，未处理可能的锁获取失败情况。", "consequences": "线程panic或程序意外终止", "suggestions": "1. 使用lock().expect()提供更有意义的错误信息；2. 处理可能的错误情况而不是直接panic；3. 考虑使用Mutex::try_lock()进行非阻塞尝试", "has_risk": true, "verification_notes": "分析结论正确：\n1. 前置条件合理：Mutex确实可能在中毒状态或系统资源耗尽时导致lock()失败\n2. 触发路径成立：代码确实在AutoCounter::new()和Drop实现中直接使用unwrap()\n3. 后果评估准确：确实会导致线程panic或程序意外终止\n4. 建议合适：提供了三种可行的改进方案\n验证依据：\n- 代码检查确认存在unwrap()直接使用\n- 项目记忆确认这是已知的潜在风险点\n- Rust标准库文档确认Mutex::lock()可能失败的情况"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "services/core_service/src/upgrade_operator.rs", "line": 162, "evidence": "let app_name = CString::new(info).unwrap();", "confidence": 0.65, "severity": "medium", "gid": 370, "verify": "检查unwrap/expect使用是否有更好的错误处理方式或确保panic是可接受的", "preconditions": "输入字符串info包含null字节", "trigger_path": "调用路径推导：外部调用 -> is_hap_in_allowlist() -> CString::new(info).unwrap()。数据流：info参数来自外部输入，未经有效性检查直接传递给CString::new()。关键调用点：is_hap_in_allowlist()函数未对输入进行null字节检查。", "consequences": "程序panic，可能导致服务中断", "suggestions": "使用match或unwrap_or_else处理可能的错误，或添加输入验证", "has_risk": true, "verification_notes": "分析结论正确，CString::new(info).unwrap()确实会在info包含null字节时panic，函数未进行输入检查，后果评估准确，建议合理"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "services/core_service/src/upgrade_operator.rs", "line": 180, "evidence": "let owner_info = datas.first().unwrap().get_bytes_attr(&column::OWNER)?;", "confidence": 0.65, "severity": "medium", "gid": 371, "verify": "检查unwrap/expect使用是否有更好的错误处理方式或确保panic是可接受的", "preconditions": "数据库查询返回空结果集", "trigger_path": "调用路径推导：clone_data_from_app_to_clone_app() -> clone_single_app() -> datas.first().unwrap()。数据流：datas来自数据库查询结果，未经空检查直接调用first().unwrap()。关键调用点：clone_single_app()函数未检查datas是否为空。", "consequences": "程序panic，可能导致服务中断", "suggestions": "添加空检查或使用if let Some(first) = datas.first()", "has_risk": true, "verification_notes": "分析结论正确，datas.first().unwrap()确实会在datas为空时panic，函数未进行空检查，后果评估准确，建议合理"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "services/core_service/src/upgrade_operator.rs", "line": 181, "evidence": "let owner_type = datas.first().unwrap().get_enum_attr::<OwnerType>(&column::OWNER_TYPE)?;", "confidence": 0.65, "severity": "medium", "gid": 372, "verify": "检查unwrap/expect使用是否有更好的错误处理方式或确保panic是可接受的", "preconditions": "数据库查询返回空结果集", "trigger_path": "调用路径推导：clone_data_from_app_to_clone_app() -> clone_single_app() -> datas.first().unwrap()。数据流：datas来自数据库查询结果，未经空检查直接调用first().unwrap()。关键调用点：clone_single_app()函数未检查datas是否为空。", "consequences": "程序panic，可能导致服务中断", "suggestions": "添加空检查或使用if let Some(first) = datas.first()", "has_risk": true, "verification_notes": "分析结论正确，datas.first().unwrap()确实会在datas为空时panic，函数未进行空检查，后果评估准确，建议合理"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "services/core_service/src/upgrade_operator.rs", "line": 114, "evidence": "let _ = upgrade_execute(user_id, version.clone(), &info);", "confidence": 0.55, "severity": "low", "gid": 373, "verify": "确认忽略函数返回值是否安全，是否有必要处理潜在错误", "preconditions": "升级操作执行过程中出现错误", "trigger_path": "调用路径推导：upgrade_single() -> upgrade_execute()。数据流：用户ID和升级信息通过upgrade_single()传递给upgrade_execute()执行关键升级操作。关键调用点：upgrade_single()函数未处理upgrade_execute()返回的错误结果。", "consequences": "升级操作失败但无错误报告，可能导致系统状态不一致", "suggestions": "在upgrade_single()中添加错误处理逻辑，记录或传播错误", "has_risk": true, "verification_notes": "分析结论正确，前置条件合理（升级操作可能出错），触发路径成立（upgrade_single->upgrade_execute），后果评估准确（忽略错误可能导致状态不一致），建议合适（应添加错误处理）"}
{"language": "rust", "category": "ffi", "pattern": "CString/CStr", "file": "services/core_service/src/upgrade_operator.rs", "line": 19, "evidence": "use std::{ffi::CString, collections::HashSet};", "confidence": 0.65, "severity": "medium", "gid": 376, "verify": "确保所有FFI字符串转换都正确处理了可能的错误", "preconditions": "输入字符串包含null字节或无法转换为C字符串", "trigger_path": "调用路径推导：外部调用 -> upgrade_clone_app_data()/upgrade_single_clone_app_data() -> upgrade_single() -> is_hap_in_allowlist() -> CString::new().unwrap()。数据流：外部输入通过upgrade_clone_app_data或upgrade_single_clone_app_data接收，传递给upgrade_single处理，upgrade_single调用is_hap_in_allowlist时未对输入字符串进行校验，直接使用CString::new().unwrap()转换。关键调用点：is_hap_in_allowlist函数未对CString转换进行错误处理。", "consequences": "当输入包含null字节时会导致程序panic，可能引发服务中断", "suggestions": "将unwrap()替换为match或unwrap_or_else等错误处理机制，类似于文件中get_clone_app_indexes函数的处理方式", "has_risk": true, "verification_notes": "分析结论正确，is_hap_in_allowlist函数确实存在未处理的CString转换风险，可能导致panic。前置条件合理（输入可能包含null字节），触发路径清晰（外部输入通过upgrade_clone_app_data传递），后果评估准确（会导致panic），建议合适（应使用match或unwrap_or_else处理错误）"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "services/core_service/src/lib.rs", "line": 124, "evidence": "let _ = upload_system_event(start_service(handler), &calling_info, start, func_name, &AssetMap::new());", "confidence": 0.55, "severity": "low", "gid": 385, "verify": "验证被忽略的返回值是否可能包含重要错误信息", "preconditions": "start_service()函数返回错误结果（插件加载失败或IPC发布失败）", "trigger_path": "调用路径推导：on_start_with_reason() -> upload_system_event(start_service(handler), ...)。数据流：handler参数传递给start_service()，start_service()可能返回错误结果，该结果被upload_system_event()处理但最终被调用者忽略。关键调用点：on_start_with_reason()未检查upload_system_event()的返回值。", "consequences": "服务启动失败未被正确处理，错误信息丢失，可能导致服务异常运行", "suggestions": "检查upload_system_event()的返回值或至少记录错误日志", "has_risk": true, "verification_notes": "分析结论正确：\n1. 前置条件合理：start_service()确实返回Result类型，可能包含插件加载失败或IPC发布失败的错误\n2. 触发路径成立：调用路径为on_start_with_reason() -> upload_system_event(start_service(handler),...)，且调用者确实忽略了返回值\n3. 后果评估准确：忽略返回值会导致服务启动失败未被正确处理\n4. 建议合适：检查返回值或记录错误日志是合理的改进方案"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "services/core_service/src/common_event/listener.rs", "line": 237, "evidence": "let owner: Vec<u8> = unsafe { slice::from_raw_parts(owner.data, owner.size as usize).to_vec() };", "confidence": 0.8, "severity": "high", "gid": 392, "verify": "验证指针在解引用前非空且长度参数有效", "preconditions": "外部调用者传入无效的owner.data或owner.size", "trigger_path": "调用路径推导：外部C代码 -> on_package_removed() -> delete_data_by_owner() -> unsafe代码块。数据流：外部输入通过PackageInfoFfi结构体传递，owner字段未经校验直接使用。关键调用点：delete_data_by_owner()函数未对owner.data和owner.size进行校验。", "consequences": "可能导致内存访问越界或空指针解引用", "suggestions": "在delete_data_by_owner函数入口处添加对owner.data和owner.size的校验", "has_risk": true, "verification_notes": "分析结论正确，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "services/core_service/src/common_event/listener.rs", "line": 275, "evidence": "let bundle_name: Vec<u8> = unsafe {", "confidence": 0.8, "severity": "high", "gid": 393, "verify": "验证指针在解引用前非空且长度参数有效", "preconditions": "外部调用者传入无效的bundle_name.data或bundle_name.size", "trigger_path": "调用路径推导：外部C代码 -> on_package_removed() -> unsafe代码块。数据流：外部输入通过PackageInfoFfi结构体传递，bundle_name字段未经校验直接使用。关键调用点：on_package_removed()函数未对bundle_name.data和bundle_name.size进行校验。", "consequences": "可能导致内存访问越界或空指针解引用", "suggestions": "在on_package_removed函数入口处添加对bundle_name.data和bundle_name.size的校验", "has_risk": true, "verification_notes": "分析结论正确，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "services/core_service/src/common_event/listener.rs", "line": 343, "evidence": "let c_str = unsafe { CStr::from_ptr(bundle_name as _) };", "confidence": 0.8, "severity": "high", "gid": 394, "verify": "验证指针在解引用前非空且长度参数有效", "preconditions": "外部调用者传入null指针作为bundle_name参数", "trigger_path": "调用路径推导：外部C代码 -> on_app_restore() -> unsafe代码块。数据流：外部输入直接作为指针参数传递，未经null检查。关键调用点：on_app_restore()函数未对bundle_name指针进行null检查。", "consequences": "可能导致空指针解引用和程序崩溃", "suggestions": "在调用CStr::from_ptr之前添加对bundle_name的null检查", "has_risk": true, "verification_notes": "分析结论正确，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "services/core_service/src/common_event/listener.rs", "line": 72, "evidence": "fn GetUninstallGroups(userId: i32, developer_id: *const ConstAssetBlob, group_ids: *mut MutAssetBlobArray) -> i32;", "confidence": 0.75, "severity": "medium", "gid": 401, "verify": "验证指针参数的有效性和安全性", "preconditions": "developer_id或group_ids指针无效或指向非法内存", "trigger_path": "调用路径推导：delete_data_by_owner() -> construct_calling_infos() -> GetUninstallGroups()。数据流：通过PackageInfoFfi结构体传入原始指针，construct_calling_infos()函数(line 182)有基本非空检查但未验证内存有效性，直接传递给GetUninstallGroups()。关键调用点：construct_calling_infos()未充分验证指针有效性。", "consequences": "可能导致内存访问违规或任意代码执行", "suggestions": "1. 添加指针有效性验证；2. 使用Rust的NonNull类型包装指针；3. 考虑改用安全FFI模式", "has_risk": true, "verification_notes": "分析结论正确，前置条件合理（指针可能无效），触发路径清晰（construct_calling_infos确实调用GetUninstallGroups），后果评估准确（可能导致内存访问违规），建议合适"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "services/core_service/src/common_event/listener.rs", "line": 436, "evidence": "fn GetUserIds(userIdsPtr: *mut i32, userIdsSize: *mut u32) -> i32;", "confidence": 0.75, "severity": "medium", "gid": 403, "verify": "验证指针参数的有效性和安全性", "preconditions": "userIdsPtr或userIdsSize指针无效或指向非法内存", "trigger_path": "调用路径推导：trigger_sync()/backup_all_db() -> GetUserIds()/GetFirstUnlockUserIds()/GetUsersSize()。数据流：本地分配缓冲区后直接传递原始指针，未验证指针有效性。关键调用点：调用前仅分配缓冲区但未添加边界检查。", "consequences": "可能导致缓冲区溢出或内存损坏", "suggestions": "1. 添加指针和缓冲区大小验证；2. 使用Rust的slice类型代替原始指针；3. 实现安全的FFI包装器", "has_risk": true, "verification_notes": "分析结论正确，前置条件合理（指针可能无效），触发路径清晰（trigger_sync/backup_all_db调用这些函数），后果评估准确（可能导致缓冲区溢出），建议合适"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "services/core_service/src/common_event/listener.rs", "line": 437, "evidence": "fn GetFirstUnlockUserIds(userIdsPtr: *mut i32, userIdsSize: *mut u32) -> i32;", "confidence": 0.75, "severity": "medium", "gid": 404, "verify": "验证指针参数的有效性和安全性", "preconditions": "userIdsPtr或userIdsSize指针无效或指向非法内存", "trigger_path": "调用路径推导：trigger_sync()/backup_all_db() -> GetUserIds()/GetFirstUnlockUserIds()/GetUsersSize()。数据流：本地分配缓冲区后直接传递原始指针，未验证指针有效性。关键调用点：调用前仅分配缓冲区但未添加边界检查。", "consequences": "可能导致缓冲区溢出或内存损坏", "suggestions": "1. 添加指针和缓冲区大小验证；2. 使用Rust的slice类型代替原始指针；3. 实现安全的FFI包装器", "has_risk": true, "verification_notes": "分析结论正确，前置条件合理（指针可能无效），触发路径清晰（trigger_sync/backup_all_db调用这些函数），后果评估准确（可能导致缓冲区溢出），建议合适"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "services/core_service/src/common_event/listener.rs", "line": 438, "evidence": "fn GetUsersSize(userIdsSize: *mut u32) -> i32;", "confidence": 0.75, "severity": "medium", "gid": 405, "verify": "验证指针参数的有效性和安全性", "preconditions": "userIdsPtr或userIdsSize指针无效或指向非法内存", "trigger_path": "调用路径推导：trigger_sync()/backup_all_db() -> GetUserIds()/GetFirstUnlockUserIds()/GetUsersSize()。数据流：本地分配缓冲区后直接传递原始指针，未验证指针有效性。关键调用点：调用前仅分配缓冲区但未添加边界检查。", "consequences": "可能导致缓冲区溢出或内存损坏", "suggestions": "1. 添加指针和缓冲区大小验证；2. 使用Rust的slice类型代替原始指针；3. 实现安全的FFI包装器", "has_risk": true, "verification_notes": "分析结论正确，前置条件合理（指针可能无效），触发路径清晰（trigger_sync/backup_all_db调用这些函数），后果评估准确（可能导致缓冲区溢出），建议合适"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "services/core_service/src/common_event/listener.rs", "line": 189, "evidence": "let data_str = CString::new(String::from_utf8_lossy(data).to_string()).unwrap();", "confidence": 0.65, "severity": "medium", "gid": 408, "verify": "验证unwrap/expect调用前是否有错误处理", "preconditions": "输入数据包含null字节", "trigger_path": "调用路径推导：delete_data_by_owner() -> construct_calling_infos()。数据流：外部FFI调用传入的原始字节数据通过construct_calling_infos()处理，在转换为CString时未检查是否包含null字节。关键调用点：construct_calling_infos()函数未对输入数据进行null字节检查。", "consequences": "程序panic导致服务中断", "suggestions": "使用expect_with提供更有意义的错误信息，或改用CString::new_with_nul处理可能包含null字节的情况", "has_risk": true, "verification_notes": "分析结论正确，前置条件合理（输入数据可能包含null字节），触发路径清晰（来自FFI调用未检查null字节），后果评估准确（会导致panic），建议合适（应使用expect_with或CString::new_with_nul）"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "services/core_service/src/common_event/listener.rs", "line": 548, "evidence": "let mut user_ids: Vec<i32> = vec![0i32; (*user_ids_size_ptr + USER_ID_VEC_BUFFER).try_into().unwrap()];", "confidence": 0.65, "severity": "medium", "gid": 412, "verify": "验证unwrap/expect调用前是否有错误处理", "preconditions": "user_ids_size_ptr值过大导致整数转换失败", "trigger_path": "调用路径推导：backup_all_db()。数据流：通过FFI调用GetUsersSize()获取的用户ID数量，在转换为usize时未进行边界检查。关键调用点：backup_all_db()函数未对user_ids_size_ptr的值进行有效性验证。", "consequences": "整数转换失败导致程序panic", "suggestions": "添加边界检查，确保user_ids_size_ptr的值在合理范围内", "has_risk": true, "verification_notes": "分析结论正确，前置条件合理（user_ids_size_ptr可能过大），触发路径清晰（来自GetUsersSize的FFI调用未边界检查），后果评估准确（整数转换失败会导致panic），建议合适（需要添加边界检查）"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "services/core_service/src/common_event/listener.rs", "line": 555, "evidence": "let user_ids_slice = unsafe { slice::from_raw_parts_mut(user_ids_ptr, (*user_ids_size_ptr).try_into().unwrap()) };", "confidence": 0.65, "severity": "medium", "gid": 413, "verify": "验证unwrap/expect调用前是否有错误处理", "preconditions": "user_ids_size_ptr值过大导致整数转换失败", "trigger_path": "调用路径推导：backup_all_db()。数据流：通过FFI调用GetUsersSize()获取的用户ID数量，在转换为usize时未进行边界检查。关键调用点：backup_all_db()函数未对user_ids_size_ptr的值进行有效性验证。", "consequences": "整数转换失败导致程序panic", "suggestions": "添加边界检查，确保user_ids_size_ptr的值在合理范围内", "has_risk": true, "verification_notes": "分析结论正确，前置条件合理（user_ids_size_ptr可能过大），触发路径清晰（来自GetUsersSize的FFI调用未边界检查），后果评估准确（整数转换失败会导致panic），建议合适（需要添加边界检查）"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "services/core_service/src/operations/operation_post_query.rs", "line": 43, "evidence": "crypto_manager.lock().unwrap().remove(calling_info, challenge);", "confidence": 0.65, "severity": "medium", "gid": 432, "verify": "验证候选 432 的安全风险", "preconditions": "Mutex被污染(线程panic持有锁)", "trigger_path": "调用路径推导：post_query() -> CryptoManager::get_instance() -> lock().unwrap()。数据流：handle参数(AssetMap)和calling_info参数通过post_query()传入，传递给CryptoManager::get_instance()获取单例实例，然后调用lock()获取互斥锁。关键调用点：lock()后直接使用unwrap()而没有错误处理。", "consequences": "线程panic，可能导致服务中断", "suggestions": "将unwrap()改为expect()提供更有意义的错误信息，或使用match/if let处理可能的错误", "has_risk": true, "verification_notes": "分析结论正确，前置条件合理（CryptoManager使用OnceLock+Arc<Mutex>实现线程安全单例），触发路径清晰（post_query() -> CryptoManager::get_instance() -> lock().unwrap()），后果评估准确（Mutex锁unwrap失败会导致panic），建议合适（应改用expect提供更有意义的错误信息）"}
{"language": "rust", "category": "ffi", "pattern": "CString/CStr", "file": "services/core_service/src/operations/operation_add.rs", "line": 18, "evidence": "use std::{ffi::CString, os::raw::c_char};", "confidence": 0.65, "severity": "medium", "gid": 440, "verify": "检查FFI相关导入的使用情况，确认是否有必要且安全", "preconditions": "当传入的权限字符串包含null字节时", "trigger_path": "调用路径推导：外部调用 -> check_persistent_permission() -> CString::new()。数据流：权限检查请求通过外部调用进入系统，传递给check_persistent_permission()函数，该函数使用硬编码的权限字符串创建CString，未处理可能的null字节错误。关键调用点：check_persistent_permission()函数直接使用unwrap()而未处理可能的错误。", "consequences": "可能导致程序panic，拒绝服务攻击", "suggestions": "1. 使用expect()替代unwrap()并提供有意义的错误信息；2. 使用match或unwrap_or_else处理可能的错误；3. 考虑将硬编码字符串定义为常量", "has_risk": true, "verification_notes": "分析结论正确：\n1. 前置条件合理：确实存在硬编码权限字符串\"ohos.permission.STORE_PERSISTENT_DATA\"转换为CString的情况\n2. 触发路径成立：调用路径为外部调用->check_persistent_permission()->CString::new()，且确实使用了unwrap()而未处理错误\n3. 后果评估准确：如果传入包含null字节的字符串确实会导致panic\n4. 建议合适：使用expect()或match处理错误是合理的改进方案"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "services/plugin/src/asset_plugin.rs", "line": 131, "evidence": "let developer_id: Vec<u8> = parts.next().unwrap().to_vec();", "confidence": 0.65, "severity": "medium", "gid": 452, "verify": "验证unwrap/expect前的Option/Result是否确实不会为None/Err", "preconditions": "输入数据中的GROUP_ID字段格式不正确，缺少GROUP_SEPARATOR分隔符", "trigger_path": "调用路径推导：get_db_name() -> attributes.get(&column::GROUP_ID) -> split() -> parts.next().unwrap()。数据流：外部输入通过ExtDbMap传递到get_db_name函数，attributes.get(&column::GROUP_ID)获取分组ID，使用GROUP_SEPARATOR分割后直接调用unwrap()。关键调用点：get_db_name函数未对分割结果进行校验。", "consequences": "程序panic崩溃，可能导致服务不可用", "suggestions": "使用match或if let对Option进行安全处理，或返回错误而不是panic", "has_risk": true, "verification_notes": "分析结论正确，前置条件合理（GROUP_ID字段可能缺少分隔符），触发路径成立（从外部输入到unwrap调用点缺少校验），后果评估准确（会导致panic崩溃），建议合适（应使用match或if let处理Option）"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "services/plugin/src/asset_plugin.rs", "line": 132, "evidence": "let group_id: Vec<u8> = parts.next().unwrap().to_vec();", "confidence": 0.65, "severity": "medium", "gid": 453, "verify": "验证unwrap/expect前的Option/Result是否确实不会为None/Err", "preconditions": "输入数据中的GROUP_ID字段格式不正确，缺少GROUP_SEPARATOR分隔符", "trigger_path": "调用路径推导：get_db_name() -> attributes.get(&column::GROUP_ID) -> split() -> parts.next().unwrap()。数据流：外部输入通过ExtDbMap传递到get_db_name函数，attributes.get(&column::GROUP_ID)获取分组ID，使用GROUP_SEPARATOR分割后直接调用unwrap()。关键调用点：get_db_name函数未对分割结果进行校验。", "consequences": "程序panic崩溃，可能导致服务不可用", "suggestions": "使用match或if let对Option进行安全处理，或返回错误而不是panic", "has_risk": true, "verification_notes": "分析结论正确，前置条件合理（GROUP_ID字段可能缺少分隔符），触发路径成立（从外部输入到unwrap调用点缺少校验），后果评估准确（会导致panic崩溃），建议合适（应使用match或if let处理Option）"}
{"language": "rust", "category": "concurrency", "pattern": "unsafe_impl_Send_or_Sync", "file": "services/plugin/src/asset_plugin.rs", "line": 45, "evidence": "unsafe impl Sync for AssetPlugin {}", "confidence": 0.8, "severity": "high", "gid": 454, "verify": "验证Sync trait的实现是否确实线程安全", "preconditions": "在多线程环境下通过get_instance()获取AssetPlugin实例并访问lib字段", "trigger_path": "调用路径推导：get_instance() -> Arc<AssetPlugin> -> 多线程访问lib字段。数据流：通过get_instance()获取的Arc<AssetPlugin>可以在多线程间共享，任何线程都可以访问lib字段。关键调用点：RefCell<Option<libloading::Library>>不是线程安全的，但被标记为Sync。", "consequences": "多线程环境下同时访问lib字段会导致数据竞争，可能引发内存损坏或未定义行为", "suggestions": "使用Mutex或RwLock替代RefCell来保证线程安全，或者移除Sync实现如果不需要跨线程共享", "has_risk": true, "verification_notes": "分析结论正确，前置条件合理（确实存在RefCell<Option<libloading::Library>>字段并通过get_instance()共享），触发路径清晰（多线程访问lib字段），后果评估准确（会导致数据竞争），建议合适（应使用Mutex/RwLock或移除Sync实现）"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "interfaces/inner_kits/c/src/lib.rs", "line": 68, "evidence": "let blob_slice = slice::from_raw_parts((*attr).value.blob.data, (*attr).value.blob.size as usize);", "confidence": 0.85, "severity": "high", "gid": 495, "verify": "验证不安全内存操作的范围和有效性", "preconditions": "C端传入的blob.size与实际分配的内存大小不匹配", "trigger_path": "调用路径推导：外部C调用 -> add_asset/remove_asset/update_asset等 -> into_map -> from_raw_parts。数据流：C端传入的AssetAttr结构体包含blob数据指针和大小，into_map函数检查指针非空和size非零，但未验证size与实际分配内存的匹配关系。关键调用点：into_map函数未完全验证blob数据的有效性。", "consequences": "可能导致越界内存访问，引发程序崩溃或信息泄露", "suggestions": "1. 在C端确保正确维护size与分配内存的关系 2. 在Rust端增加对size的边界检查 3. 考虑使用更安全的FFI接口设计", "has_risk": true, "verification_notes": "分析结论正确：\n1. 前置条件合理：代码确实未验证C端传入的blob.size与实际分配内存的匹配关系（仅检查了非空和size非零）\n2. 触发路径成立：调用路径和数据处理流程与分析描述一致\n3. 后果评估准确：确实存在越界访问风险\n4. 建议合适：提出的3条改进建议都针对实际风险点\n验证依据：\n- 代码中确实使用slice::from_raw_parts且仅做了基础检查（行64-68）\n- 检索到的项目记忆也确认了该模块的FFI安全注意事项"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "interfaces/inner_kits/c/src/lib.rs", "line": 91, "evidence": "let ret = if let Err(e) = manager.lock().unwrap().add(&map) {", "confidence": 0.65, "severity": "medium", "gid": 483, "verify": "验证是否有比unwrap/expect更安全的错误处理方式", "preconditions": "Manager锁获取失败（如线程panic持有锁）", "trigger_path": "调用路径推导：C调用方 -> Rust FFI函数（如add_asset/remove_asset等） -> manager.lock().unwrap()。数据流：所有路径都从C调用的Rust FFI函数开始，直接调用manager.lock().unwrap()。关键调用点：所有FFI函数都未对锁获取错误进行处理，直接使用unwrap()。", "consequences": "如果锁获取失败会导致程序崩溃，影响系统稳定性", "suggestions": "使用manager.lock().map_err(|e| ...)替代unwrap()，或者使用expect()提供更有意义的错误信息，或者使用match显式处理锁获取错误", "has_risk": true, "verification_notes": "分析结论正确：\n1. 前置条件合理：确实存在Manager锁获取失败的风险，特别是在多线程环境下\n2. 触发路径成立：所有FFI函数都直接调用manager.lock().unwrap()，没有中间处理层\n3. 后果评估准确：锁获取失败会导致panic，影响系统稳定性\n4. 建议合适：使用map_err或expect替代unwrap是更安全的做法\n代码中确实存在多处直接使用unwrap()获取锁的情况，且没有对锁获取错误进行处理"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "interfaces/inner_kits/c/src/lib.rs", "line": 112, "evidence": "let ret = if let Err(e) = manager.lock().unwrap().remove(&map) {", "confidence": 0.65, "severity": "medium", "gid": 484, "verify": "验证是否有比unwrap/expect更安全的错误处理方式", "preconditions": "Manager锁获取失败（如线程panic持有锁）", "trigger_path": "调用路径推导：C调用方 -> Rust FFI函数（如add_asset/remove_asset等） -> manager.lock().unwrap()。数据流：所有路径都从C调用的Rust FFI函数开始，直接调用manager.lock().unwrap()。关键调用点：所有FFI函数都未对锁获取错误进行处理，直接使用unwrap()。", "consequences": "如果锁获取失败会导致程序崩溃，影响系统稳定性", "suggestions": "使用manager.lock().map_err(|e| ...)替代unwrap()，或者使用expect()提供更有意义的错误信息，或者使用match显式处理锁获取错误", "has_risk": true, "verification_notes": "分析结论正确：\n1. 前置条件合理：确实存在Manager锁获取失败的风险，特别是在多线程环境下\n2. 触发路径成立：所有FFI函数都直接调用manager.lock().unwrap()，没有中间处理层\n3. 后果评估准确：锁获取失败会导致panic，影响系统稳定性\n4. 建议合适：使用map_err或expect替代unwrap是更安全的做法\n代码中确实存在多处直接使用unwrap()获取锁的情况，且没有对锁获取错误进行处理"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "interfaces/inner_kits/c/src/lib.rs", "line": 143, "evidence": "let ret = if let Err(e) = manager.lock().unwrap().update(&query_map, &update_map) {", "confidence": 0.65, "severity": "medium", "gid": 485, "verify": "验证是否有比unwrap/expect更安全的错误处理方式", "preconditions": "Manager锁获取失败（如线程panic持有锁）", "trigger_path": "调用路径推导：C调用方 -> Rust FFI函数（如add_asset/remove_asset等） -> manager.lock().unwrap()。数据流：所有路径都从C调用的Rust FFI函数开始，直接调用manager.lock().unwrap()。关键调用点：所有FFI函数都未对锁获取错误进行处理，直接使用unwrap()。", "consequences": "如果锁获取失败会导致程序崩溃，影响系统稳定性", "suggestions": "使用manager.lock().map_err(|e| ...)替代unwrap()，或者使用expect()提供更有意义的错误信息，或者使用match显式处理锁获取错误", "has_risk": true, "verification_notes": "分析结论正确：\n1. 前置条件合理：确实存在Manager锁获取失败的风险，特别是在多线程环境下\n2. 触发路径成立：所有FFI函数都直接调用manager.lock().unwrap()，没有中间处理层\n3. 后果评估准确：锁获取失败会导致panic，影响系统稳定性\n4. 建议合适：使用map_err或expect替代unwrap是更安全的做法\n代码中确实存在多处直接使用unwrap()获取锁的情况，且没有对锁获取错误进行处理"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "interfaces/inner_kits/c/src/lib.rs", "line": 173, "evidence": "let res = match manager.lock().unwrap().pre_query(&map) {", "confidence": 0.65, "severity": "medium", "gid": 486, "verify": "验证是否有比unwrap/expect更安全的错误处理方式", "preconditions": "Manager锁获取失败（如线程panic持有锁）", "trigger_path": "调用路径推导：C调用方 -> Rust FFI函数（如add_asset/remove_asset等） -> manager.lock().unwrap()。数据流：所有路径都从C调用的Rust FFI函数开始，直接调用manager.lock().unwrap()。关键调用点：所有FFI函数都未对锁获取错误进行处理，直接使用unwrap()。", "consequences": "如果锁获取失败会导致程序崩溃，影响系统稳定性", "suggestions": "使用manager.lock().map_err(|e| ...)替代unwrap()，或者使用expect()提供更有意义的错误信息，或者使用match显式处理锁获取错误", "has_risk": true, "verification_notes": "分析结论正确：\n1. 前置条件合理：确实存在Manager锁获取失败的风险，特别是在多线程环境下\n2. 触发路径成立：所有FFI函数都直接调用manager.lock().unwrap()，没有中间处理层\n3. 后果评估准确：锁获取失败会导致panic，影响系统稳定性\n4. 建议合适：使用map_err或expect替代unwrap是更安全的做法\n代码中确实存在多处直接使用unwrap()获取锁的情况，且没有对锁获取错误进行处理"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "interfaces/inner_kits/c/src/lib.rs", "line": 209, "evidence": "let res = match manager.lock().unwrap().query(&map) {", "confidence": 0.65, "severity": "medium", "gid": 487, "verify": "验证是否有比unwrap/expect更安全的错误处理方式", "preconditions": "Manager锁获取失败（如线程panic持有锁）", "trigger_path": "调用路径推导：C调用方 -> Rust FFI函数（如add_asset/remove_asset等） -> manager.lock().unwrap()。数据流：所有路径都从C调用的Rust FFI函数开始，直接调用manager.lock().unwrap()。关键调用点：所有FFI函数都未对锁获取错误进行处理，直接使用unwrap()。", "consequences": "如果锁获取失败会导致程序崩溃，影响系统稳定性", "suggestions": "使用manager.lock().map_err(|e| ...)替代unwrap()，或者使用expect()提供更有意义的错误信息，或者使用match显式处理锁获取错误", "has_risk": true, "verification_notes": "分析结论正确：\n1. 前置条件合理：确实存在Manager锁获取失败的风险，特别是在多线程环境下\n2. 触发路径成立：所有FFI函数都直接调用manager.lock().unwrap()，没有中间处理层\n3. 后果评估准确：锁获取失败会导致panic，影响系统稳定性\n4. 建议合适：使用map_err或expect替代unwrap是更安全的做法\n代码中确实存在多处直接使用unwrap()获取锁的情况，且没有对锁获取错误进行处理"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "interfaces/inner_kits/c/src/lib.rs", "line": 236, "evidence": "let ret = if let Err(e) = manager.lock().unwrap().post_query(&map) {", "confidence": 0.65, "severity": "medium", "gid": 488, "verify": "验证是否有比unwrap/expect更安全的错误处理方式", "preconditions": "Manager锁获取失败（如线程panic持有锁）", "trigger_path": "调用路径推导：C调用方 -> Rust FFI函数（如add_asset/remove_asset等） -> manager.lock().unwrap()。数据流：所有路径都从C调用的Rust FFI函数开始，直接调用manager.lock().unwrap()。关键调用点：所有FFI函数都未对锁获取错误进行处理，直接使用unwrap()。", "consequences": "如果锁获取失败会导致程序崩溃，影响系统稳定性", "suggestions": "使用manager.lock().map_err(|e| ...)替代unwrap()，或者使用expect()提供更有意义的错误信息，或者使用match显式处理锁获取错误", "has_risk": true, "verification_notes": "分析结论正确：\n1. 前置条件合理：确实存在Manager锁获取失败的风险，特别是在多线程环境下\n2. 触发路径成立：所有FFI函数都直接调用manager.lock().unwrap()，没有中间处理层\n3. 后果评估准确：锁获取失败会导致panic，影响系统稳定性\n4. 建议合适：使用map_err或expect替代unwrap是更安全的做法\n代码中确实存在多处直接使用unwrap()获取锁的情况，且没有对锁获取错误进行处理"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "interfaces/inner_kits/c/src/lib.rs", "line": 270, "evidence": "let ret = match manager.lock().unwrap().query_sync_result(&map) {", "confidence": 0.65, "severity": "medium", "gid": 489, "verify": "验证是否有比unwrap/expect更安全的错误处理方式", "preconditions": "Manager锁获取失败（如线程panic持有锁）", "trigger_path": "调用路径推导：C调用方 -> Rust FFI函数（如add_asset/remove_asset等） -> manager.lock().unwrap()。数据流：所有路径都从C调用的Rust FFI函数开始，直接调用manager.lock().unwrap()。关键调用点：所有FFI函数都未对锁获取错误进行处理，直接使用unwrap()。", "consequences": "如果锁获取失败会导致程序崩溃，影响系统稳定性", "suggestions": "使用manager.lock().map_err(|e| ...)替代unwrap()，或者使用expect()提供更有意义的错误信息，或者使用match显式处理锁获取错误", "has_risk": true, "verification_notes": "分析结论正确：\n1. 前置条件合理：确实存在Manager锁获取失败的风险，特别是在多线程环境下\n2. 触发路径成立：所有FFI函数都直接调用manager.lock().unwrap()，没有中间处理层\n3. 后果评估准确：锁获取失败会导致panic，影响系统稳定性\n4. 建议合适：使用map_err或expect替代unwrap是更安全的做法\n代码中确实存在多处直接使用unwrap()获取锁的情况，且没有对锁获取错误进行处理"}
