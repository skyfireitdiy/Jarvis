{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_ffrt/build.rs", "line": 21, "evidence": "let root = PathBuf::from(env::var_os(\"                  \").unwrap());", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_ffrt/build.rs", "line": 22, "evidence": "let library_dir = fs::canonicalize(root.join(\"   \")).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_ffrt/build.rs", "line": 27, "evidence": "env::join_paths([library_dir]).unwrap().to_str().unwrap()", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/macros.rs", "line": 136, "evidence": "let res = unsafe { libc::$fn($($arg, )*) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/select.rs", "line": 224, "evidence": "let fut = unsafe { Pin::new_unchecked(fut) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/select.rs", "line": 271, "evidence": "_ => unreachable!(\"                  \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/select.rs", "line": 277, "evidence": "$crate::select!({ random = $bool; $($t)*; panic!(\"                                 \") })", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/spawn.rs", "line": 41, "evidence": "let func = self.0.take().expect(\"                                              \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/error.rs", "line": 286, "evidence": "format!(\"  \", custom_error.into_inner().unwrap()),", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/util/slots.rs", "line": 265, "evidence": "None => panic!(\"             \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/util/slots.rs", "line": 267, "evidence": "None => panic!(\"             \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/util/slots.rs", "line": 277, "evidence": "None => panic!(\"             \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/util/slots.rs", "line": 279, "evidence": "None => panic!(\"             \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/slab.rs", "line": 83, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/slab.rs", "line": 94, "evidence": "unsafe { &(*self.value).value }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/slab.rs", "line": 98, "evidence": "unsafe impl<T: Sync> Sync for Ref<T> {}", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/slab.rs", "line": 99, "evidence": "unsafe impl<T: Sync> Send for Ref<T> {}", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/slab.rs", "line": 185, "evidence": "pub unsafe fn allocate(&self) -> Option<(Address, Ref<T>)> {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/slab.rs", "line": 202, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/slab.rs", "line": 221, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/slab.rs", "line": 255, "evidence": "pub unsafe fn compact(&mut self) {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/slab.rs", "line": 300, "evidence": "unsafe impl<T: Sync> Sync for Page<T> {}", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/slab.rs", "line": 301, "evidence": "unsafe impl<T: Sync> Send for Page<T> {}", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/slab.rs", "line": 329, "evidence": "unsafe fn allocate(me: &Arc<Page<T>>) -> Option<(Address, Ref<T>)> {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/slab.rs", "line": 445, "evidence": "unsafe fn release(&self) -> Arc<Page<T>> {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/slab.rs", "line": 525, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/slab.rs", "line": 556, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/slab.rs", "line": 577, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/slab.rs", "line": 590, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/slab.rs", "line": 619, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/slab.rs", "line": 668, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/slab.rs", "line": 708, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/slab.rs", "line": 752, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/slab.rs", "line": 818, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/util/slab.rs", "line": 76, "evidence": "value: *const Value<T>,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/util/slab.rs", "line": 315, "evidence": "fn release(&self, value: *const Value<T>) {", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/util/slab.rs", "line": 362, "evidence": "page: &**me as *const _,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/util/slab.rs", "line": 404, "evidence": "fn index_for(&self, slot: *const Value<T>) -> usize {", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/util/slab.rs", "line": 408, "evidence": "let base = &self.slots[0] as *const _ as usize;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/util/slab.rs", "line": 430, "evidence": "let slot = self as *const Slot<T>;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/util/slab.rs", "line": 441, "evidence": "pub page: *const Page<T>,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/util/slab.rs", "line": 447, "evidence": "page.release(self as *const _);", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "resource_management", "pattern": "mem::forget", "file": "ylong_runtime/src/util/slab.rs", "line": 429, "evidence": "std::mem::forget(page.clone());", "description": "使用 mem::forget 会跳过 Drop 导致资源泄漏，若错误使用可能破坏不变式或造成泄漏。", "suggestion": "避免无必要的 mem::forget；如需抑制 Drop，优先使用 ManuallyDrop 或设计更安全的所有权转移。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 157, "evidence": "let page = Arc::get_mut(page).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 199, "evidence": "let slots = self.pages[page_idx].slots.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 226, "evidence": ".unwrap()", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 316, "evidence": "let mut locked = self.slots.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 334, "evidence": "let mut locked = me.slots.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 527, "evidence": "let (_, foo1) = alloc.allocate().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 532, "evidence": "let (_, foo2) = alloc.allocate().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 536, "evidence": "let (_, foo3) = alloc.allocate().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 542, "evidence": "assert_eq!(temp.pop().unwrap(), value.id.load(SeqCst));", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 557, "evidence": "let (addr, _) = slab.allocate().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 579, "evidence": "let (addr, foo) = slab.allocate().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 584, "evidence": "assert_eq!(slab.get(address[32].0).unwrap().id.load(SeqCst), 32);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 594, "evidence": "let (addr, foo) = slab.allocate().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 599, "evidence": "drop(address.pop().unwrap().1);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 621, "evidence": "let (addr1, test_entry1) = alloc.allocate().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 623, "evidence": "slab.get(addr1).unwrap().id.store(1, SeqCst);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 625, "evidence": "assert_eq!(0, slab.get(addr1).unwrap().cnt.load(SeqCst));", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 628, "evidence": "let (addr2, test_entry2) = alloc.allocate().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 629, "evidence": "slab.get(addr2).unwrap().id.store(2, SeqCst);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 630, "evidence": "assert_eq!(0, slab.get(addr2).unwrap().cnt.load(SeqCst));", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 633, "evidence": "assert_eq!(1, slab.get(addr1).unwrap().id.load(SeqCst));", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 634, "evidence": "assert_eq!(2, slab.get(addr2).unwrap().id.load(SeqCst));", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 639, "evidence": "assert_eq!(1, slab.get(addr1).unwrap().id.load(SeqCst));", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 643, "evidence": "let (addr3, test_entry3) = alloc.allocate().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 646, "evidence": "assert_eq!(1, slab.get(addr3).unwrap().cnt.load(SeqCst));", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 647, "evidence": "slab.get(addr3).unwrap().id.store(3, SeqCst);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 648, "evidence": "assert_eq!(3, slab.get(addr3).unwrap().id.load(SeqCst));", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 676, "evidence": "let (addr, val) = alloc.allocate().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 683, "evidence": "assert_eq!(i, slab.get(*addr).unwrap().id.load(SeqCst));", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 689, "evidence": "let (addr, val) = alloc.allocate().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 696, "evidence": "assert_eq!(10_000 - i, slab.get(*addr).unwrap().id.load(SeqCst));", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 714, "evidence": "let (addr, val) = alloc.allocate().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 726, "evidence": "assert_eq!(i, slab.get(*addr).unwrap().id.load(SeqCst));", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 755, "evidence": "let (addr, test_entry) = thread_one_alloc.allocate().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 757, "evidence": "free_queue.lock().unwrap().push((addr, test_entry, i));", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 763, "evidence": "let (addr, test_entry) = thread_two_alloc.allocate().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 765, "evidence": "free_queue_2.lock().unwrap().push((addr, test_entry, i));", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 771, "evidence": "let (addr, test_entry) = thread_three_alloc.allocate().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 773, "evidence": "free_queue_3.lock().unwrap().push((addr, test_entry, i));", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 779, "evidence": ".expect(\"                                      \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 782, "evidence": ".expect(\"                                      \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 785, "evidence": ".expect(\"                                      \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 789, "evidence": "let temp = free_queue_4.clone().lock().unwrap().pop().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 790, "evidence": "assert_eq!(slab.get(temp.0).unwrap().id.load(SeqCst), temp.2);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 821, "evidence": "let (addr, test_entry) = thread_one_alloc.allocate().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 825, "evidence": "free_queue_one.lock().unwrap().push(addr);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 831, "evidence": ".expect(\"                                      \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 836, "evidence": "let (addr, test_entry) = thread_two_alloc.allocate().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 839, "evidence": "free_queue_two.lock().unwrap().push(addr);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 846, "evidence": ".expect(\"                                      \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 850, "evidence": "free_queue_one_2.clone().lock().unwrap().pop().unwrap(),", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/slab.rs", "line": 851, "evidence": "free_queue_two_2.lock().unwrap().pop().unwrap()", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/util/slab.rs", "line": 84, "evidence": "let _ = (*self.value).release();", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "unsafe_usage", "pattern": "pointer_arithmetic", "file": "ylong_runtime/src/util/slab.rs", "line": 203, "evidence": "let slot = slots.slots.as_ptr().add(slot_idx);", "description": "使用 offset/add 进行指针算术，若计算结果超出有效范围将导致未定义行为。", "suggestion": "确保指针算术结果在有效对象边界内；使用 slice 等安全抽象替代原始指针算术。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "pointer_arithmetic", "file": "ylong_runtime/src/util/slab.rs", "line": 229, "evidence": ".add(slot_idx);", "description": "使用 offset/add 进行指针算术，若计算结果超出有效范围将导致未定义行为。", "suggestion": "确保指针算术结果在有效对象边界内；使用 slice 等安全抽象替代原始指针算术。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/util/slab.rs", "line": 446, "evidence": "let page = Arc::from_raw(self.page);", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.7999999999999999, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/linked_list.rs", "line": 42, "evidence": "unsafe fn remove_node(node: NonNull<T>) -> Option<NonNull<T>> {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/linked_list.rs", "line": 59, "evidence": "unsafe impl<T: Send> Send for Node<T> {}", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/linked_list.rs", "line": 60, "evidence": "unsafe impl<T: Sync> Sync for Node<T> {}", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/linked_list.rs", "line": 66, "evidence": "unsafe impl<L: Link + Default + Send> Send for LinkedList<L> {}", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/linked_list.rs", "line": 67, "evidence": "unsafe impl<L: Link + Default + Sync> Sync for LinkedList<L> {}", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/linked_list.rs", "line": 76, "evidence": "pub(crate) unsafe trait Link {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/linked_list.rs", "line": 77, "evidence": "unsafe fn node(ptr: NonNull<Self>) -> NonNull<Node<Self>>", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/linked_list.rs", "line": 86, "evidence": "let head_ptr = unsafe { NonNull::new_unchecked(Box::into_raw(head)) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/linked_list.rs", "line": 87, "evidence": "let node = unsafe { L::node(head_ptr).as_mut() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/linked_list.rs", "line": 95, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/linked_list.rs", "line": 110, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/linked_list.rs", "line": 131, "evidence": "pub(crate) unsafe fn remove(&mut self, node: NonNull<L>) -> Option<NonNull<L>> {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/linked_list.rs", "line": 138, "evidence": "unsafe { L::node(self.head).as_ref().next == Some(self.head) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/linked_list.rs", "line": 148, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/linked_list.rs", "line": 172, "evidence": "let _ = unsafe { Box::from_raw(self.head.as_ptr()) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/linked_list.rs", "line": 201, "evidence": "unsafe fn address_of_node(mut ptr: NonNull<Entry>) -> NonNull<Node<Entry>> {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/linked_list.rs", "line": 207, "evidence": "unsafe { ptr.as_ref().val }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/linked_list.rs", "line": 210, "evidence": "unsafe impl Link for Entry {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/linked_list.rs", "line": 211, "evidence": "unsafe fn node(ptr: NonNull<Self>) -> NonNull<Node<Self>> {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/linked_list.rs", "line": 279, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/linked_list.rs", "line": 293, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/linked_list.rs", "line": 307, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/linked_list.rs", "line": 348, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/linked_list.rs", "line": 114, "evidence": "let node = head.prev.take().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/linked_list.rs", "line": 153, "evidence": "let node = p.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/linked_list.rs", "line": 252, "evidence": "assert_eq!(1, get_val(list.pop_back().unwrap()));", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/linked_list.rs", "line": 253, "evidence": "assert_eq!(2, get_val(list.pop_back().unwrap()));", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/linked_list.rs", "line": 254, "evidence": "assert_eq!(3, get_val(list.pop_back().unwrap()));", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/linked_list.rs", "line": 308, "evidence": "assert_eq!(get_val(list.remove(node3_ptr).unwrap()), 3);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/linked_list.rs", "line": 312, "evidence": "assert_eq!(get_val(list.remove(node1_ptr).unwrap()), 1);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/linked_list.rs", "line": 314, "evidence": "assert_eq!(get_val(list.remove(node2_ptr).unwrap()), 2);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/linked_list.rs", "line": 350, "evidence": "assert_eq!(node.unwrap().as_mut().val, 1);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/util/linked_list.rs", "line": 352, "evidence": "assert_eq!(node.unwrap().as_mut().val, 3);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/util/linked_list.rs", "line": 172, "evidence": "let _ = unsafe { Box::from_raw(self.head.as_ptr()) };", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.45000000000000007, "severity": "low"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/util/linked_list.rs", "line": 172, "evidence": "let _ = unsafe { Box::from_raw(self.head.as_ptr()) };", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.7999999999999999, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 205, "evidence": "unsafe { Waker::from_raw(RawWaker::new(data, &CURRENT_THREAD_RAW_WAKER_VIRTUAL_TABLE)) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 212, "evidence": "let parker = unsafe { Arc::from_raw(ptr.cast::<Parker>()) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 222, "evidence": "let parker = unsafe { Arc::from_raw(ptr.cast::<Parker>()) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 227, "evidence": "let parker = unsafe { Arc::from_raw(ptr.cast::<Parker>()) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 233, "evidence": "unsafe { mem::drop(Arc::from_raw(ptr.cast::<Parker>())) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 283, "evidence": "let mut future = unsafe { Pin::new_unchecked(&mut future) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "resource_management", "pattern": "mem::forget", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 215, "evidence": "mem::forget(parker.clone());", "description": "使用 mem::forget 会跳过 Drop 导致资源泄漏，若错误使用可能破坏不变式或造成泄漏。", "suggestion": "避免无必要的 mem::forget；如需抑制 Drop，优先使用 ManuallyDrop 或设计更安全的所有权转移。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "resource_management", "pattern": "mem::forget", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 229, "evidence": "mem::forget(parker);", "description": "使用 mem::forget 会跳过 Drop 导致资源泄漏，若错误使用可能破坏不变式或造成泄漏。", "suggestion": "避免无必要的 mem::forget；如需抑制 Drop，优先使用 ManuallyDrop 或设计更安全的所有权转移。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 60, "evidence": "let mut queue = self.inner.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 65, "evidence": "let parker_list = self.parker_list.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 74, "evidence": "let mut queue = self.inner.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 143, "evidence": "let mut lock = self.mutex.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 162, "evidence": "lock = self.condvar.wait(lock).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 178, "evidence": "let mut lock = self.mutex.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 191, "evidence": "let mut lock = self.mutex.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 258, "evidence": "let mut queue = self.scheduler.inner.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 263, "evidence": "let parker_list = self.scheduler.parker_list.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 275, "evidence": "let mut parker_list = self.scheduler.parker_list.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 338, "evidence": "let mut guard = self.mutex.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 341, "evidence": "guard = self.condvar.wait(guard).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 347, "evidence": "let mut guard = self.mutex.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 363, "evidence": "let tcp = TcpListener::bind(ADDR).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 364, "evidence": "let addr = tcp.local_addr().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 365, "evidence": "tx.send(addr).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 366, "evidence": "let (mut stream, _) = tcp.accept().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 369, "evidence": "stream.read_exact(&mut buf).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 373, "evidence": "stream.write_all(&buf).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 378, "evidence": "let addr = rx.await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 383, "evidence": "let mut tcp = tcp.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 386, "evidence": "tcp.write_all(&buf).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 389, "evidence": "tcp.read_exact(&mut buf).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 406, "evidence": "assert_eq!(spawner.scheduler.inner.lock().unwrap().len(), 0);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 407, "evidence": "assert_eq!(spawner.block_on(handle1).unwrap(), 1);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 408, "evidence": "assert_eq!(spawner.block_on(handle2).unwrap(), 1);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 422, "evidence": "let spawner = Arc::new(RuntimeBuilder::new_current_thread().build().unwrap());", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 474, "evidence": "join.join().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 492, "evidence": "let spawner = RuntimeBuilder::new_current_thread().build().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 497, "evidence": "spawner.block_on(join_handle).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 499, "evidence": "let spawner = RuntimeBuilder::new_current_thread().build().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 503, "evidence": "spawner.block_on(join_handle).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 122, "evidence": "actual => panic!(\"                                                    \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 125, "evidence": "Err(actual) => panic!(\"                                          \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 138, "evidence": "n => panic!(\"                                    \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 155, "evidence": "actual => panic!(\"                                                    \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 158, "evidence": "Err(actual) => panic!(\"                                          \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 169, "evidence": "n => panic!(\"                                    \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 184, "evidence": "actual => panic!(\"                                               \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 197, "evidence": "actual => panic!(\"                                               \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "concurrency", "pattern": "unsafe_impl_Send_or_Sync", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 55, "evidence": "unsafe impl Sync for CurrentThreadScheduler {}", "description": "手写 unsafe impl Send/Sync 可能破坏并发内存模型保证，带来数据竞争风险。", "suggestion": "避免手写 unsafe impl；必要时严格证明线程安全前置条件并最小化不安全区域。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 205, "evidence": "unsafe { Waker::from_raw(RawWaker::new(data, &CURRENT_THREAD_RAW_WAKER_VIRTUAL_TABLE)) }", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 212, "evidence": "let parker = unsafe { Arc::from_raw(ptr.cast::<Parker>()) };", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 222, "evidence": "let parker = unsafe { Arc::from_raw(ptr.cast::<Parker>()) };", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 227, "evidence": "let parker = unsafe { Arc::from_raw(ptr.cast::<Parker>()) };", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/executor/current_thread.rs", "line": 233, "evidence": "unsafe { mem::drop(Arc::from_raw(ptr.cast::<Parker>())) };", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/executor/driver_handle.rs", "line": 49, "evidence": "self.io.waker.wake().unwrap_or_else(|e| panic!(\"                                \"));", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/queue.rs", "line": 29, "evidence": "unsafe fn non_atomic_load(data: &AtomicU16) -> u16 {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/queue.rs", "line": 211, "evidence": "let tail_pos = unsafe { non_atomic_load(&self.rear) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/queue.rs", "line": 234, "evidence": "Some(unsafe { ptr::read(task).assume_init() })", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/queue.rs", "line": 242, "evidence": "let rear = unsafe { non_atomic_load(&self.rear) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/queue.rs", "line": 273, "evidence": "let rear = unsafe { non_atomic_load(&self.rear) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/queue.rs", "line": 279, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/queue.rs", "line": 322, "evidence": "let task = unsafe { ptr::read(task_ptr).assume_init() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/queue.rs", "line": 323, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/queue.rs", "line": 343, "evidence": "let mut dst_rear = unsafe { non_atomic_load(&dst.inner.rear) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/queue.rs", "line": 391, "evidence": "let task = unsafe { ptr::read(task_ptr).assume_init() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/queue.rs", "line": 394, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/queue.rs", "line": 404, "evidence": "let task = unsafe { ptr::read(task_ptr).assume_init() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/queue.rs", "line": 461, "evidence": "let task = unsafe { ptr::read(task_ptr.get()).assume_init() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/queue.rs", "line": 481, "evidence": "let rear = unsafe { non_atomic_load(&inner_buf.rear) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/queue.rs", "line": 485, "evidence": "let first_task = unsafe { Task::from_raw(list.pop_back()?) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/queue.rs", "line": 493, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/queue.rs", "line": 522, "evidence": ".map(|header| unsafe { Task::from_raw(header) });", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/executor/queue.rs", "line": 30, "evidence": "ptr::read((data as *const AtomicU16).cast::<u16>())", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/executor/queue.rs", "line": 15, "evidence": "use std::mem::MaybeUninit;", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/executor/queue.rs", "line": 131, "evidence": "buffer: Box<[UnsafeCell<MaybeUninit<Task>>]>,", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/executor/queue.rs", "line": 181, "evidence": "buffer.push(UnsafeCell::new(MaybeUninit::uninit()));", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/executor/queue.rs", "line": 234, "evidence": "Some(unsafe { ptr::read(task).assume_init() })", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/executor/queue.rs", "line": 316, "evidence": "tmp_buf.push(UnsafeCell::new(MaybeUninit::uninit()));", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/executor/queue.rs", "line": 322, "evidence": "let task = unsafe { ptr::read(task_ptr).assume_init() };", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/executor/queue.rs", "line": 391, "evidence": "let task = unsafe { ptr::read(task_ptr).assume_init() };", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/executor/queue.rs", "line": 404, "evidence": "let task = unsafe { ptr::read(task_ptr).assume_init() };", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/executor/queue.rs", "line": 457, "evidence": "pub(super) fn push_batch(&self, tasks: Vec<UnsafeCell<MaybeUninit<Task>>>, task: Task) {", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/executor/queue.rs", "line": 461, "evidence": "let task = unsafe { ptr::read(task_ptr.get()).assume_init() };", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/queue.rs", "line": 56, "evidence": "let (steal_pos, _) = unwrap(self.inner.front.load(Acquire));", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/queue.rs", "line": 65, "evidence": "fn unwrap(num: u32) -> (u16, u16) {", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/queue.rs", "line": 154, "evidence": "let (_, head) = unwrap(self.front.load(Acquire));", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/queue.rs", "line": 199, "evidence": "let (_, head) = unwrap(self.front.load(Acquire));", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/queue.rs", "line": 208, "evidence": "let (steal_pos, real_pos) = unwrap(head);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/queue.rs", "line": 240, "evidence": "let (steal_pos, _real_pos) = unwrap(front);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/queue.rs", "line": 249, "evidence": "let (_front_steal, front_real) = unwrap(prev);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/queue.rs", "line": 254, "evidence": "let (actual_steal_pos, actual_real_pos) = unwrap(actual);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/queue.rs", "line": 271, "evidence": "let (steal_pos, _) = unwrap(front);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/queue.rs", "line": 312, "evidence": "let (mut src_front_steal, _src_front_real) = unwrap(prev);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/queue.rs", "line": 353, "evidence": "let (src_front_steal, src_front_real) = unwrap(src_prev_front);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/queue.rs", "line": 383, "evidence": "let (mut src_front_steal, _src_front_real) = unwrap(src_next_front);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/queue.rs", "line": 438, "evidence": "let task = self.pop_front().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/queue.rs", "line": 458, "evidence": "let mut list = self.globals.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/queue.rs", "line": 484, "evidence": "let mut list = self.globals.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/queue.rs", "line": 519, "evidence": "let mut list = self.globals.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/queue.rs", "line": 531, "evidence": "let mut list = self.globals.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/queue.rs", "line": 570, "evidence": "let (_, real_pos) = crate::executor::queue::unwrap(front);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "concurrency", "pattern": "unsafe_impl_Send_or_Sync", "file": "ylong_runtime/src/executor/queue.rs", "line": 42, "evidence": "unsafe impl Send for LocalQueue {}", "description": "手写 unsafe impl Send/Sync 可能破坏并发内存模型保证，带来数据竞争风险。", "suggestion": "避免手写 unsafe impl；必要时严格证明线程安全前置条件并最小化不安全区域。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "concurrency", "pattern": "unsafe_impl_Send_or_Sync", "file": "ylong_runtime/src/executor/queue.rs", "line": 43, "evidence": "unsafe impl Sync for LocalQueue {}", "description": "手写 unsafe impl Send/Sync 可能破坏并发内存模型保证，带来数据竞争风险。", "suggestion": "避免手写 unsafe impl；必要时严格证明线程安全前置条件并最小化不安全区域。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "concurrency", "pattern": "unsafe_impl_Send_or_Sync", "file": "ylong_runtime/src/executor/queue.rs", "line": 45, "evidence": "unsafe impl Send for InnerBuffer {}", "description": "手写 unsafe impl Send/Sync 可能破坏并发内存模型保证，带来数据竞争风险。", "suggestion": "避免手写 unsafe impl；必要时严格证明线程安全前置条件并最小化不安全区域。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "concurrency", "pattern": "unsafe_impl_Send_or_Sync", "file": "ylong_runtime/src/executor/queue.rs", "line": 46, "evidence": "unsafe impl Sync for InnerBuffer {}", "description": "手写 unsafe impl Send/Sync 可能破坏并发内存模型保证，带来数据竞争风险。", "suggestion": "避免手写 unsafe impl；必要时严格证明线程安全前置条件并最小化不安全区域。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe_mem_ops", "file": "ylong_runtime/src/executor/queue.rs", "line": 30, "evidence": "ptr::read((data as *const AtomicU16).cast::<u16>())", "description": "使用不安全的内存操作（copy/copy_nonoverlapping/write/read），需确保指针有效性、对齐与重叠检查。", "suggestion": "优先使用安全的复制方法；必须使用时，在 SAFETY 注释中证明指针有效性、对齐与边界条件。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe_mem_ops", "file": "ylong_runtime/src/executor/queue.rs", "line": 234, "evidence": "Some(unsafe { ptr::read(task).assume_init() })", "description": "使用不安全的内存操作（copy/copy_nonoverlapping/write/read），需确保指针有效性、对齐与重叠检查。", "suggestion": "优先使用安全的复制方法；必须使用时，在 SAFETY 注释中证明指针有效性、对齐与边界条件。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe_mem_ops", "file": "ylong_runtime/src/executor/queue.rs", "line": 280, "evidence": "ptr::write((*ptr).as_mut_ptr(), task);", "description": "使用不安全的内存操作（copy/copy_nonoverlapping/write/read），需确保指针有效性、对齐与重叠检查。", "suggestion": "优先使用安全的复制方法；必须使用时，在 SAFETY 注释中证明指针有效性、对齐与边界条件。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe_mem_ops", "file": "ylong_runtime/src/executor/queue.rs", "line": 322, "evidence": "let task = unsafe { ptr::read(task_ptr).assume_init() };", "description": "使用不安全的内存操作（copy/copy_nonoverlapping/write/read），需确保指针有效性、对齐与重叠检查。", "suggestion": "优先使用安全的复制方法；必须使用时，在 SAFETY 注释中证明指针有效性、对齐与边界条件。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe_mem_ops", "file": "ylong_runtime/src/executor/queue.rs", "line": 324, "evidence": "ptr::write((*dst_ptr.get()).as_mut_ptr(), task);", "description": "使用不安全的内存操作（copy/copy_nonoverlapping/write/read），需确保指针有效性、对齐与重叠检查。", "suggestion": "优先使用安全的复制方法；必须使用时，在 SAFETY 注释中证明指针有效性、对齐与边界条件。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe_mem_ops", "file": "ylong_runtime/src/executor/queue.rs", "line": 391, "evidence": "let task = unsafe { ptr::read(task_ptr).assume_init() };", "description": "使用不安全的内存操作（copy/copy_nonoverlapping/write/read），需确保指针有效性、对齐与重叠检查。", "suggestion": "优先使用安全的复制方法；必须使用时，在 SAFETY 注释中证明指针有效性、对齐与边界条件。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe_mem_ops", "file": "ylong_runtime/src/executor/queue.rs", "line": 395, "evidence": "ptr::write((*ptr).as_mut_ptr(), task);", "description": "使用不安全的内存操作（copy/copy_nonoverlapping/write/read），需确保指针有效性、对齐与重叠检查。", "suggestion": "优先使用安全的复制方法；必须使用时，在 SAFETY 注释中证明指针有效性、对齐与边界条件。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe_mem_ops", "file": "ylong_runtime/src/executor/queue.rs", "line": 404, "evidence": "let task = unsafe { ptr::read(task_ptr).assume_init() };", "description": "使用不安全的内存操作（copy/copy_nonoverlapping/write/read），需确保指针有效性、对齐与重叠检查。", "suggestion": "优先使用安全的复制方法；必须使用时，在 SAFETY 注释中证明指针有效性、对齐与边界条件。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe_mem_ops", "file": "ylong_runtime/src/executor/queue.rs", "line": 461, "evidence": "let task = unsafe { ptr::read(task_ptr.get()).assume_init() };", "description": "使用不安全的内存操作（copy/copy_nonoverlapping/write/read），需确保指针有效性、对齐与重叠检查。", "suggestion": "优先使用安全的复制方法；必须使用时，在 SAFETY 注释中证明指针有效性、对齐与边界条件。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe_mem_ops", "file": "ylong_runtime/src/executor/queue.rs", "line": 494, "evidence": "ptr::write((*ptr).as_mut_ptr(), Task::from_raw(task));", "description": "使用不安全的内存操作（copy/copy_nonoverlapping/write/read），需确保指针有效性、对齐与重叠检查。", "suggestion": "优先使用安全的复制方法；必须使用时，在 SAFETY 注释中证明指针有效性、对齐与边界条件。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/executor/queue.rs", "line": 485, "evidence": "let first_task = unsafe { Task::from_raw(list.pop_back()?) };", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/executor/queue.rs", "line": 494, "evidence": "ptr::write((*ptr).as_mut_ptr(), Task::from_raw(task));", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/executor/queue.rs", "line": 522, "evidence": ".map(|header| unsafe { Task::from_raw(header) });", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_runtime/src/executor/queue.rs", "line": 181, "evidence": "buffer.push(UnsafeCell::new(MaybeUninit::uninit()));", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_runtime/src/executor/queue.rs", "line": 316, "evidence": "tmp_buf.push(UnsafeCell::new(MaybeUninit::uninit()));", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/executor/driver.rs", "line": 80, "evidence": ".unwrap_or_else(|e| panic!(\"                                    \"));", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/executor/driver.rs", "line": 104, "evidence": ".unwrap_or_else(|e| panic!(\"                                    \"));", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/parker.rs", "line": 124, "evidence": "let mut l = self.mutex.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/parker.rs", "line": 141, "evidence": "let (lock, timeout_result) = self.condvar.wait_timeout(l, duration).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/parker.rs", "line": 145, "evidence": "l = self.condvar.wait(l).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/executor/parker.rs", "line": 109, "evidence": "Err(actual) => panic!(\"                                          \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/executor/parker.rs", "line": 118, "evidence": "n => panic!(\"                                    \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/executor/parker.rs", "line": 135, "evidence": "Err(actual) => panic!(\"                                          \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/executor/parker.rs", "line": 173, "evidence": "actual => panic!(\"                                               \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/async_pool.rs", "line": 545, "evidence": "pub(crate) unsafe fn spawn_with_ref<T>(", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/async_pool.rs", "line": 101, "evidence": "let join_handle = self.handles.read().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/async_pool.rs", "line": 113, "evidence": "let mut search_list = self.sleeper.wake_by_search.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/async_pool.rs", "line": 134, "evidence": ".unwrap()", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/async_pool.rs", "line": 136, "evidence": ".unwrap()", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/async_pool.rs", "line": 162, "evidence": "let local_run_queue = self.locals.get(index).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/async_pool.rs", "line": 172, "evidence": "let item = self.locals.get(index).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/async_pool.rs", "line": 205, "evidence": "let local_run_queue = self.locals.get(worker_ctx.worker.index).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/async_pool.rs", "line": 320, "evidence": "let target = self.locals.get(i).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/async_pool.rs", "line": 399, "evidence": "let mut finished = lock.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/async_pool.rs", "line": 453, "evidence": "self.inner.workers.lock().unwrap().push(worker.clone());", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/async_pool.rs", "line": 468, "evidence": "self.exe_mng_info.handles.write().unwrap().push(parker);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/async_pool.rs", "line": 570, "evidence": "let finished = lock.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/async_pool.rs", "line": 575, "evidence": ".unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/async_pool.rs", "line": 586, "evidence": "let mut join_handle = self.exe_mng_info.handles.write().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/async_pool.rs", "line": 598, "evidence": "let vec = self.inner.workers.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/executor/async_pool.rs", "line": 477, "evidence": "let _ = set_current_affinity(cpu_id);", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/mod.rs", "line": 133, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/executor/mod.rs", "line": 304, "evidence": "ctx.set((&cur_context as *const WorkerHandle).cast::<()>());", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/executor/mod.rs", "line": 22, "evidence": "use std::mem::MaybeUninit;", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/executor/mod.rs", "line": 130, "evidence": "static mut GLOBAL_DEFAULT_BLOCKING: MaybeUninit<BlockPoolSpawner> = MaybeUninit::uninit();", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/executor/mod.rs", "line": 143, "evidence": "Ok(bps) => GLOBAL_DEFAULT_BLOCKING = MaybeUninit::new(bps),", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/mod.rs", "line": 135, "evidence": "let mut global_builder = GLOBAL_BUILDER.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/executor/mod.rs", "line": 58, "evidence": "panic!(\"                          \");", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/executor/mod.rs", "line": 144, "evidence": "Err(e) => panic!(\"                                      \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/executor/mod.rs", "line": 291, "evidence": "panic!(", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_runtime/src/executor/mod.rs", "line": 130, "evidence": "static mut GLOBAL_DEFAULT_BLOCKING: MaybeUninit<BlockPoolSpawner> = MaybeUninit::uninit();", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 77, "evidence": "let mut shared = self.inner.shared.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 86, "evidence": "let shutdown_shared = self.inner.shutdown_shared.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 92, "evidence": ".unwrap()", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 172, "evidence": "let mut shared = self.inner.shared.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 208, "evidence": "let mut shared = self.inner.shared.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 405, "evidence": ".expect(\"                                              \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 436, "evidence": "thread_pool_builder.common.keep_alive_time.unwrap()", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 458, "evidence": "blocking_pool.inner.shared.lock().unwrap().shutdown = true;", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 465, "evidence": "*spawner_inner_clone.shutdown_shared.lock().unwrap() = true;", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 477, "evidence": "blocking_pool.inner.shared.lock().unwrap().shutdown = true;", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 495, "evidence": "assert_eq!(blocking_pool.inner.shared.lock().unwrap().worker_id, 4);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 503, "evidence": "blocking_pool.inner.shared.lock().unwrap().worker_id,", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 511, "evidence": ".unwrap()", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 514, "evidence": ".unwrap()", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 518, "evidence": ".unwrap(),", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 531, "evidence": "blocking_pool.inner.shared.lock().unwrap().worker_id,", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 539, "evidence": ".unwrap()", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 542, "evidence": ".unwrap()", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 546, "evidence": ".unwrap(),", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 96, "evidence": "let _ = handle.1.join();", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/executor/blocking_pool.rs", "line": 247, "evidence": "panic!(\"                                 \");", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/block_on.rs", "line": 24, "evidence": "let thread = unsafe { Arc::from_raw(ptr.cast::<Parker>()) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/block_on.rs", "line": 34, "evidence": "let thread = unsafe { Arc::from_raw(ptr.cast::<Parker>()) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/block_on.rs", "line": 39, "evidence": "let thread = unsafe { Arc::from_raw(ptr.cast::<Parker>()) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/block_on.rs", "line": 45, "evidence": "unsafe { mem::drop(Arc::from_raw(ptr.cast::<Parker>())) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/block_on.rs", "line": 67, "evidence": "unsafe { Waker::from_raw(RawWaker::new(data, &BLOCK_ON_RAW_WAKER_VIRTUAL_TABLE)) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/block_on.rs", "line": 103, "evidence": "let mut future = unsafe { Pin::new_unchecked(&mut task) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "resource_management", "pattern": "mem::forget", "file": "ylong_runtime/src/executor/block_on.rs", "line": 27, "evidence": "mem::forget(thread.clone());", "description": "使用 mem::forget 会跳过 Drop 导致资源泄漏，若错误使用可能破坏不变式或造成泄漏。", "suggestion": "避免无必要的 mem::forget；如需抑制 Drop，优先使用 ManuallyDrop 或设计更安全的所有权转移。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "resource_management", "pattern": "mem::forget", "file": "ylong_runtime/src/executor/block_on.rs", "line": 41, "evidence": "mem::forget(thread);", "description": "使用 mem::forget 会跳过 Drop 导致资源泄漏，若错误使用可能破坏不变式或造成泄漏。", "suggestion": "避免无必要的 mem::forget；如需抑制 Drop，优先使用 ManuallyDrop 或设计更安全的所有权转移。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/block_on.rs", "line": 78, "evidence": "let mut guard = self.mutex.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/block_on.rs", "line": 81, "evidence": "guard = self.condvar.wait(guard).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/block_on.rs", "line": 87, "evidence": "let mut guard = self.mutex.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/executor/block_on.rs", "line": 24, "evidence": "let thread = unsafe { Arc::from_raw(ptr.cast::<Parker>()) };", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/executor/block_on.rs", "line": 34, "evidence": "let thread = unsafe { Arc::from_raw(ptr.cast::<Parker>()) };", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/executor/block_on.rs", "line": 39, "evidence": "let thread = unsafe { Arc::from_raw(ptr.cast::<Parker>()) };", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/executor/block_on.rs", "line": 45, "evidence": "unsafe { mem::drop(Arc::from_raw(ptr.cast::<Parker>())) };", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/executor/block_on.rs", "line": 67, "evidence": "unsafe { Waker::from_raw(RawWaker::new(data, &BLOCK_ON_RAW_WAKER_VIRTUAL_TABLE)) }", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/worker.rs", "line": 85, "evidence": "Some(unsafe { &*(val.cast::<WorkerContext>()) })", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/executor/worker.rs", "line": 212, "evidence": "pub(crate) unsafe fn get_inner_ptr(&self) -> &Inner {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/executor/worker.rs", "line": 107, "evidence": "cur.set((&cur_context as *const WorkerContext).cast::<()>());", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/executor/worker.rs", "line": 111, "evidence": "handle.set((&cur_handle as *const WorkerHandle).cast::<()>());", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "concurrency", "pattern": "unsafe_impl_Send_or_Sync", "file": "ylong_runtime/src/executor/worker.rs", "line": 131, "evidence": "unsafe impl Send for Worker {}", "description": "手写 unsafe impl Send/Sync 可能破坏并发内存模型保证，带来数据竞争风险。", "suggestion": "避免手写 unsafe impl；必要时严格证明线程安全前置条件并最小化不安全区域。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "concurrency", "pattern": "unsafe_impl_Send_or_Sync", "file": "ylong_runtime/src/executor/worker.rs", "line": 132, "evidence": "unsafe impl Sync for Worker {}", "description": "手写 unsafe impl Send/Sync 可能破坏并发内存模型保证，带来数据竞争风险。", "suggestion": "避免手写 unsafe impl；必要时严格证明线程安全前置条件并最小化不安全区域。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/sleeper.rs", "line": 35, "evidence": "let idle_list = self.idle_list.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/sleeper.rs", "line": 40, "evidence": "let mut idle_list = self.idle_list.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/sleeper.rs", "line": 57, "evidence": "let mut idle_list = self.idle_list.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/sleeper.rs", "line": 63, "evidence": "let mut search_list = self.wake_by_search.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/executor/sleeper.rs", "line": 74, "evidence": "let mut idle_list = self.idle_list.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/waiter.rs", "line": 60, "evidence": "sem: SemaphoreInner::new(0).unwrap(),", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/waiter.rs", "line": 86, "evidence": "self.sem.acquire().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/sync/rwlock.rs", "line": 65, "evidence": "unsafe impl<T: ?Sized + Send> Send for RwLock<T> {}", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/sync/rwlock.rs", "line": 66, "evidence": "unsafe impl<T: ?Sized + Send + Sync> Sync for RwLock<T> {}", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/sync/rwlock.rs", "line": 245, "evidence": "unsafe { &mut *self.data.get() }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/sync/rwlock.rs", "line": 252, "evidence": "unsafe impl<T: ?Sized + Send> Send for RwLockReadGuard<'", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/sync/rwlock.rs", "line": 298, "evidence": "unsafe impl<T: ?Sized + Sync> Sync for RwLockWriteGuard<'", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/sync/rwlock.rs", "line": 331, "evidence": "unsafe { &mut *self.0.data.get() }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/rwlock.rs", "line": 82, "evidence": "read_sem: SemaphoreInner::new(0).unwrap(),", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/rwlock.rs", "line": 83, "evidence": "write_sem: SemaphoreInner::new(0).unwrap(),", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/rwlock.rs", "line": 84, "evidence": "write_mutex: SemaphoreInner::new(1).unwrap(),", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/rwlock.rs", "line": 395, "evidence": ".unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/rwlock.rs", "line": 411, "evidence": "let res = lock.try_read().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/rwlock.rs", "line": 426, "evidence": "let mut a = lock.try_write().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/rwlock.rs", "line": 479, "evidence": "block_on(handle).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/rwlock.rs", "line": 480, "evidence": "block_on(handle1).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/rwlock.rs", "line": 485, "evidence": "block_on(handle2).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/rwlock.rs", "line": 498, "evidence": "let mut aa = lock.try_write().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/rwlock.rs", "line": 511, "evidence": "let mut a = lock.try_write().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/watch.rs", "line": 112, "evidence": "let mut lock = self.channel.value.write().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/sync/watch.rs", "line": 624, "evidence": "let _ = block_on(handle1);", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.45000000000000007, "severity": "low"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/sync/semaphore_inner.rs", "line": 243, "evidence": "let (semaphore, waker_index, enqueue, wait_permit) = unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "get_unchecked", "file": "ylong_runtime/src/sync/semaphore_inner.rs", "line": 244, "evidence": "let me = self.get_unchecked_mut();", "description": "使用 get_unchecked/get_unchecked_mut 绕过边界检查，若索引无效将导致未定义行为。", "suggestion": "优先使用安全的索引方法（[] 或 get）；必须使用 get_unchecked 时，在 SAFETY 注释中证明索引有效性。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/atomic_waker.rs", "line": 56, "evidence": "let waker = self.waker.borrow_mut().take().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "concurrency", "pattern": "unsafe_impl_Send_or_Sync", "file": "ylong_runtime/src/sync/atomic_waker.rs", "line": 89, "evidence": "unsafe impl Send for AtomicWaker {}", "description": "手写 unsafe impl Send/Sync 可能破坏并发内存模型保证，带来数据竞争风险。", "suggestion": "避免手写 unsafe impl；必要时严格证明线程安全前置条件并最小化不安全区域。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "concurrency", "pattern": "unsafe_impl_Send_or_Sync", "file": "ylong_runtime/src/sync/atomic_waker.rs", "line": 90, "evidence": "unsafe impl Sync for AtomicWaker {}", "description": "手写 unsafe impl Send/Sync 可能破坏并发内存模型保证，带来数据竞争风险。", "suggestion": "避免手写 unsafe impl；必要时严格证明线程安全前置条件并最小化不安全区域。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/oneshot.rs", "line": 183, "evidence": "return Err(self.channel.take_value().unwrap());", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/oneshot.rs", "line": 479, "evidence": "tx.send(\"     \").unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/oneshot.rs", "line": 481, "evidence": "assert_eq!(rx.try_recv().unwrap(), \"     \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/oneshot.rs", "line": 529, "evidence": "let msg = rx.try_recv().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/sync/oneshot.rs", "line": 185, "evidence": "_ => unreachable!(),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/sync/oneshot.rs", "line": 334, "evidence": "_ => unreachable!(),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/sync/oneshot.rs", "line": 496, "evidence": "panic!(\"                \");", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.44999999999999996, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/sync/oneshot.rs", "line": 501, "evidence": "Err(_) => panic!(\"              \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.44999999999999996, "severity": "low"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/sync/wake_list.rs", "line": 214, "evidence": "unsafe { &mut *self.waker_set.inner.get() }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/sync/wake_list.rs", "line": 239, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/sync/wake_list.rs", "line": 181, "evidence": "let _ = self.wake_list.remove(key);", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "concurrency", "pattern": "unsafe_impl_Send_or_Sync", "file": "ylong_runtime/src/sync/wake_list.rs", "line": 50, "evidence": "unsafe impl Sync for WakerList {}", "description": "手写 unsafe impl Send/Sync 可能破坏并发内存模型保证，带来数据竞争风险。", "suggestion": "避免手写 unsafe impl；必要时严格证明线程安全前置条件并最小化不安全区域。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "concurrency", "pattern": "unsafe_impl_Send_or_Sync", "file": "ylong_runtime/src/sync/wake_list.rs", "line": 51, "evidence": "unsafe impl Send for WakerList {}", "description": "手写 unsafe impl Send/Sync 可能破坏并发内存模型保证，带来数据竞争风险。", "suggestion": "避免手写 unsafe impl；必要时严格证明线程安全前置条件并最小化不安全区域。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/sync/mutex.rs", "line": 42, "evidence": "unsafe impl<T: ?Sized + Send> Send for Mutex<T> {}", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/sync/mutex.rs", "line": 43, "evidence": "unsafe impl<T: ?Sized + Send> Sync for Mutex<T> {}", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/sync/mutex.rs", "line": 151, "evidence": "unsafe impl<T: ?Sized + Send + Sync> Sync for MutexGuard<'", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/sync/mutex.rs", "line": 181, "evidence": "unsafe { &mut *self.0.data.get() }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/mutex.rs", "line": 99, "evidence": "self.sem.acquire().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/mutex.rs", "line": 234, "evidence": "let mut lock = mutex.try_lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/net/async_source.rs", "line": 183, "evidence": "let ret = self.poll_read_io(cx, || unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/net/async_source.rs", "line": 17, "evidence": "use std::mem::MaybeUninit;", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/net/async_source.rs", "line": 184, "evidence": "let slice = &mut *(buf.unfilled_mut() as *mut [MaybeUninit<u8>] as *mut [u8]);", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/net/async_source.rs", "line": 193, "evidence": "buf.assume_init(r_len);", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/async_source.rs", "line": 98, "evidence": "let mut io = self.io.take().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/async_source.rs", "line": 186, "evidence": "self.io.as_ref().unwrap().read(slice)", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/async_source.rs", "line": 240, "evidence": "self.io.as_ref().unwrap()", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/net/async_source.rs", "line": 248, "evidence": "let _ = self.handle.io_deregister(&mut io);", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe_mem_ops", "file": "ylong_runtime/src/net/async_source.rs", "line": 186, "evidence": "self.io.as_ref().unwrap().read(slice)", "description": "使用不安全的内存操作（copy/copy_nonoverlapping/write/read），需确保指针有效性、对齐与重叠检查。", "suggestion": "优先使用安全的复制方法；必须使用时，在 SAFETY 注释中证明指针有效性、对齐与边界条件。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/net/driver.rs", "line": 243, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/net/driver.rs", "line": 298, "evidence": "ONCE.call_once(|| unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/net/driver.rs", "line": 83, "evidence": "use std::mem::MaybeUninit;", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/net/driver.rs", "line": 84, "evidence": "static mut DRIVER: MaybeUninit<IoDriver> = MaybeUninit::uninit();", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/net/driver.rs", "line": 85, "evidence": "static mut HANDLE: MaybeUninit<IoHandle> = MaybeUninit::uninit();", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/net/driver.rs", "line": 310, "evidence": "HANDLE = MaybeUninit::new(IoHandle::new(inner));", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/net/driver.rs", "line": 311, "evidence": "DRIVER = MaybeUninit::new(driver);", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/driver.rs", "line": 175, "evidence": ".unwrap()", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/driver.rs", "line": 245, "evidence": "self.resources.as_mut().unwrap().compact();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/net/driver.rs", "line": 198, "evidence": "Poll::new().unwrap_or_else(|e| panic!(\"                                       \"));", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/net/driver.rs", "line": 200, "evidence": ".unwrap_or_else(|e| panic!(\"                                              \"));", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_runtime/src/net/driver.rs", "line": 84, "evidence": "static mut DRIVER: MaybeUninit<IoDriver> = MaybeUninit::uninit();", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_runtime/src/net/driver.rs", "line": 85, "evidence": "static mut HANDLE: MaybeUninit<IoHandle> = MaybeUninit::uninit();", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/net/schedule_io.rs", "line": 100, "evidence": "unsafe impl Link for Waiter {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/net/schedule_io.rs", "line": 101, "evidence": "unsafe fn node(mut ptr: NonNull<Self>) -> NonNull<Node<Self>>", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/net/schedule_io.rs", "line": 361, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/net/schedule_io.rs", "line": 431, "evidence": "let (schedule_io, state, waiter) = unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/net/schedule_io.rs", "line": 436, "evidence": "let interest = unsafe { (*waiter.get()).interest };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/schedule_io.rs", "line": 343, "evidence": "let mut waiters = schedule_io.waiters.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "concurrency", "pattern": "unsafe_impl_Send_or_Sync", "file": "ylong_runtime/src/net/schedule_io.rs", "line": 445, "evidence": "unsafe impl Sync for Readiness<'", "description": "手写 unsafe impl Send/Sync 可能破坏并发内存模型保证，带来数据竞争风险。", "suggestion": "避免手写 unsafe impl；必要时严格证明线程安全前置条件并最小化不安全区域。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "get_unchecked", "file": "ylong_runtime/src/net/schedule_io.rs", "line": 432, "evidence": "let me = self.get_unchecked_mut();", "description": "使用 get_unchecked/get_unchecked_mut 绕过边界检查，若索引无效将导致未定义行为。", "suggestion": "优先使用安全的索引方法（[] 或 get）；必须使用 get_unchecked 时，在 SAFETY 注释中证明索引有效性。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/join_set.rs", "line": 56, "evidence": "unsafe impl<R: Send> Send for JoinSet<R> {}", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/join_set.rs", "line": 58, "evidence": "unsafe impl<R: Send> Sync for JoinSet<R> {}", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/join_set.rs", "line": 103, "evidence": "unsafe { (*(self.handle.get())).raw.eq(&(*(other.handle.get())).raw) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/join_set.rs", "line": 111, "evidence": "unsafe { (*self.handle.get()).raw.hash(state) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/join_set.rs", "line": 184, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/join_set.rs", "line": 245, "evidence": "unsafe { (*item.handle.get()).cancel() }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/join_set.rs", "line": 248, "evidence": "unsafe { (*item.handle.get()).cancel() }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/join_set.rs", "line": 312, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/join_set.rs", "line": 428, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/join_set.rs", "line": 434, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/task/join_set.rs", "line": 121, "evidence": "let mut list = entry.list.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/task/join_set.rs", "line": 179, "evidence": "let mut list = self.list.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/task/join_set.rs", "line": 217, "evidence": "let count = self.list.lock().unwrap().len;", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/task/join_set.rs", "line": 243, "evidence": "let list = self.list.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/task/join_set.rs", "line": 285, "evidence": "let mut list = self.list.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/task/join_set.rs", "line": 315, "evidence": "let mut list = self.list.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/task/join_set.rs", "line": 323, "evidence": "let mut list = self.list.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/task/join_set.rs", "line": 425, "evidence": "let mut list = self.list.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/task/join_set.rs", "line": 325, "evidence": "let _ = entry.in_done.replace(false);", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "resource_management", "pattern": "ManuallyDrop", "file": "ylong_runtime/src/task/join_set.rs", "line": 19, "evidence": "use std::mem::ManuallyDrop;", "description": "使用 ManuallyDrop 需要手动管理 Drop，若使用不当可能导致资源泄漏或双重释放。", "suggestion": "确保 ManuallyDrop 包装的对象在适当时候手动调用 drop；在 SAFETY 注释中说明生命周期管理策略。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "resource_management", "pattern": "ManuallyDrop", "file": "ylong_runtime/src/task/join_set.rs", "line": 83, "evidence": "handle: UnsafeCell<ManuallyDrop<JoinHandle<R>>>,", "description": "使用 ManuallyDrop 需要手动管理 Drop，若使用不当可能导致资源泄漏或双重释放。", "suggestion": "确保 ManuallyDrop 包装的对象在适当时候手动调用 drop；在 SAFETY 注释中说明生命周期管理策略。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "resource_management", "pattern": "ManuallyDrop", "file": "ylong_runtime/src/task/join_set.rs", "line": 175, "evidence": "handle: UnsafeCell::new(ManuallyDrop::new(handle)),", "description": "使用 ManuallyDrop 需要手动管理 Drop，若使用不当可能导致资源泄漏或双重释放。", "suggestion": "确保 ManuallyDrop 包装的对象在适当时候手动调用 drop；在 SAFETY 注释中说明生命周期管理策略。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "resource_management", "pattern": "ManuallyDrop", "file": "ylong_runtime/src/task/join_set.rs", "line": 319, "evidence": "drop(ManuallyDrop::take(&mut *entry.handle.get()));", "description": "使用 ManuallyDrop 需要手动管理 Drop，若使用不当可能导致资源泄漏或双重释放。", "suggestion": "确保 ManuallyDrop 包装的对象在适当时候手动调用 drop；在 SAFETY 注释中说明生命周期管理策略。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "resource_management", "pattern": "ManuallyDrop", "file": "ylong_runtime/src/task/join_set.rs", "line": 430, "evidence": "drop(ManuallyDrop::take(&mut *item.handle.get()));", "description": "使用 ManuallyDrop 需要手动管理 Drop，若使用不当可能导致资源泄漏或双重释放。", "suggestion": "确保 ManuallyDrop 包装的对象在适当时候手动调用 drop；在 SAFETY 注释中说明生命周期管理策略。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "resource_management", "pattern": "ManuallyDrop", "file": "ylong_runtime/src/task/join_set.rs", "line": 436, "evidence": "drop(ManuallyDrop::take(&mut *item.handle.get()));", "description": "使用 ManuallyDrop 需要手动管理 Drop，若使用不当可能导致资源泄漏或双重释放。", "suggestion": "确保 ManuallyDrop 包装的对象在适当时候手动调用 drop；在 SAFETY 注释中说明生命周期管理策略。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/join_handle.rs", "line": 52, "evidence": "unsafe impl<R: Send> Send for JoinHandle<R> {}", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/join_handle.rs", "line": 53, "evidence": "unsafe impl<R: Send> Sync for JoinHandle<R> {}", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/join_handle.rs", "line": 69, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/join_handle.rs", "line": 84, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/task/join_handle.rs", "line": 87, "evidence": ".set_waker(cur, (waker as *const Waker).cast::<()>())", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 35, "evidence": "pub(crate) run: unsafe fn(NonNull<Header>) -> bool,", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 37, "evidence": "pub(crate) schedule: unsafe fn(NonNull<Header>, bool),", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 39, "evidence": "pub(crate) get_result: unsafe fn(NonNull<Header>, *mut ()),", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 41, "evidence": "pub(crate) drop_join_handle: unsafe fn(NonNull<Header>),", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 43, "evidence": "pub(crate) drop_ref: unsafe fn(NonNull<Header>),", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 45, "evidence": "pub(crate) set_waker: unsafe fn(NonNull<Header>, cur_state: usize, waker: *const ()) -> bool,", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 48, "evidence": "pub(crate) release: unsafe fn(NonNull<Header>),", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 50, "evidence": "pub(crate) cancel: unsafe fn(NonNull<Header>),", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 63, "evidence": "unsafe fn default_run(_task: NonNull<Header>) -> bool {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 66, "evidence": "unsafe fn default_schedule(_task: NonNull<Header>, _fifo: bool) {}", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 67, "evidence": "unsafe fn default_get_result(_task: NonNull<Header>, _result: *mut ()) {}", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 68, "evidence": "unsafe fn default_drop_handle(_task: NonNull<Header>) {}", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 69, "evidence": "unsafe fn default_set_waker(", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 76, "evidence": "unsafe fn default_drop_ref(_task: NonNull<Header>) {}", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 77, "evidence": "unsafe fn default_release(_task: NonNull<Header>) {}", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 78, "evidence": "unsafe fn default_cancel(_task: NonNull<Header>) {}", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 103, "evidence": "unsafe impl Link for Header {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 104, "evidence": "unsafe fn node(mut ptr: NonNull<Self>) -> NonNull<Node<Self>>", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 120, "evidence": "unsafe { self.ptr.as_ref() }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 125, "evidence": "unsafe { (vir_table.run)(self.ptr) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 128, "evidence": "pub(crate) unsafe fn get_result(self, res: *mut ()) {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 133, "evidence": "pub(crate) unsafe fn cancel(self) {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 138, "evidence": "pub(crate) unsafe fn set_waker(self, cur_state: usize, waker: *const ()) -> bool {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 145, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 152, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 167, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 210, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 219, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 226, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 233, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 240, "evidence": "let data = mem::replace(unsafe { &mut *stage }, Stage::UsedData);", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 249, "evidence": "let future = match unsafe { &mut *stage } {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 254, "evidence": "let future = unsafe { Pin::new_unchecked(future) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 270, "evidence": "match unsafe { &*waker } {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 289, "evidence": "unsafe fn get_result<T, S>(ptr: NonNull<Header>, res: *mut ())", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 299, "evidence": "unsafe fn drop_ref<T, S>(ptr: NonNull<Header>)", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 308, "evidence": "unsafe fn set_waker<T, S>(ptr: NonNull<Header>, cur_state: usize, waker: *const ()) -> bool", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 318, "evidence": "unsafe fn drop_join_handle<T, S>(ptr: NonNull<Header>)", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 328, "evidence": "unsafe fn run<T, S>(ptr: NonNull<Header>) -> bool", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 338, "evidence": "unsafe fn schedule<T, S>(ptr: NonNull<Header>, flag: bool)", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 351, "evidence": "unsafe fn release<T, S>(ptr: NonNull<Header>)", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/raw.rs", "line": 360, "evidence": "unsafe fn cancel<T, S>(ptr: NonNull<Header>)", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/task/raw.rs", "line": 243, "evidence": "_ => panic!(\"                                                            \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/task/raw.rs", "line": 251, "evidence": "_ => panic!(\"                                                        \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/task/raw.rs", "line": 274, "evidence": "None => panic!(\"                           \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/task/raw.rs", "line": 295, "evidence": "let task_handle = TaskHandle::<T, S>::from_raw(ptr);", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/task/raw.rs", "line": 304, "evidence": "let task_handle = TaskHandle::<T, S>::from_raw(ptr);", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/task/raw.rs", "line": 314, "evidence": "let task_handle = TaskHandle::<T, S>::from_raw(ptr);", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/task/raw.rs", "line": 323, "evidence": "let task_handle = TaskHandle::<T, S>::from_raw(ptr);", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/task/raw.rs", "line": 333, "evidence": "let task_handle = TaskHandle::<T, S>::from_raw(ptr);", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/task/raw.rs", "line": 343, "evidence": "let task_handle = TaskHandle::<T, S>::from_raw(ptr);", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/task/raw.rs", "line": 356, "evidence": "let task_handle = TaskHandle::<T, S>::from_raw(ptr);", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/task/raw.rs", "line": 365, "evidence": "let task_handle = TaskHandle::<T, S>::from_raw(ptr);", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/task_handle.rs", "line": 39, "evidence": "pub(crate) unsafe fn from_raw(ptr: NonNull<Header>) -> Self {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/task_handle.rs", "line": 46, "evidence": "unsafe { self.task.as_ref().header() }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/task_handle.rs", "line": 50, "evidence": "unsafe { self.task.as_ref().inner() }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/task_handle.rs", "line": 79, "evidence": "unsafe { drop(Box::from_raw(self.task.as_ptr())) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/task_handle.rs", "line": 117, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/task_handle.rs", "line": 123, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/task_handle.rs", "line": 133, "evidence": "let is_same_waker = unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/task_handle.rs", "line": 305, "evidence": "let ffrt_task = unsafe { (*self.inner().task.get()).as_ref().unwrap() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/task_handle.rs", "line": 334, "evidence": "let ffrt_task = unsafe { (*self.inner().task.get()).as_ref().unwrap() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/task_handle.rs", "line": 348, "evidence": "let ffrt_task = unsafe { (*self.inner().task.get()).as_ref().unwrap() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/task/task_handle.rs", "line": 138, "evidence": ".expect(\"                                              \")", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/task/task_handle.rs", "line": 305, "evidence": "let ffrt_task = unsafe { (*self.inner().task.get()).as_ref().unwrap() };", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/task/task_handle.rs", "line": 334, "evidence": "let ffrt_task = unsafe { (*self.inner().task.get()).as_ref().unwrap() };", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/task/task_handle.rs", "line": 348, "evidence": "let ffrt_task = unsafe { (*self.inner().task.get()).as_ref().unwrap() };", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/task/task_handle.rs", "line": 69, "evidence": "Err(e) => panic!(\"  \", e.as_str()),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/task/task_handle.rs", "line": 181, "evidence": "StateAction::Failed(state) => panic!(\"                           \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/task/task_handle.rs", "line": 182, "evidence": "_ => unreachable!(),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/task/task_handle.rs", "line": 309, "evidence": "StateAction::Failed(state) => panic!(\"                        \", state),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/task/task_handle.rs", "line": 39, "evidence": "pub(crate) unsafe fn from_raw(ptr: NonNull<Header>) -> Self {", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/task/task_handle.rs", "line": 79, "evidence": "unsafe { drop(Box::from_raw(self.task.as_ptr())) };", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/mod.rs", "line": 91, "evidence": "pub(crate) unsafe fn from_raw(ptr: NonNull<Header>) -> Task {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/task/mod.rs", "line": 134, "evidence": "panic!(\"                                                       \");", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "concurrency", "pattern": "unsafe_impl_Send_or_Sync", "file": "ylong_runtime/src/task/mod.rs", "line": 70, "evidence": "unsafe impl Send for Task {}", "description": "手写 unsafe impl Send/Sync 可能破坏并发内存模型保证，带来数据竞争风险。", "suggestion": "避免手写 unsafe impl；必要时严格证明线程安全前置条件并最小化不安全区域。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "concurrency", "pattern": "unsafe_impl_Send_or_Sync", "file": "ylong_runtime/src/task/mod.rs", "line": 71, "evidence": "unsafe impl Sync for Task {}", "description": "手写 unsafe impl Send/Sync 可能破坏并发内存模型保证，带来数据竞争风险。", "suggestion": "避免手写 unsafe impl；必要时严格证明线程安全前置条件并最小化不安全区域。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/task/mod.rs", "line": 91, "evidence": "pub(crate) unsafe fn from_raw(ptr: NonNull<Header>) -> Task {", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/task/state.rs", "line": 425, "evidence": "let ret = task_state.turning_to_finish().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/task/state.rs", "line": 399, "evidence": "_ => panic!(),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.44999999999999996, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/task/state.rs", "line": 404, "evidence": "_ => panic!(),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.44999999999999996, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/task/state.rs", "line": 452, "evidence": "_ => panic!(),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.44999999999999996, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/task/state.rs", "line": 458, "evidence": "_ => panic!(),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.44999999999999996, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/task/state.rs", "line": 470, "evidence": "_ => panic!(),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.44999999999999996, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/task/state.rs", "line": 480, "evidence": "_ => panic!(),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.44999999999999996, "severity": "low"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/waker.rs", "line": 23, "evidence": "unsafe fn get_header_by_raw_ptr(ptr: *const ()) -> NonNull<Header> {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/waker.rs", "line": 33, "evidence": "unsafe fn clone<T>(ptr: *const ()) -> RawWaker", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/waker.rs", "line": 42, "evidence": "unsafe fn wake(ptr: *const ()) {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/waker.rs", "line": 48, "evidence": "unsafe fn wake_by_ref(ptr: *const ()) {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/waker.rs", "line": 54, "evidence": "unsafe fn drop(ptr: *const ()) {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/task/waker.rs", "line": 79, "evidence": "let waker = unsafe { ManuallyDrop::new(Waker::from_raw(raw_waker::<T>(header))) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/task/waker.rs", "line": 24, "evidence": "let header = ptr as *mut Header;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/task/waker.rs", "line": 60, "evidence": "fn raw_waker<T>(header: *const Header) -> RawWaker", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/task/waker.rs", "line": 29, "evidence": "panic!(\"                   \");", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/task/waker.rs", "line": 79, "evidence": "let waker = unsafe { ManuallyDrop::new(Waker::from_raw(raw_waker::<T>(header))) };", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "resource_management", "pattern": "ManuallyDrop", "file": "ylong_runtime/src/task/waker.rs", "line": 16, "evidence": "use std::mem::ManuallyDrop;", "description": "使用 ManuallyDrop 需要手动管理 Drop，若使用不当可能导致资源泄漏或双重释放。", "suggestion": "确保 ManuallyDrop 包装的对象在适当时候手动调用 drop；在 SAFETY 注释中说明生命周期管理策略。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "resource_management", "pattern": "ManuallyDrop", "file": "ylong_runtime/src/task/waker.rs", "line": 79, "evidence": "let waker = unsafe { ManuallyDrop::new(Waker::from_raw(raw_waker::<T>(header))) };", "description": "使用 ManuallyDrop 需要手动管理 Drop，若使用不当可能导致资源泄漏或双重释放。", "suggestion": "确保 ManuallyDrop 包装的对象在适当时候手动调用 drop；在 SAFETY 注释中说明生命周期管理策略。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/task/builder.rs", "line": 116, "evidence": "assert_eq!(builder.name(name.clone()).name.unwrap(), name);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/task/builder.rs", "line": 130, "evidence": "assert_eq!(builder.qos(pri).qos.unwrap(), pri);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/task/builder.rs", "line": 134, "evidence": "assert_eq!(builder.qos(pri).qos.unwrap(), pri);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/task/builder.rs", "line": 138, "evidence": "assert_eq!(builder.qos(pri).qos.unwrap(), pri);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/task/builder.rs", "line": 142, "evidence": "assert_eq!(builder.qos(pri).qos.unwrap(), pri);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/task/builder.rs", "line": 146, "evidence": "assert_eq!(builder.qos(pri).qos.unwrap(), pri);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/iter/core.rs", "line": 95, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/iter/core.rs", "line": 124, "evidence": "unsafe fn spawn_task<P, C>(", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/iter/core.rs", "line": 172, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/iter/core.rs", "line": 187, "evidence": "unsafe fn spawn_task_ffrt<P, C>(", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/ffrt/ffrt_task.rs", "line": 24, "evidence": "let task_ctx = unsafe { ffrt_get_current_task() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/ffrt/ffrt_task.rs", "line": 29, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/ffrt/ffrt_task.rs", "line": 17, "evidence": "type RawTaskCtx = *mut c_void;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/ffrt/spawner.rs", "line": 27, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/ffrt/spawner.rs", "line": 36, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/ffrt/spawner.rs", "line": 54, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/ffrt/spawner.rs", "line": 26, "evidence": "extern \" \" fn exec_future(data: *mut c_void) -> FfrtRet {", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/ffrt/spawner.rs", "line": 28, "evidence": "match (*(data as *mut Task)).0.run() {", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/ffrt/spawner.rs", "line": 35, "evidence": "extern \" \" fn exec_drop(data: *mut c_void) {", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/ffrt/spawner.rs", "line": 37, "evidence": "drop(Box::from_raw(data as *mut Task));", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/ffrt/spawner.rs", "line": 53, "evidence": "let data = Box::into_raw(t) as *mut c_void;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/ffrt/spawner.rs", "line": 61, "evidence": "&attr as *const FfrtTaskAttr,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/ffrt/spawner.rs", "line": 37, "evidence": "drop(Box::from_raw(data as *mut Task));", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/ffrt/ffrt_timer.rs", "line": 25, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/ffrt/ffrt_timer.rs", "line": 32, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/ffrt/ffrt_timer.rs", "line": 40, "evidence": "unsafe { ylong_ffrt::ffrt_timer_query(self.0) == 1 }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/ffrt/ffrt_timer.rs", "line": 44, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/ffrt/ffrt_timer.rs", "line": 18, "evidence": "type FfrtTimerHandle = *mut c_void;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/ffrt/ffrt_timer.rs", "line": 23, "evidence": "pub(crate) fn timer_register(waker: *mut Waker, dur: u64) -> Self {", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/ffrt/ffrt_timer.rs", "line": 24, "evidence": "extern \" \" fn timer_wake_hook(data: *mut c_void) {", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/ffrt/ffrt_timer.rs", "line": 26, "evidence": "let waker = data as *mut Waker;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/ffrt/ffrt_timer.rs", "line": 31, "evidence": "let data = waker as *mut c_void;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/signal/mod.rs", "line": 110, "evidence": ".unwrap_or_else(|e| panic!(\"                                          \"));", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/builder/multi_thread_builder.rs", "line": 70, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/builder/multi_thread_builder.rs", "line": 64, "evidence": "let mut builder = GLOBAL_BUILDER.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/builder/multi_thread_builder.rs", "line": 321, "evidence": "let num = builder.thread_num_by_qos.get(&UserInteractive).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/builder/multi_thread_builder.rs", "line": 325, "evidence": "let num = builder.thread_num_by_qos.get(&UserInteractive).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/builder/multi_thread_builder.rs", "line": 329, "evidence": "let num = builder.thread_num_by_qos.get(&Default).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/builder/multi_thread_builder.rs", "line": 352, "evidence": ".unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/builder/multi_thread_builder.rs", "line": 361, "evidence": ".unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/builder/multi_thread_builder.rs", "line": 366, "evidence": "let num = builder.common.stack_size_by_qos.get(&Default).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/builder/multi_thread_builder.rs", "line": 375, "evidence": ".unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/builder/multi_thread_builder.rs", "line": 286, "evidence": "AsyncHandle::CurrentThread(_) => unreachable!(),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.44999999999999996, "severity": "low"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/process/try_join3.rs", "line": 45, "evidence": "let mut fut1 = unsafe { Pin::new_unchecked(&mut fut1) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/process/try_join3.rs", "line": 48, "evidence": "let mut fut2 = unsafe { Pin::new_unchecked(&mut fut2) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/process/try_join3.rs", "line": 51, "evidence": "let mut fut3 = unsafe { Pin::new_unchecked(&mut fut3) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/process/try_join3.rs", "line": 83, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/process/try_join3.rs", "line": 59, "evidence": "fut1.take_output().unwrap_or_else(|_| unreachable!()),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/process/try_join3.rs", "line": 60, "evidence": "fut2.take_output().unwrap_or_else(|_| unreachable!()),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/process/try_join3.rs", "line": 61, "evidence": "fut3.take_output().unwrap_or_else(|_| unreachable!()),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/process/try_join3.rs", "line": 88, "evidence": "unreachable!()", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "get_unchecked", "file": "ylong_runtime/src/process/try_join3.rs", "line": 84, "evidence": "let inner = self.get_unchecked_mut();", "description": "使用 get_unchecked/get_unchecked_mut 绕过边界检查，若索引无效将导致未定义行为。", "suggestion": "优先使用安全的索引方法（[] 或 get）；必须使用 get_unchecked 时，在 SAFETY 注释中证明索引有效性。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/child.rs", "line": 454, "evidence": "let std_child = command.spawn().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/child.rs", "line": 457, "evidence": "let mut child = Child::new(std_child, false, None, None, None).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/child.rs", "line": 463, "evidence": "let status = child.wait().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/child.rs", "line": 466, "evidence": "crate::block_on(handle).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/child.rs", "line": 478, "evidence": "let std_child = command.spawn().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/child.rs", "line": 480, "evidence": "let mut child = Child::new(std_child, false, None, None, None).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/child.rs", "line": 483, "evidence": "if child.try_wait().unwrap().is_some() {", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/child.rs", "line": 487, "evidence": "assert!(child.try_wait().unwrap().is_some());", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/child.rs", "line": 489, "evidence": "crate::block_on(handle).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/child.rs", "line": 507, "evidence": "let mut child = command.spawn().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/child.rs", "line": 509, "evidence": "let child_stdin = child.take_stdin().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/child.rs", "line": 511, "evidence": "let child_stdout = child.take_stdout().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/child.rs", "line": 513, "evidence": "let child_stderr = child.take_stderr().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/child.rs", "line": 518, "evidence": "let mut child = command.spawn().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/child.rs", "line": 520, "evidence": "let child_stdin = child.take_stdin().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/child.rs", "line": 525, "evidence": "let child_stdout = child.take_stdout().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/child.rs", "line": 530, "evidence": "let child_stderr = child.take_stderr().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/child.rs", "line": 536, "evidence": "crate::block_on(handle).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/child.rs", "line": 552, "evidence": "let mut child = command.spawn().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/child.rs", "line": 554, "evidence": "let stdin = child.stdin.take().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/child.rs", "line": 556, "evidence": "let stdout = child.stdout.take().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/child.rs", "line": 558, "evidence": "let stderr = child.stderr.take().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/child.rs", "line": 561, "evidence": "crate::block_on(handle).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/process/child.rs", "line": 317, "evidence": "let _ = child.kill();", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/process/command.rs", "line": 568, "evidence": "pub unsafe fn pre_exec<F>(&mut self, f: F) -> &mut Command", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 623, "evidence": "let output = command.output().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 629, "evidence": "crate::block_on(handle).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 643, "evidence": "let status = command.status().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 646, "evidence": "crate::block_on(handle).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 664, "evidence": ".expect(\"                             \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 666, "evidence": "let mut stdin = child.take_stdin().expect(\"                    \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 672, "evidence": ".unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 673, "evidence": "stdin.flush().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 674, "evidence": "stdin.shutdown().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 677, "evidence": "let mut stdout = child.take_stdout().expect(\"                     \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 680, "evidence": "stdout.read_to_end(&mut buf).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 682, "evidence": "assert!(String::from_utf8(buf).unwrap().contains(str));", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 685, "evidence": "let mut stderr = child.take_stderr().expect(\"                     \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 688, "evidence": "stderr.read_to_end(&mut buf).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 692, "evidence": "let status = child.wait().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 695, "evidence": "stdin_handle.await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 696, "evidence": "stdout_handle.await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 697, "evidence": "stderr_handle.await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 699, "evidence": "crate::block_on(handle).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 713, "evidence": "let mut child = command.spawn().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 717, "evidence": "crate::block_on(handle).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 733, "evidence": "drop(child.unwrap());", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 739, "evidence": "drop(child.unwrap());", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 741, "evidence": "crate::block_on(handle).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 757, "evidence": "let mut child = command.spawn().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 760, "evidence": "let status = child.wait().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/command.rs", "line": 763, "evidence": "crate::block_on(handle).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/time/timer.rs", "line": 214, "evidence": "block_on(handle).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/time/timer.rs", "line": 240, "evidence": "block_on(handle).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/time/timer.rs", "line": 255, "evidence": "let mut a = xc.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/time/timer.rs", "line": 264, "evidence": "let x = x.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/time/timer.rs", "line": 262, "evidence": "let _ = block_on(handle);", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.45000000000000007, "severity": "low"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/time/wheel.rs", "line": 125, "evidence": "unsafe impl Link for Clock {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/time/wheel.rs", "line": 126, "evidence": "unsafe fn node(mut ptr: NonNull<Self>) -> NonNull<Node<Self>>", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/time/wheel.rs", "line": 221, "evidence": "let expiration = unsafe { clock_entry.as_ref().expiration() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/time/wheel.rs", "line": 232, "evidence": "unsafe { clock_entry.as_mut().set_level(level) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/time/wheel.rs", "line": 240, "evidence": "let level = unsafe { clock_entry.as_ref().level() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/time/wheel.rs", "line": 259, "evidence": "let expected_expiration = unsafe { item.as_ref().expiration() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/time/wheel.rs", "line": 263, "evidence": "unsafe { item.as_mut().set_level(level) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/time/wheel.rs", "line": 320, "evidence": "unsafe { MaybeUninit::uninit().assume_init() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/time/wheel.rs", "line": 326, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/time/wheel.rs", "line": 342, "evidence": "let duration = unsafe { clock_entry.as_ref().expiration() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/time/wheel.rs", "line": 346, "evidence": "unsafe { clock_entry.as_mut().set_duration(duration) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/time/wheel.rs", "line": 357, "evidence": "let duration = unsafe { clock_entry.as_ref().duration() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/time/wheel.rs", "line": 364, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "mem::transmute", "file": "ylong_runtime/src/time/wheel.rs", "line": 327, "evidence": "let slots = mem::transmute::<_, [LinkedList<Clock>; SLOTS_NUM]>(slots);", "description": "使用 mem::transmute 进行类型转换，若未严格保证布局/对齐/生命周期，将导致未定义行为。", "suggestion": "避免使用 transmute，优先采用安全转换或 bytemuck 等受审计抽象；必须使用时严格注明不变式。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/time/wheel.rs", "line": 16, "evidence": "use std::mem::MaybeUninit;", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/time/wheel.rs", "line": 319, "evidence": "let mut slots: [MaybeUninit<LinkedList<Clock>>; SLOTS_NUM] =", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7999999999999999, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/time/wheel.rs", "line": 320, "evidence": "unsafe { MaybeUninit::uninit().assume_init() };", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7999999999999999, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/time/wheel.rs", "line": 323, "evidence": "*slot = MaybeUninit::new(Default::default());", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7999999999999999, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/time/wheel.rs", "line": 467, "evidence": "let sender = UdpSocket::bind(ADDR).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/time/wheel.rs", "line": 470, "evidence": "let receiver_addr = rx.await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/time/wheel.rs", "line": 471, "evidence": "sender.send_to(buf.as_slice(), receiver_addr).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/time/wheel.rs", "line": 475, "evidence": "let receiver = UdpSocket::bind(ADDR).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/time/wheel.rs", "line": 476, "evidence": "let addr = receiver.local_addr().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/time/wheel.rs", "line": 477, "evidence": "tx.send(addr).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/time/wheel.rs", "line": 494, "evidence": "let lock = TimeDriver::get_ref().wheel.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/time/wheel.rs", "line": 491, "evidence": "let _ = crate::block_on(t);", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.45000000000000007, "severity": "low"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_runtime/src/time/wheel.rs", "line": 320, "evidence": "unsafe { MaybeUninit::uninit().assume_init() };", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/time/driver.rs", "line": 72, "evidence": "let clock_handle = unsafe { clock_entry.as_mut() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/time/driver.rs", "line": 54, "evidence": "let mut lock = self.wheel.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/time/driver.rs", "line": 59, "evidence": "let mut lock = self.wheel.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/time/driver.rs", "line": 82, "evidence": ".expect(\"                                  \")", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/time/driver.rs", "line": 93, "evidence": ".expect(\"                                                  \")", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/time/driver.rs", "line": 102, "evidence": "let mut lock = self.wheel.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/time/driver.rs", "line": 124, "evidence": ".expect(\"                                  \")", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/time/sleep.rs", "line": 114, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/time/sleep.rs", "line": 126, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/time/sleep.rs", "line": 231, "evidence": "let this = unsafe { self.get_unchecked_mut() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/time/sleep.rs", "line": 87, "evidence": "waker: Option<*mut Waker>,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/time/sleep.rs", "line": 239, "evidence": ".unwrap()", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/time/sleep.rs", "line": 319, "evidence": "block_on(handle_one).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/time/sleep.rs", "line": 320, "evidence": "block_on(handle_two).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/time/sleep.rs", "line": 321, "evidence": "block_on(handle_three).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/time/sleep.rs", "line": 335, "evidence": "let past = Instant::now().checked_sub(Duration::from_secs(1)).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "concurrency", "pattern": "unsafe_impl_Send_or_Sync", "file": "ylong_runtime/src/time/sleep.rs", "line": 92, "evidence": "unsafe impl Send for Sleep {}", "description": "手写 unsafe impl Send/Sync 可能破坏并发内存模型保证，带来数据竞争风险。", "suggestion": "避免手写 unsafe impl；必要时严格证明线程安全前置条件并最小化不安全区域。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "concurrency", "pattern": "unsafe_impl_Send_or_Sync", "file": "ylong_runtime/src/time/sleep.rs", "line": 93, "evidence": "unsafe impl Sync for Sleep {}", "description": "手写 unsafe impl Send/Sync 可能破坏并发内存模型保证，带来数据竞争风险。", "suggestion": "避免手写 unsafe impl；必要时严格证明线程安全前置条件并最小化不安全区域。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "get_unchecked", "file": "ylong_runtime/src/time/sleep.rs", "line": 231, "evidence": "let this = unsafe { self.get_unchecked_mut() };", "description": "使用 get_unchecked/get_unchecked_mut 绕过边界检查，若索引无效将导致未定义行为。", "suggestion": "优先使用安全的索引方法（[] 或 get）；必须使用 get_unchecked 时，在 SAFETY 注释中证明索引有效性。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/time/sleep.rs", "line": 115, "evidence": "drop(Box::from_raw(waker));", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/time/sleep.rs", "line": 127, "evidence": "drop(Box::from_raw(waker));", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/read_buf.rs", "line": 41, "evidence": "buf: unsafe { &mut *(buf as *mut [u8] as *mut [MaybeUninit<u8>]) },", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/read_buf.rs", "line": 100, "evidence": "unsafe { &*(&self.buf[..self.filled] as *const [MaybeUninit<u8>] as *const [u8]) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/read_buf.rs", "line": 106, "evidence": "unsafe { &mut *(&mut self.buf[..self.filled] as *mut [MaybeUninit<u8>] as *mut [u8]) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/read_buf.rs", "line": 118, "evidence": "unsafe { &*(&self.buf[..self.initialized] as *const [MaybeUninit<u8>] as *const [u8]) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/read_buf.rs", "line": 124, "evidence": "unsafe { &mut *(&mut self.buf[..self.initialized] as *mut [MaybeUninit<u8>] as *mut [u8]) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/read_buf.rs", "line": 155, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/read_buf.rs", "line": 162, "evidence": "unsafe { &mut *(&mut self.buf[self.filled..end] as *mut [MaybeUninit<u8>] as *mut [u8]) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/read_buf.rs", "line": 240, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/io/read_buf.rs", "line": 14, "evidence": "use std::mem::MaybeUninit;", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/io/read_buf.rs", "line": 31, "evidence": "'a mut [MaybeUninit<u8>],", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/io/read_buf.rs", "line": 41, "evidence": "buf: unsafe { &mut *(buf as *mut [u8] as *mut [MaybeUninit<u8>]) },", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/io/read_buf.rs", "line": 63, "evidence": "pub fn uninit(buf: &mut [MaybeUninit<u8>]) -> ReadBuf<'", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/io/read_buf.rs", "line": 100, "evidence": "unsafe { &*(&self.buf[..self.filled] as *const [MaybeUninit<u8>] as *const [u8]) }", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/io/read_buf.rs", "line": 106, "evidence": "unsafe { &mut *(&mut self.buf[..self.filled] as *mut [MaybeUninit<u8>] as *mut [u8]) }", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/io/read_buf.rs", "line": 111, "evidence": "pub fn unfilled_mut(&mut self) -> &mut [MaybeUninit<u8>] {", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/io/read_buf.rs", "line": 118, "evidence": "unsafe { &*(&self.buf[..self.initialized] as *const [MaybeUninit<u8>] as *const [u8]) }", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/io/read_buf.rs", "line": 124, "evidence": "unsafe { &mut *(&mut self.buf[..self.initialized] as *mut [MaybeUninit<u8>] as *mut [u8]) }", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/io/read_buf.rs", "line": 132, "evidence": "pub fn inner_mut(&mut self) -> &mut [MaybeUninit<u8>] {", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/io/read_buf.rs", "line": 162, "evidence": "unsafe { &mut *(&mut self.buf[self.filled..end] as *mut [MaybeUninit<u8>] as *mut [u8]) }", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/io/read_buf.rs", "line": 216, "evidence": "pub fn assume_init(&mut self, n: usize) {", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/io/read_buf.rs", "line": 256, "evidence": "use std::mem::MaybeUninit;", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/io/read_buf.rs", "line": 208, "evidence": ".expect(\"                        \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_runtime/src/io/read_buf.rs", "line": 63, "evidence": "pub fn uninit(buf: &mut [MaybeUninit<u8>]) -> ReadBuf<'", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_runtime/src/io/read_buf.rs", "line": 94, "evidence": "ReadBuf::uninit(&mut self.unfilled_mut()[..rsize])", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/io/write_task.rs", "line": 26, "evidence": "None => panic!(\"                          \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/stderr.rs", "line": 82, "evidence": "unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/stdout.rs", "line": 82, "evidence": "unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/read_task.rs", "line": 109, "evidence": "let mut read_buf = ReadBuf::uninit(unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/read_task.rs", "line": 124, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/io/read_task.rs", "line": 15, "evidence": "use std::mem::MaybeUninit;", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/io/read_task.rs", "line": 110, "evidence": "from_raw_parts_mut(buf.as_mut_ptr().cast::<MaybeUninit<u8>>(), buf.capacity())", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7999999999999999, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/io/read_task.rs", "line": 112, "evidence": "read_buf.assume_init(len);", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7999999999999999, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/io/read_task.rs", "line": 500, "evidence": "let mut f = File::create(file_path).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/io/read_task.rs", "line": 502, "evidence": "let n = f.write(&buf).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/io/read_task.rs", "line": 505, "evidence": "let f = File::open(file_path).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/io/read_task.rs", "line": 515, "evidence": "crate::block_on(handle).expect(\"                  \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/io/read_task.rs", "line": 32, "evidence": "None => panic!(\"                         \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_runtime/src/io/read_task.rs", "line": 109, "evidence": "let mut read_buf = ReadBuf::uninit(unsafe {", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/io/stdio.rs", "line": 164, "evidence": "let buf = buf_cell.take().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/io/stdio.rs", "line": 165, "evidence": "let mut inner = self.std.take().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/io/seek_task.rs", "line": 46, "evidence": "let pos = self.pos.take().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/stdin.rs", "line": 127, "evidence": "unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/io/stdin.rs", "line": 55, "evidence": "let mut buf_inner = buf_op.take().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/io/stdin.rs", "line": 65, "evidence": "let mut std = self.std.take().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 750, "evidence": "File::create(file_path).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 783, "evidence": "File::create(file_path).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 806, "evidence": "File::create(file_path).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 810, "evidence": "let s = read_to_string(file_path).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 832, "evidence": "File::create(file_path).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 836, "evidence": "let buf = read(file_path).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 837, "evidence": "let s = String::from_utf8(buf).expect(\"                   \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 874, "evidence": "File::create(file_path).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 899, "evidence": "File::create(file_path).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 924, "evidence": "File::create(file_path).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 948, "evidence": "File::create(file_path).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 971, "evidence": "File::create(file_path).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 993, "evidence": "File::create(file_path).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 995, "evidence": "let mut perms = metadata(file_path).await.unwrap().permissions();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 1000, "evidence": "let mut perms = metadata(file_path).await.unwrap().permissions();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 1022, "evidence": "File::create(\"                   \").await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 1023, "evidence": "File::create(\"                   \").await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 1024, "evidence": "let mut dir = read_dir(\"         \").await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 1025, "evidence": "let entry = dir.next().await.unwrap().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 1026, "evidence": "assert!(!entry.file_type().await.unwrap().is_dir());", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 1027, "evidence": "assert!(entry.file_type().await.unwrap().is_file());", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 1028, "evidence": "assert!(entry.file_name().into_string().unwrap().contains(\"    \"));", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 1029, "evidence": "let entry = dir.next().await.unwrap().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 1030, "evidence": "assert!(!entry.metadata().await.unwrap().is_dir());", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 1031, "evidence": "assert!(entry.metadata().await.unwrap().is_file());", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 1032, "evidence": "assert!(!entry.metadata().await.unwrap().permissions().readonly());", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 1033, "evidence": "assert!(entry.file_name().into_string().unwrap().contains(\"    \"));", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 1034, "evidence": "assert!(dir.next().await.unwrap().is_none());", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 1037, "evidence": "crate::block_on(handle).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/fs/async_dir.rs", "line": 1021, "evidence": "let _ = create_dir(\"         \").await;", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.45000000000000007, "severity": "low"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/fs/async_file.rs", "line": 461, "evidence": "unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/fs/async_file.rs", "line": 466, "evidence": "unsafe fn from_raw_handle(handle: RawHandle) -> Self {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/fs/async_file.rs", "line": 972, "evidence": "let file2 = unsafe { File::from_raw_fd(fd) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 284, "evidence": "FileState::Idle(ref mut buf) => buf.take().unwrap(),", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 391, "evidence": "Arc::try_unwrap(self.file).expect(\"                               \")", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 538, "evidence": "let mut r_buf = file_buf.take().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 694, "evidence": "let file = File::create(file_path).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 716, "evidence": "let file = File::create(file_path).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 735, "evidence": "let mut file = File::create(file_path).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 737, "evidence": "let res = file.write(&buf).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 739, "evidence": "file.sync_all().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 741, "evidence": "crate::block_on(handle).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 744, "evidence": "let mut file = File::open(file_path).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 745, "evidence": "let ret = file.seek(SeekFrom::Current(3)).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 749, "evidence": "let ret = file.read(&mut buf).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 753, "evidence": "let ret = file.seek(SeekFrom::Current(1)).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 757, "evidence": "let ret = file.read(&mut buf).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 761, "evidence": "let ret = file.seek(SeekFrom::Current(2)).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 765, "evidence": "let ret = file.read(&mut buf).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 769, "evidence": "let ret = file.seek(SeekFrom::Start(0)).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 772, "evidence": "let ret = file.read(&mut buf).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 776, "evidence": "let ret = file.seek(SeekFrom::End(-1)).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 779, "evidence": "let ret = file.read(&mut buf).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 784, "evidence": "crate::block_on(handle2).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 785, "evidence": "std::fs::remove_file(file_path).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 798, "evidence": "let file = File::create(file_path).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 799, "evidence": "let mut perms = file.metadata().await.unwrap().permissions();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 803, "evidence": "let mut perms = file.metadata().await.unwrap().permissions();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 809, "evidence": "crate::block_on(handle).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 810, "evidence": "std::fs::remove_file(file_path).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 822, "evidence": "let mut file = File::create(file_path).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 835, "evidence": "crate::block_on(handle).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 836, "evidence": "std::fs::remove_file(file_path).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 849, "evidence": "let mut file = File::create(file_path).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 861, "evidence": "crate::block_on(handle).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 862, "evidence": "std::fs::remove_file(file_path).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 876, "evidence": "crate::block_on(handle).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 897, "evidence": ".unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 903, "evidence": "let ret = std.seek(SeekFrom::Start(0)).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 910, "evidence": "crate::block_on(handle).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 911, "evidence": "std::fs::remove_file(file_path).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 928, "evidence": "let mut file = File::create(file_path).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 942, "evidence": "crate::block_on(handle).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 943, "evidence": "std::fs::remove_file(file_path).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 963, "evidence": "let file = File::create(file_path).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 977, "evidence": "crate::block_on(handle).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/fs/async_file.rs", "line": 978, "evidence": "std::fs::remove_file(file_path).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/fs/async_file.rs", "line": 285, "evidence": "_ => unreachable!(),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/core_affinity/windows.rs", "line": 44, "evidence": "let res = unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/core_affinity/linux.rs", "line": 32, "evidence": "let res: i32 = unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/core_affinity/linux.rs", "line": 45, "evidence": "unsafe { zeroed::<cpu_set_t>() }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/num_cpus/unix.rs", "line": 21, "evidence": "unsafe { sysconf(_SC_NPROCESSORS_ONLN) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/util/num_cpus/windows.rs", "line": 38, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/util/num_cpus/windows.rs", "line": 24, "evidence": "lp_minimum_application_address: *mut u8,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/util/num_cpus/windows.rs", "line": 25, "evidence": "lp_maximum_application_address: *mut u8,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/util/num_cpus/windows.rs", "line": 26, "evidence": "dw_active_processor_mask: *mut u8,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/util/num_cpus/windows.rs", "line": 35, "evidence": "fn GetSystemInfo(lpSystemInfo: *mut SYSTEM_INFO);", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_runtime/src/util/num_cpus/windows.rs", "line": 39, "evidence": "let mut sysinfo: SYSTEM_INFO = std::mem::zeroed();", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/sync/mpsc/bounded/array.rs", "line": 49, "evidence": "unsafe impl<T: Send> Send for Array<T> {}", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/sync/mpsc/bounded/array.rs", "line": 50, "evidence": "unsafe impl<T: Send> Sync for Array<T> {}", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/sync/mpsc/bounded/array.rs", "line": 152, "evidence": "let value = unsafe { node.value.as_ptr().read().assume_init() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/sync/mpsc/bounded/array.rs", "line": 16, "evidence": "use std::mem::MaybeUninit;", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/sync/mpsc/bounded/array.rs", "line": 36, "evidence": "value: RefCell<MaybeUninit<T>>,", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/sync/mpsc/bounded/array.rs", "line": 64, "evidence": "value: RefCell::new(MaybeUninit::uninit()),", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/sync/mpsc/bounded/array.rs", "line": 152, "evidence": "let value = unsafe { node.value.as_ptr().read().assume_init() };", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/mpsc/bounded/array.rs", "line": 85, "evidence": "let node = self.data.get(index).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/mpsc/bounded/array.rs", "line": 108, "evidence": "let node = self.data.get(index).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/mpsc/bounded/array.rs", "line": 147, "evidence": "let node = self.data.get(index).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/sync/mpsc/bounded/array.rs", "line": 139, "evidence": "SendPosition::Full => unreachable!(),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe_mem_ops", "file": "ylong_runtime/src/sync/mpsc/bounded/array.rs", "line": 152, "evidence": "let value = unsafe { node.value.as_ptr().read().assume_init() };", "description": "使用不安全的内存操作（copy/copy_nonoverlapping/write/read），需确保指针有效性、对齐与重叠检查。", "suggestion": "优先使用安全的复制方法；必须使用时，在 SAFETY 注释中证明指针有效性、对齐与边界条件。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_runtime/src/sync/mpsc/bounded/array.rs", "line": 64, "evidence": "value: RefCell::new(MaybeUninit::uninit()),", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/sync/mpsc/bounded/mod.rs", "line": 225, "evidence": "SendPosition::Full => unreachable!(),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 47, "evidence": "data: unsafe { MaybeUninit::zeroed().assume_init() },", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 78, "evidence": "curr = unsafe { next.as_ref().unwrap() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 82, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 105, "evidence": "unsafe impl<T: Send> Send for Queue<T> {}", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 106, "evidence": "unsafe impl<T: Send> Sync for Queue<T> {}", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 143, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 164, "evidence": "let block = unsafe { &*block_ptr };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 189, "evidence": "let block = unsafe { &*block_ptr };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 196, "evidence": "let value = unsafe { node.value.as_ptr().read().assume_init() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 201, "evidence": "unsafe { (*self.tail.block.load(Acquire)).insert(block_ptr) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 56, "evidence": "fn try_insert(&self, ptr: *mut Block<T>) -> Result<(), *mut Block<T>> {", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 66, "evidence": "fn insert(&self, ptr: *mut Block<T>) {", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 15, "evidence": "use std::mem::MaybeUninit;", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 36, "evidence": "value: RefCell<MaybeUninit<T>>,", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 47, "evidence": "data: unsafe { MaybeUninit::zeroed().assume_init() },", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7999999999999999, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 144, "evidence": "node.value.as_ptr().write(MaybeUninit::new(value));", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 196, "evidence": "let value = unsafe { node.value.as_ptr().read().assume_init() };", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 78, "evidence": "curr = unsafe { next.as_ref().unwrap() };", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 115, "evidence": "block: NonNull::new(block_ptr).unwrap(),", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 135, "evidence": "let new_block_ptr = Box::into_raw(new_block.unwrap());", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 142, "evidence": "let node = block.data.get(index).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 193, "evidence": "let node = block.data.get(index).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 199, "evidence": "head.block = NonNull::new(block.next.load(Acquire)).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe_mem_ops", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 144, "evidence": "node.value.as_ptr().write(MaybeUninit::new(value));", "description": "使用不安全的内存操作（copy/copy_nonoverlapping/write/read），需确保指针有效性、对齐与重叠检查。", "suggestion": "优先使用安全的复制方法；必须使用时，在 SAFETY 注释中证明指针有效性、对齐与边界条件。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe_mem_ops", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 196, "evidence": "let value = unsafe { node.value.as_ptr().read().assume_init() };", "description": "使用不安全的内存操作（copy/copy_nonoverlapping/write/read），需确保指针有效性、对齐与重叠检查。", "suggestion": "优先使用安全的复制方法；必须使用时，在 SAFETY 注释中证明指针有效性、对齐与边界条件。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 83, "evidence": "drop(Box::from_raw(ptr));", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_runtime/src/sync/mpsc/unbounded/queue.rs", "line": 47, "evidence": "data: unsafe { MaybeUninit::zeroed().assume_init() },", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 16, "evidence": "use std::mem::MaybeUninit;", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1469, "evidence": "let local_addr = local_udp_socket.local_addr().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1470, "evidence": "let peer_addr = peer_udp_socket.local_addr().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1500, "evidence": "sender.set_ttl(101).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1501, "evidence": "assert_eq!(sender.ttl().unwrap(), 101);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1502, "evidence": "assert!(sender.take_error().unwrap().is_none());", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1503, "evidence": "sender.set_multicast_loop_v4(false).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1504, "evidence": "assert!(!sender.multicast_loop_v4().unwrap());", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1505, "evidence": "sender.set_multicast_ttl_v4(42).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1506, "evidence": "assert_eq!(sender.multicast_ttl_v4().unwrap(), 42);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1519, "evidence": ".expect(\"                                \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1523, "evidence": "let (connected_sender, _) = udp_try_bind_connect(ADDR, socket_deal).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1525, "evidence": "connected_sender.set_ttl(101).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1526, "evidence": "assert_eq!(connected_sender.ttl().unwrap(), 101);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1527, "evidence": "assert!(connected_sender.take_error().unwrap().is_none());", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1528, "evidence": "connected_sender.set_multicast_loop_v4(false).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1529, "evidence": "assert!(!connected_sender.multicast_loop_v4().unwrap());", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1530, "evidence": "connected_sender.set_multicast_ttl_v4(42).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1531, "evidence": "assert_eq!(connected_sender.multicast_ttl_v4().unwrap(), 42);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1536, "evidence": ".expect(\"                               \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1538, "evidence": ".leave_multicast_v4(&multi_addr.unwrap(), &interface)", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1539, "evidence": ".expect(\"                                \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1559, "evidence": "sender.set_multicast_loop_v6(false).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1560, "evidence": "assert!(!sender.multicast_loop_v6().unwrap());", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1573, "evidence": ".expect(\"                                \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1576, "evidence": "let (connected_sender, _) = udp_try_bind_connect(addr, socket_deal).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1578, "evidence": "connected_sender.set_multicast_loop_v6(false).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1579, "evidence": "assert!(!connected_sender.multicast_loop_v6().unwrap());", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1584, "evidence": ".expect(\"                               \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1587, "evidence": ".expect(\"                                \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1603, "evidence": "udp_try_bind_connect(ADDR, |_| {}).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1606, "evidence": ".expect(\"                  \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1613, "evidence": ".unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1617, "evidence": "block_on(handle).expect(\"               \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1631, "evidence": "let sender = UdpSocket::bind(ADDR).await.expect(\"                  \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1632, "evidence": "let receiver = UdpSocket::bind(ADDR).await.expect(\"                  \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1634, "evidence": "let sender_addr = sender.local_addr().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1635, "evidence": "let receiver_addr = receiver.local_addr().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1638, "evidence": ".expect(\"                  \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1645, "evidence": ".unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1649, "evidence": "block_on(handle).expect(\"               \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1662, "evidence": "let broadcast_socket = UdpSocket::bind(ADDR).await.expect(\"                  \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1665, "evidence": ".expect(\"                    \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1667, "evidence": "assert!(broadcast_socket.broadcast().expect(\"                    \"));", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1669, "evidence": "block_on(handle).expect(\"               \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1672, "evidence": "let (broadcast_socket, _) = udp_try_bind_connect(ADDR, |_| {}).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1675, "evidence": ".expect(\"                    \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1677, "evidence": "assert!(broadcast_socket.broadcast().expect(\"                    \"));", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1679, "evidence": "block_on(handle).expect(\"               \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1692, "evidence": "let socket_deal = |socket: &UdpSocket| local_addr = Some(socket.local_addr().unwrap());", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1693, "evidence": "let (connected_sock, _) = udp_try_bind_connect(ADDR, socket_deal).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1695, "evidence": "let connect_local_addr = connected_sock.local_addr().expect(\"                 \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1696, "evidence": "assert_eq!(connect_local_addr, local_addr.unwrap());", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1698, "evidence": "block_on(handle).expect(\"               \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1712, "evidence": "let socket_deal = |socket: &UdpSocket| local_addr = Some(socket.local_addr().unwrap());", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1713, "evidence": "let (_, peer_socket) = udp_try_bind_connect(ADDR, socket_deal).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1716, "evidence": "peer_socket.peer_addr().expect(\"                \"),", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1717, "evidence": "local_addr.unwrap()", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1720, "evidence": "block_on(handle).expect(\"               \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1734, "evidence": "let sender = UdpSocket::bind(ADDR).await.expect(\"                  \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1735, "evidence": "let receiver = UdpSocket::bind(ADDR).await.expect(\"                  \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1737, "evidence": "let receiver_addr = receiver.local_addr().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1742, "evidence": ".expect(\"                \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1748, "evidence": ".expect(\"                   \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1753, "evidence": "block_on(handle).expect(\"               \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1768, "evidence": "let sender = UdpSocket::bind(ADDR).await.expect(\"                  \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1769, "evidence": "let receiver = UdpSocket::bind(ADDR).await.expect(\"                  \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1771, "evidence": "let receiver_addr = receiver.local_addr().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1777, "evidence": ".expect(\"                \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1781, "evidence": "receiver.readable().await.expect(\"                       \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1784, "evidence": ".expect(\"                   \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1788, "evidence": "block_on(handle).expect(\"               \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1802, "evidence": "let sender = UdpSocket::bind(ADDR).await.expect(\"                  \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1803, "evidence": "let receiver = UdpSocket::bind(ADDR).await.expect(\"                  \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1805, "evidence": "let sender_addr = sender.local_addr().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1806, "evidence": "let receiver_addr = receiver.local_addr().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1810, "evidence": ".expect(\"                  \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1817, "evidence": ".unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1821, "evidence": "block_on(handle).expect(\"               \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1835, "evidence": "let sender = UdpSocket::bind(ADDR).await.expect(\"                  \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1836, "evidence": "let receiver = UdpSocket::bind(ADDR).await.expect(\"                  \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1838, "evidence": "let sender_addr = sender.local_addr().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1839, "evidence": "let receiver_addr = receiver.local_addr().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1841, "evidence": "let connect_socket = receiver.connect(sender_addr).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1847, "evidence": ".expect(\"                \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1853, "evidence": ".expect(\"                   \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1858, "evidence": "block_on(handle).expect(\"               \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1873, "evidence": "let sender = UdpSocket::bind(ADDR).await.expect(\"                  \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1874, "evidence": "let receiver = UdpSocket::bind(ADDR).await.expect(\"                  \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1876, "evidence": "let sender_addr = sender.local_addr().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1877, "evidence": "let receiver_addr = receiver.local_addr().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1879, "evidence": "let connect_socket = receiver.connect(sender_addr).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1885, "evidence": ".expect(\"                \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1888, "evidence": "connect_socket.readable().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1891, "evidence": ".expect(\"                   \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/udp.rs", "line": 1896, "evidence": "block_on(handle).expect(\"               \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/addr.rs", "line": 218, "evidence": "let mut addrs_iter = addr_str.to_socket_addrs().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/addr.rs", "line": 239, "evidence": ".unwrap()", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/addr.rs", "line": 259, "evidence": "let mut addrs_iter = addr_str.to_socket_addrs().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/addr.rs", "line": 271, "evidence": ".unwrap()", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/addr.rs", "line": 281, "evidence": "let mut addrs_iter = addr_str.to_socket_addrs().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/addr.rs", "line": 299, "evidence": "let mut addrs_iter = addr_str.to_socket_addrs().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/addr.rs", "line": 308, "evidence": "let mut addrs_iter = addr_str.to_socket_addrs().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/addr.rs", "line": 326, "evidence": "let mut addrs_iter = addr_str.to_socket_addrs().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/addr.rs", "line": 344, "evidence": "let mut addrs_iter = addr_str.to_socket_addrs().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/listener.rs", "line": 269, "evidence": "let server = TcpListener::bind(ADDR).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/listener.rs", "line": 271, "evidence": "server.set_ttl(101).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/listener.rs", "line": 272, "evidence": "assert_eq!(server.ttl().unwrap(), 101);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/listener.rs", "line": 274, "evidence": "assert!(server.take_error().unwrap().is_none());", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 135, "evidence": "let listener = TcpListener::bind(ADDR).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 136, "evidence": "let addr = listener.local_addr().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 143, "evidence": "let mut stream = stream.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 146, "evidence": "write_half.write(b\"                \").await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 148, "evidence": "let n = read_half.read(&mut buf).await.expect(\"               \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 151, "evidence": "String::from_utf8(Vec::from(buf)).unwrap().as_str(),", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 156, "evidence": "let (mut stream, _) = listener.accept().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 158, "evidence": "let n = stream.read(&mut buf).await.expect(\"               \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 161, "evidence": "String::from_utf8(Vec::from(buf)).unwrap().as_str(),", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 164, "evidence": "stream.write(b\"                \").await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 166, "evidence": "handle.await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 181, "evidence": "let listener = TcpListener::bind(ADDR).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 182, "evidence": "let addr = listener.local_addr().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 189, "evidence": "let stream = stream.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 193, "evidence": "write_half.write(b\"                \").await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 195, "evidence": "let n = read_half.read(&mut buf).await.expect(\"               \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 198, "evidence": "String::from_utf8(Vec::from(buf)).unwrap().as_str(),", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 203, "evidence": "let (mut stream, _) = listener.accept().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 205, "evidence": "let n = stream.read(&mut buf).await.expect(\"               \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 208, "evidence": "String::from_utf8(Vec::from(buf)).unwrap().as_str(),", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 211, "evidence": "stream.write(b\"                \").await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 213, "evidence": "handle.await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 228, "evidence": "let listener = TcpListener::bind(ADDR).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 229, "evidence": "let addr = listener.local_addr().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 236, "evidence": "let mut stream = stream.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 243, "evidence": "write_half.write_vectored(&[slice1, slice2]).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 244, "evidence": "write_half.flush().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 245, "evidence": "write_half.shutdown().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 247, "evidence": "let n = read_half.read(&mut buf).await.expect(\"               \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 252, "evidence": "let (mut stream, _) = listener.accept().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 254, "evidence": "let n = stream.read(&mut buf).await.expect(\"               \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 261, "evidence": "stream.write_vectored(&[slice1, slice2]).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 263, "evidence": "handle.await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 278, "evidence": "let listener = TcpListener::bind(ADDR).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 279, "evidence": "let addr = listener.local_addr().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 286, "evidence": "let stream = stream.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 293, "evidence": "write_half.write_vectored(&[slice1, slice2]).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 294, "evidence": "write_half.flush().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 295, "evidence": "write_half.shutdown().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 297, "evidence": "let n = read_half.read(&mut buf).await.expect(\"               \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 302, "evidence": "let (mut stream, _) = listener.accept().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 304, "evidence": "let n = stream.read(&mut buf).await.expect(\"               \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 311, "evidence": "stream.write_vectored(&[slice1, slice2]).await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/tcp/split.rs", "line": 313, "evidence": "handle.await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/net/sys/unix/listener.rs", "line": 125, "evidence": "unsafe { BorrowedFd::borrow_raw(self.as_raw_fd()) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/net/sys/unix/datagram.rs", "line": 448, "evidence": "unsafe { BorrowedFd::borrow_raw(self.as_raw_fd()) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/unix/datagram.rs", "line": 470, "evidence": "let (datagram, _) = std::os::unix::net::UnixDatagram::pair().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/unix/datagram.rs", "line": 474, "evidence": "let datagram = res.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/unix/datagram.rs", "line": 479, "evidence": "crate::block_on(handle).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/unix/datagram.rs", "line": 497, "evidence": "let (server, client) = UnixDatagram::pair().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/unix/datagram.rs", "line": 500, "evidence": "client.send(b\"           \").await.expect(\"           \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/unix/datagram.rs", "line": 504, "evidence": "server.recv(buf.as_mut_slice()).await.expect(\"           \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/unix/datagram.rs", "line": 506, "evidence": "std::str::from_utf8(&buf).unwrap(),", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/unix/datagram.rs", "line": 510, "evidence": "handle.await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/unix/datagram.rs", "line": 512, "evidence": "crate::block_on(handle2).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/unix/datagram.rs", "line": 528, "evidence": "let (server, client) = UnixDatagram::pair().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/unix/datagram.rs", "line": 530, "evidence": "server.writable().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/unix/datagram.rs", "line": 541, "evidence": "client.readable().await.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/unix/datagram.rs", "line": 546, "evidence": "assert_eq!(std::str::from_utf8(&data).unwrap(), \"     \".to_string());", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/net/sys/unix/datagram.rs", "line": 554, "evidence": "crate::block_on(handle).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/net/sys/unix/datagram.rs", "line": 537, "evidence": "Err(e) => panic!(\"     \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.44999999999999996, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/net/sys/unix/datagram.rs", "line": 550, "evidence": "Err(e) => panic!(\"     \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "pointer_arithmetic", "file": "ylong_runtime/src/iter/pariter/sum.rs", "line": 41, "evidence": "a.add(b)", "description": "使用 offset/add 进行指针算术，若计算结果超出有效范围将导致未定义行为。", "suggestion": "确保指针算术结果在有效对象边界内；使用 slice 等安全抽象替代原始指针算术。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/signal/windows/registry.rs", "line": 14, "evidence": "use std::mem::MaybeUninit;", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/signal/windows/mod.rs", "line": 125, "evidence": "unsafe extern \"      \" fn signal_action(signal_kind: u32) -> i32 {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/signal/windows/mod.rs", "line": 134, "evidence": "let res = unsafe { winapi::SetConsoleCtrlHandler(Some(signal_action), 1) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/signal/windows/winapi.rs", "line": 18, "evidence": "pub type PHANDLER_ROUTINE = Option<unsafe extern \"      \" fn(ctrlType: u32) -> BOOL>;", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/signal/unix/registry.rs", "line": 101, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/signal/unix/registry.rs", "line": 16, "evidence": "use std::mem::MaybeUninit;", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/signal/unix/registry.rs", "line": 99, "evidence": "static mut REGISTRY: MaybeUninit<Registry> = MaybeUninit::uninit();", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/signal/unix/registry.rs", "line": 103, "evidence": "REGISTRY = MaybeUninit::new(Registry::default());", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/signal/unix/registry.rs", "line": 136, "evidence": "let _ = event.inner.send(());", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/signal/unix/registry.rs", "line": 114, "evidence": ".unwrap_or_else(|| panic!(\"                    \", event_id))", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/signal/unix/registry.rs", "line": 122, "evidence": ".unwrap_or_else(|| panic!(\"                    \", event_id))", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_runtime/src/signal/unix/registry.rs", "line": 99, "evidence": "static mut REGISTRY: MaybeUninit<Registry> = MaybeUninit::uninit();", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/signal/unix/driver.rs", "line": 28, "evidence": "use std::mem::MaybeUninit;", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/signal/unix/driver.rs", "line": 29, "evidence": "static mut SIGNAL_DRIVER: MaybeUninit<SignalDriver> = MaybeUninit::uninit();", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/signal/unix/driver.rs", "line": 37, "evidence": "Ok(0) => panic!(\"                           \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/signal/unix/driver.rs", "line": 40, "evidence": "Err(e) => panic!(\"                                  \"),", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_runtime/src/signal/unix/driver.rs", "line": 55, "evidence": ".unwrap_or_else(|e| panic!(\"                                      \"));", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_runtime/src/signal/unix/driver.rs", "line": 29, "evidence": "static mut SIGNAL_DRIVER: MaybeUninit<SignalDriver> = MaybeUninit::uninit();", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 455, "evidence": "unsafe { libc::raise(libc::SIGALRM) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 460, "evidence": "unsafe { libc::raise(libc::SIGALRM) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 474, "evidence": "unsafe { libc::raise(libc::SIGALRM) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 489, "evidence": "unsafe { libc::raise(libc::SIGCHLD) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 504, "evidence": "unsafe { libc::raise(libc::SIGHUP) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 519, "evidence": "unsafe { libc::raise(libc::SIGINT) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 534, "evidence": "unsafe { libc::raise(libc::SIGIO) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 549, "evidence": "unsafe { libc::raise(libc::SIGPIPE) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 564, "evidence": "unsafe { libc::raise(libc::SIGTERM) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 579, "evidence": "unsafe { libc::raise(libc::SIGUSR1) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 594, "evidence": "unsafe { libc::raise(libc::SIGUSR2) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 609, "evidence": "unsafe { libc::raise(libc::SIGWINCH) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 454, "evidence": "let mut signal = signal(SignalKind::alarm()).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 459, "evidence": "let mut signal = signal(SignalKind::alarm()).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 473, "evidence": "let mut signal = signal(SignalKind::alarm()).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 488, "evidence": "let mut signal = signal(SignalKind::child()).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 503, "evidence": "let mut signal = signal(SignalKind::hangup()).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 518, "evidence": "let mut signal = signal(SignalKind::interrupt()).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 533, "evidence": "let mut signal = signal(SignalKind::io()).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 548, "evidence": "let mut signal = signal(SignalKind::pipe()).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 563, "evidence": "let mut signal = signal(SignalKind::terminate()).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 578, "evidence": "let mut signal = signal(SignalKind::user_defined1()).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 593, "evidence": "let mut signal = signal(SignalKind::user_defined2()).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 608, "evidence": "let mut signal = signal(SignalKind::window_change()).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 357, "evidence": "let _ = global.write(&[1]);", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 403, "evidence": "let _ = SignalDriver::get_mut_ref();", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.45000000000000007, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 477, "evidence": "let _ = crate::block_on(handle);", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.45000000000000007, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 492, "evidence": "let _ = crate::block_on(handle);", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.45000000000000007, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 507, "evidence": "let _ = crate::block_on(handle);", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.45000000000000007, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 522, "evidence": "let _ = crate::block_on(handle);", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.45000000000000007, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 537, "evidence": "let _ = crate::block_on(handle);", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.45000000000000007, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 552, "evidence": "let _ = crate::block_on(handle);", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.45000000000000007, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 567, "evidence": "let _ = crate::block_on(handle);", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.45000000000000007, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 582, "evidence": "let _ = crate::block_on(handle);", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.45000000000000007, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 597, "evidence": "let _ = crate::block_on(handle);", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.45000000000000007, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 612, "evidence": "let _ = crate::block_on(handle);", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.45000000000000007, "severity": "low"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 58, "evidence": "pub const fn from_raw(signal_num: c_int) -> SignalKind {", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 341, "evidence": "Self::from_raw(value)", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 429, "evidence": "assert_eq!(SignalKind::from_raw(2), SignalKind::interrupt());", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.7999999999999999, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_runtime/src/signal/unix/mod.rs", "line": 440, "evidence": "let signal_kind = SignalKind::from_raw(SIGNAL_BLOCK_LIST[0]);", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.7999999999999999, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/pty_process/pty.rs", "line": 149, "evidence": ".expect(\"                                                       \"))", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/pty_process/pty.rs", "line": 162, "evidence": "value.0.io_take().expect(\"                    \").into()", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/process/pty_process/sys.rs", "line": 41, "evidence": "let fd = unsafe { OwnedFd::from_raw_fd(raw) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/process/pty_process/sys.rs", "line": 66, "evidence": "let res = unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/process/pty_process/sys.rs", "line": 87, "evidence": "let name = unsafe { CStr::from_ptr(name_buf.as_ptr()) }.to_owned();", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/pty_process/sys.rs", "line": 222, "evidence": "let pty = PtyInner::open().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/pty_process/sys.rs", "line": 225, "evidence": "let pts = pts.unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/pty_process/sys.rs", "line": 240, "evidence": "let mut pty = PtyInner::open().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/pty_process/sys.rs", "line": 242, "evidence": "pty.write_all(arg.as_bytes()).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/pty_process/sys.rs", "line": 245, "evidence": "pty.read_exact(&mut buf).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "ffi", "pattern": "CString/CStr", "file": "ylong_runtime/src/process/pty_process/sys.rs", "line": 14, "evidence": "use std::ffi::CStr;", "description": "FFI 中使用 CString/CStr 需要确保正确的生命周期管理与空字节处理。", "suggestion": "确保 CString 生命周期覆盖 FFI 调用期间；注意 CStr 不能包含内部空字节。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "ffi", "pattern": "CString/CStr", "file": "ylong_runtime/src/process/pty_process/sys.rs", "line": 87, "evidence": "let name = unsafe { CStr::from_ptr(name_buf.as_ptr()) }.to_owned();", "description": "FFI 中使用 CString/CStr 需要确保正确的生命周期管理与空字节处理。", "suggestion": "确保 CString 生命周期覆盖 FFI 调用期间；注意 CStr 不能包含内部空字节。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe_mem_ops", "file": "ylong_runtime/src/process/pty_process/sys.rs", "line": 90, "evidence": "let file = OpenOptions::new().read(true).write(true).open(path)?;", "description": "使用不安全的内存操作（copy/copy_nonoverlapping/write/read），需确保指针有效性、对齐与重叠检查。", "suggestion": "优先使用安全的复制方法；必须使用时，在 SAFETY 注释中证明指针有效性、对齐与边界条件。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/process/pty_process/command.rs", "line": 302, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/process/pty_process/command.rs", "line": 485, "evidence": "pub unsafe fn pre_exec<F>(&mut self, f: F) -> &mut PtyCommand", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_runtime/src/process/sys/unix/zombie_manager.rs", "line": 14, "evidence": "use std::mem::MaybeUninit;", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/process/sys/unix/child.rs", "line": 106, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/process/sys/unix/child.rs", "line": 187, "evidence": "unsafe { BorrowedFd::borrow_raw(self.as_raw_fd()) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/sys/unix/child.rs", "line": 43, "evidence": "self.std.as_ref().unwrap().id()", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/sys/unix/child.rs", "line": 48, "evidence": "self.std.as_mut().unwrap().kill()", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/sys/unix/child.rs", "line": 53, "evidence": "self.std.as_mut().unwrap().try_wait()", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/sys/unix/child.rs", "line": 87, "evidence": "let std = self.std.take().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/process/sys/unix/pipe.rs", "line": 29, "evidence": "let fd = unsafe { File::from_raw_fd(value.into_raw_fd()) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/process/sys/unix/pipe.rs", "line": 62, "evidence": "unsafe { BorrowedFd::borrow_raw(self.fd.as_raw_fd()) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/sys/unix/pipe.rs", "line": 110, "evidence": ".unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/sys/unix/pipe.rs", "line": 111, "evidence": "let seek = file.stream_position().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/sys/unix/pipe.rs", "line": 118, "evidence": "(&pipe).write_all(arg.as_bytes()).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/sys/unix/pipe.rs", "line": 119, "evidence": "(&pipe).flush().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/sys/unix/pipe.rs", "line": 121, "evidence": "pipe.fd.seek(std::io::SeekFrom::Start(seek)).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/sys/unix/pipe.rs", "line": 124, "evidence": "(&pipe).read_exact(&mut buf).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_runtime/src/process/sys/unix/pipe.rs", "line": 127, "evidence": "std::fs::remove_file(file_path).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/buffered/async_buf_reader.rs", "line": 187, "evidence": "let this = unsafe { self.get_unchecked_mut() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/buffered/async_buf_reader.rs", "line": 189, "evidence": "return unsafe { Pin::new_unchecked(&mut this.inner).poll_read(cx, buf) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/buffered/async_buf_reader.rs", "line": 226, "evidence": "let this = unsafe { self.get_unchecked_mut() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/buffered/async_buf_reader.rs", "line": 230, "evidence": "let res = unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/buffered/async_buf_reader.rs", "line": 237, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/buffered/async_buf_reader.rs", "line": 245, "evidence": "let res = unsafe { poll_ready!(Pin::new_unchecked(&mut this.inner).poll_seek(cx, pos))? };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/buffered/async_buf_reader.rs", "line": 275, "evidence": "let this = unsafe { self.get_unchecked_mut() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/buffered/async_buf_reader.rs", "line": 276, "evidence": "unsafe { Pin::new_unchecked(&mut this.inner).poll_flush(cx) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "get_unchecked", "file": "ylong_runtime/src/io/buffered/async_buf_reader.rs", "line": 187, "evidence": "let this = unsafe { self.get_unchecked_mut() };", "description": "使用 get_unchecked/get_unchecked_mut 绕过边界检查，若索引无效将导致未定义行为。", "suggestion": "优先使用安全的索引方法（[] 或 get）；必须使用 get_unchecked 时，在 SAFETY 注释中证明索引有效性。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "get_unchecked", "file": "ylong_runtime/src/io/buffered/async_buf_reader.rs", "line": 226, "evidence": "let this = unsafe { self.get_unchecked_mut() };", "description": "使用 get_unchecked/get_unchecked_mut 绕过边界检查，若索引无效将导致未定义行为。", "suggestion": "优先使用安全的索引方法（[] 或 get）；必须使用 get_unchecked 时，在 SAFETY 注释中证明索引有效性。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "get_unchecked", "file": "ylong_runtime/src/io/buffered/async_buf_reader.rs", "line": 275, "evidence": "let this = unsafe { self.get_unchecked_mut() };", "description": "使用 get_unchecked/get_unchecked_mut 绕过边界检查，若索引无效将导致未定义行为。", "suggestion": "优先使用安全的索引方法（[] 或 get）；必须使用 get_unchecked 时，在 SAFETY 注释中证明索引有效性。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/buffered/async_buf_writer.rs", "line": 215, "evidence": "let this = unsafe { self.get_unchecked_mut() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/buffered/async_buf_writer.rs", "line": 217, "evidence": "unsafe { Pin::new_unchecked(&mut this.inner).poll_write(cx, buf) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/buffered/async_buf_writer.rs", "line": 238, "evidence": "let this = unsafe { self.get_unchecked_mut() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/buffered/async_buf_writer.rs", "line": 240, "evidence": "unsafe { Pin::new_unchecked(&mut this.inner).poll_write_vectored(cx, bufs) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/buffered/async_buf_writer.rs", "line": 259, "evidence": "let this = unsafe { self.get_unchecked_mut() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/buffered/async_buf_writer.rs", "line": 261, "evidence": "return unsafe { Pin::new_unchecked(&mut this.inner).poll_write(cx, &bufs[0]) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/buffered/async_buf_writer.rs", "line": 290, "evidence": "let this = unsafe { self.get_unchecked_mut() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/buffered/async_buf_writer.rs", "line": 291, "evidence": "unsafe { Pin::new_unchecked(&mut this.inner).poll_shutdown(cx) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/buffered/async_buf_writer.rs", "line": 320, "evidence": "let this = unsafe { self.get_unchecked_mut() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/buffered/async_buf_writer.rs", "line": 321, "evidence": "unsafe { Pin::new_unchecked(&mut this.inner).poll_fill_buf(cx) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/buffered/async_buf_writer.rs", "line": 325, "evidence": "let this = unsafe { self.get_unchecked_mut() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_runtime/src/io/buffered/async_buf_writer.rs", "line": 326, "evidence": "unsafe { Pin::new_unchecked(&mut this.inner).consume(amt) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "get_unchecked", "file": "ylong_runtime/src/io/buffered/async_buf_writer.rs", "line": 215, "evidence": "let this = unsafe { self.get_unchecked_mut() };", "description": "使用 get_unchecked/get_unchecked_mut 绕过边界检查，若索引无效将导致未定义行为。", "suggestion": "优先使用安全的索引方法（[] 或 get）；必须使用 get_unchecked 时，在 SAFETY 注释中证明索引有效性。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "get_unchecked", "file": "ylong_runtime/src/io/buffered/async_buf_writer.rs", "line": 238, "evidence": "let this = unsafe { self.get_unchecked_mut() };", "description": "使用 get_unchecked/get_unchecked_mut 绕过边界检查，若索引无效将导致未定义行为。", "suggestion": "优先使用安全的索引方法（[] 或 get）；必须使用 get_unchecked 时，在 SAFETY 注释中证明索引有效性。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "get_unchecked", "file": "ylong_runtime/src/io/buffered/async_buf_writer.rs", "line": 259, "evidence": "let this = unsafe { self.get_unchecked_mut() };", "description": "使用 get_unchecked/get_unchecked_mut 绕过边界检查，若索引无效将导致未定义行为。", "suggestion": "优先使用安全的索引方法（[] 或 get）；必须使用 get_unchecked 时，在 SAFETY 注释中证明索引有效性。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "get_unchecked", "file": "ylong_runtime/src/io/buffered/async_buf_writer.rs", "line": 290, "evidence": "let this = unsafe { self.get_unchecked_mut() };", "description": "使用 get_unchecked/get_unchecked_mut 绕过边界检查，若索引无效将导致未定义行为。", "suggestion": "优先使用安全的索引方法（[] 或 get）；必须使用 get_unchecked 时，在 SAFETY 注释中证明索引有效性。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "get_unchecked", "file": "ylong_runtime/src/io/buffered/async_buf_writer.rs", "line": 320, "evidence": "let this = unsafe { self.get_unchecked_mut() };", "description": "使用 get_unchecked/get_unchecked_mut 绕过边界检查，若索引无效将导致未定义行为。", "suggestion": "优先使用安全的索引方法（[] 或 get）；必须使用 get_unchecked 时，在 SAFETY 注释中证明索引有效性。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "get_unchecked", "file": "ylong_runtime/src/io/buffered/async_buf_writer.rs", "line": 325, "evidence": "let this = unsafe { self.get_unchecked_mut() };", "description": "使用 get_unchecked/get_unchecked_mut 绕过边界检查，若索引无效将导致未定义行为。", "suggestion": "优先使用安全的索引方法（[] 或 get）；必须使用 get_unchecked 时，在 SAFETY 注释中证明索引有效性。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/interest.rs", "line": 27, "evidence": "pub const READABLE: Interest = Interest(unsafe { NonZeroU8::new_unchecked(READABLE) });", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/interest.rs", "line": 29, "evidence": "pub const WRITABLE: Interest = Interest(unsafe { NonZeroU8::new_unchecked(WRITABLE) });", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/interest.rs", "line": 33, "evidence": "Interest(unsafe { NonZeroU8::new_unchecked(self.0.get() | other.0.get()) })", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_io/src/interest.rs", "line": 91, "evidence": "0: NonZeroU8::new(4).unwrap(),", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "unsafe_usage", "pattern": "pointer_arithmetic", "file": "ylong_io/src/interest.rs", "line": 69, "evidence": "self.add(other)", "description": "使用 offset/add 进行指针算术，若计算结果超出有效范围将导致未定义行为。", "suggestion": "确保指针算术结果在有效对象边界内；使用 slice 等安全抽象替代原始指针算术。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_io/src/waker.rs", "line": 48, "evidence": "let poll = Poll::new().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_io/src/waker.rs", "line": 49, "evidence": "let waker = Waker::new(&poll, Token::from_usize(0)).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "concurrency", "pattern": "unsafe_impl_Send_or_Sync", "file": "ylong_io/src/sys/windows/io_status_block.rs", "line": 21, "evidence": "unsafe impl Send for IoStatusBlock {}", "description": "手写 unsafe impl Send/Sync 可能破坏并发内存模型保证，带来数据竞争风险。", "suggestion": "避免手写 unsafe impl；必要时严格证明线程安全前置条件并最小化不安全区域。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_io/src/sys/windows/io_status_block.rs", "line": 24, "evidence": "pub(crate) fn zeroed() -> Self {", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/handle.rs", "line": 41, "evidence": "unsafe { CloseHandle(self.0) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "resource_management", "pattern": "mem::forget", "file": "ylong_io/src/sys/windows/handle.rs", "line": 34, "evidence": "std::mem::forget(self);", "description": "使用 mem::forget 会跳过 Drop 导致资源泄漏，若错误使用可能破坏不变式或造成泄漏。", "suggestion": "避免无必要的 mem::forget；如需抑制 Drop，优先使用 ManuallyDrop 或设计更安全的所有权转移。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_io/src/sys/windows/net.rs", "line": 65, "evidence": "let mut sock_state = state.state.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_io/src/sys/windows/net.rs", "line": 124, "evidence": "let mut sock_state = self.state.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/socket_addr.rs", "line": 37, "evidence": "let sin_addr = unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/socket_addr.rs", "line": 57, "evidence": "let sin_addr6 = unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/socket_addr.rs", "line": 63, "evidence": "let sockaddr_in6_0 = unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/socket_addr.rs", "line": 29, "evidence": "pub(crate) fn as_ptr(&self) -> *const SOCKADDR {", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/socket_addr.rs", "line": 30, "evidence": "(self as *const SocketAddrWin).cast::<SOCKADDR>()", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/iocp.rs", "line": 35, "evidence": "let handle = unsafe { CreateIoCompletionPort(INVALID_HANDLE_VALUE, 0, 0, 0) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/selector.rs", "line": 128, "evidence": "unsafe { self.update_sockets_events() }?;", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/selector.rs", "line": 137, "evidence": "Ok(iocp_events) => Ok(unsafe { self.feed_events(&mut events.events, iocp_events) }),", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/selector.rs", "line": 145, "evidence": "unsafe fn feed_events(", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/selector.rs", "line": 187, "evidence": "unsafe fn update_sockets_events(&self) -> io::Result<()> {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/selector.rs", "line": 226, "evidence": "unsafe { this.update_sockets_events()? }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/selector.rs", "line": 246, "evidence": "unsafe { self.update_sockets_events() }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/selector.rs", "line": 296, "evidence": "unsafe { (*(iocp_event.overlapped().cast::<super::Overlapped>())).callback };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/selector.rs", "line": 375, "evidence": "let result = unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/selector.rs", "line": 462, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/selector.rs", "line": 520, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/selector.rs", "line": 568, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/selector.rs", "line": 609, "evidence": "unsafe { Arc::into_raw(Pin::into_inner_unchecked(sock_state)) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/selector.rs", "line": 616, "evidence": "unsafe { Pin::new_unchecked(Arc::from_raw(sock_ptr)) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/selector.rs", "line": 574, "evidence": "(&mut base_socket as *mut RawSocket).cast::<c_void>(),", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/selector.rs", "line": 607, "evidence": "fn into_overlapped(sock_state: Pin<Arc<Mutex<SockState>>>) -> *mut c_void {", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/selector.rs", "line": 608, "evidence": "let overlapped_ptr: *const Mutex<SockState> =", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/selector.rs", "line": 610, "evidence": "overlapped_ptr as *mut _", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/selector.rs", "line": 614, "evidence": "fn from_overlapped(ptr: *mut OVERLAPPED) -> Pin<Arc<Mutex<SockState>>> {", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/selector.rs", "line": 615, "evidence": "let sock_ptr: *const Mutex<SockState> = ptr as *const _;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_io/src/sys/windows/selector.rs", "line": 151, "evidence": "let mut update_queue = self.update_queue.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_io/src/sys/windows/selector.rs", "line": 169, "evidence": "let mut sock_guard = sock_state.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_io/src/sys/windows/selector.rs", "line": 188, "evidence": "let mut update_queue = self.update_queue.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_io/src/sys/windows/selector.rs", "line": 190, "evidence": "let mut sock_internal = sock.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_io/src/sys/windows/selector.rs", "line": 196, "evidence": "update_queue.retain(|sock| sock.lock().unwrap().has_error());", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_io/src/sys/windows/selector.rs", "line": 240, "evidence": "state.lock().unwrap().set_event(flags, token.0 as u64);", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_io/src/sys/windows/selector.rs", "line": 254, "evidence": "let mut update_queue = self.update_queue.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_io/src/sys/windows/selector.rs", "line": 382, "evidence": "let code = e.raw_os_error().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_io/src/sys/windows/selector.rs", "line": 301, "evidence": "let _ = from_overlapped(iocp_event.overlapped());", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_io/src/sys/windows/selector.rs", "line": 517, "evidence": "unreachable!(\"                                        \", self);", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_io/src/sys/windows/selector.rs", "line": 616, "evidence": "unsafe { Pin::new_unchecked(Arc::from_raw(sock_ptr)) }", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_io/src/sys/windows/selector.rs", "line": 348, "evidence": "iosb: IoStatusBlock::zeroed(),", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_io/src/sys/windows/selector.rs", "line": 349, "evidence": "poll_info: AfdPollInfo::zeroed(),", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/mod.rs", "line": 18, "evidence": "let res = unsafe { $fn($($arg, )*) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/mod.rs", "line": 55, "evidence": "let res = unsafe { $fn($($arg, )*) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/winapi.rs", "line": 43, "evidence": "unsafe extern \"      \" fn(", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/winapi.rs", "line": 50, "evidence": "unsafe extern \"      \" fn(", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/winapi.rs", "line": 25, "evidence": "pub type PULONG = *mut ULONG;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/winapi.rs", "line": 27, "evidence": "pub type PVOID = *mut c_void;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/winapi.rs", "line": 30, "evidence": "pub type LPOVERLAPPED = *mut OVERLAPPED;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/winapi.rs", "line": 31, "evidence": "pub type LPOVERLAPPED_ENTRY = *mut OVERLAPPED_ENTRY;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/winapi.rs", "line": 33, "evidence": "pub type PWSTR = *mut u16;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/winapi.rs", "line": 34, "evidence": "pub type PUNICODE_STRING = *mut UNICODE_STRING;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/winapi.rs", "line": 44, "evidence": "apcContext: *mut c_void,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/winapi.rs", "line": 45, "evidence": "ioStatusBlock: *mut IO_STATUS_BLOCK,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/winapi.rs", "line": 53, "evidence": "lpOverlapped: *mut OVERLAPPED,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/winapi.rs", "line": 132, "evidence": "FileHandle: *mut HANDLE,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/winapi.rs", "line": 134, "evidence": "ObjectAttributes: *mut OBJECT_ATTRIBUTES,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/winapi.rs", "line": 135, "evidence": "IoStatusBlock: *mut IO_STATUS_BLOCK,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/winapi.rs", "line": 136, "evidence": "AllocationSize: *mut i64,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/winapi.rs", "line": 150, "evidence": "IoStatusBlock: *mut IO_STATUS_BLOCK,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/winapi.rs", "line": 165, "evidence": "lpvInBuffer: *const c_void,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/winapi.rs", "line": 167, "evidence": "lpvOutBuffer: *mut c_void,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/winapi.rs", "line": 169, "evidence": "lpcbBytesReturned: *mut u32,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/winapi.rs", "line": 170, "evidence": "lpOverlapped: *mut OVERLAPPED,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/winapi.rs", "line": 174, "evidence": "pub fn bind(s: SOCKET, name: *const SOCKADDR, namelen: c_int) -> c_int;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/winapi.rs", "line": 178, "evidence": "pub fn ioctlsocket(s: SOCKET, cmd: c_long, argp: *mut c_ulong) -> c_int;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/winapi.rs", "line": 186, "evidence": "optval: *const c_char,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/winapi.rs", "line": 192, "evidence": "pub fn connect(s: SOCKET, name: *const SOCKADDR, namelen: c_int) -> c_int;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/winapi.rs", "line": 208, "evidence": "pub Pointer: *mut c_void,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/winapi.rs", "line": 257, "evidence": "pub Pointer: *mut c_void,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/afd.rs", "line": 96, "evidence": "let fd = unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/afd.rs", "line": 136, "evidence": "pub(crate) unsafe fn poll(", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/afd.rs", "line": 169, "evidence": "pub(crate) unsafe fn cancel(&self, iosb: *mut IO_STATUS_BLOCK) -> io::Result<()> {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/afd.rs", "line": 246, "evidence": "unsafe { zeroed() }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/afd.rs", "line": 52, "evidence": "ObjectName: &OBJ_NAME as *const _ as *mut _,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/afd.rs", "line": 60, "evidence": "Buffer: AFD_HELPER_NAME.as_ptr() as *mut _,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/afd.rs", "line": 74, "evidence": "IoRequestToCancel: *mut IO_STATUS_BLOCK,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/afd.rs", "line": 75, "evidence": "IoStatusBlock: *mut IO_STATUS_BLOCK,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/afd.rs", "line": 98, "evidence": "&mut afd_device_handle as *mut _,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/afd.rs", "line": 100, "evidence": "&AFD_ATTRIBUTES as *const _ as *mut _,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/afd.rs", "line": 139, "evidence": "iosb: *mut IO_STATUS_BLOCK,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/afd.rs", "line": 140, "evidence": "overlapped: *mut c_void,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/afd.rs", "line": 142, "evidence": "let afd_info = (info as *mut AfdPollInfo).cast::<c_void>();", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/afd.rs", "line": 169, "evidence": "pub(crate) unsafe fn cancel(&self, iosb: *mut IO_STATUS_BLOCK) -> io::Result<()> {", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_io/src/sys/windows/afd.rs", "line": 209, "evidence": "let mut afd_group = self.afd_group.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_io/src/sys/windows/afd.rs", "line": 214, "evidence": "|| Arc::strong_count(afd_group.last().unwrap()) > POLL_GROUP__MAX_GROUP_SIZE", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_io/src/sys/windows/afd.rs", "line": 231, "evidence": "let mut afd_group = self.afd_group.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_io/src/sys/windows/afd.rs", "line": 222, "evidence": "None => unreachable!(", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_io/src/sys/windows/afd.rs", "line": 245, "evidence": "pub(crate) fn zeroed() -> AfdPollInfo {", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_io/src/sys/windows/afd.rs", "line": 246, "evidence": "unsafe { zeroed() }", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/unix/socket_addr.rs", "line": 26, "evidence": "pub(crate) fn as_ptr(&self) -> *const sockaddr {", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/unix/socket_addr.rs", "line": 27, "evidence": "let ptr: *const SocketAddrLibC = self;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_io/src/sys/unix/source_fd.rs", "line": 53, "evidence": "let sock = socket::socket_new(libc::AF_UNIX, libc::SOCK_STREAM).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/unix/socket.rs", "line": 34, "evidence": "&1 as *const libc::c_int as *const libc::c_void,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_io/src/sys/unix/socket.rs", "line": 37, "evidence": "let _ = syscall!(close(socket));", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_io/src/sys/unix/socket.rs", "line": 42, "evidence": "let _ = syscall!(close(socket));", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_io/src/sys/unix/socket.rs", "line": 47, "evidence": "let _ = syscall!(close(socket));", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/unix/epoll.rs", "line": 67, "evidence": "Ok(n_events) => unsafe { events.set_len(n_events as usize) },", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/unix/mod.rs", "line": 18, "evidence": "let res = unsafe { libc::$fn($($arg, )*) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/unix/waker.rs", "line": 52, "evidence": "let fd = unsafe { libc::eventfd(0, libc::EFD_CLOEXEC | libc::EFD_NONBLOCK) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/unix/waker.rs", "line": 53, "evidence": "let file = unsafe { File::from_raw_fd(fd) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/unix/kqueue.rs", "line": 69, "evidence": "unsafe { events.set_len(n_events as usize) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/unix/kqueue.rs", "line": 212, "evidence": "..unsafe { mem::zeroed() }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/unix/kqueue.rs", "line": 57, "evidence": "Some(t) => t as *const libc::timespec,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/unix/kqueue.rs", "line": 211, "evidence": "udata: udata as *mut c_void,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "panic/unreachable", "file": "ylong_io/src/sys/unix/kqueue.rs", "line": 277, "evidence": "panic!(\"                          \");", "description": "使用 panic!/unreachable! 可能导致程序崩溃，缺少优雅的错误处理。", "suggestion": "优先使用 Result 类型进行错误处理；仅在确实不可恢复的情况下使用 panic。", "confidence": 0.6, "severity": "medium"}
{"language": "rust", "category": "concurrency", "pattern": "unsafe_impl_Send_or_Sync", "file": "ylong_io/src/sys/unix/kqueue.rs", "line": 245, "evidence": "unsafe impl Send for Events {}", "description": "手写 unsafe impl Send/Sync 可能破坏并发内存模型保证，带来数据竞争风险。", "suggestion": "避免手写 unsafe impl；必要时严格证明线程安全前置条件并最小化不安全区域。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "concurrency", "pattern": "unsafe_impl_Send_or_Sync", "file": "ylong_io/src/sys/unix/kqueue.rs", "line": 246, "evidence": "unsafe impl Sync for Events {}", "description": "手写 unsafe impl Send/Sync 可能破坏并发内存模型保证，带来数据竞争风险。", "suggestion": "避免手写 unsafe impl；必要时严格证明线程安全前置条件并最小化不安全区域。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_io/src/sys/unix/kqueue.rs", "line": 212, "evidence": "..unsafe { mem::zeroed() }", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/tcp/listener.rs", "line": 45, "evidence": "let listener = unsafe { TcpListener::from_raw_socket(socket.as_raw_socket() as _) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/tcp/socket.rs", "line": 54, "evidence": "let _ = unsafe { closesocket(socket) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/tcp/socket.rs", "line": 116, "evidence": "unsafe fn from_raw_socket(sock: RawSocket) -> Self {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/tcp/socket.rs", "line": 139, "evidence": "let linger = unsafe { optval.assume_init() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/windows/tcp/socket.rs", "line": 151, "evidence": "(&optval as *const LINGER).cast(),", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_io/src/sys/windows/tcp/socket.rs", "line": 14, "evidence": "use std::mem::MaybeUninit;", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_io/src/sys/windows/tcp/socket.rs", "line": 124, "evidence": "let mut optval: MaybeUninit<LINGER> = MaybeUninit::uninit();", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_io/src/sys/windows/tcp/socket.rs", "line": 139, "evidence": "let linger = unsafe { optval.assume_init() };", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_io/src/sys/windows/tcp/socket.rs", "line": 54, "evidence": "let _ = unsafe { closesocket(socket) };", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_io/src/sys/windows/tcp/socket.rs", "line": 124, "evidence": "let mut optval: MaybeUninit<LINGER> = MaybeUninit::uninit();", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/tcp/stream.rs", "line": 46, "evidence": "let stream = unsafe { TcpStream::from_raw_socket(socket.as_raw_socket() as _) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/udp/socket.rs", "line": 52, "evidence": "let _ = unsafe { closesocket(socket) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/windows/udp/socket.rs", "line": 61, "evidence": "let socket = unsafe { net::UdpSocket::from_raw_socket(self.socket as raw::SOCKET) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "error_handling", "pattern": "ignored_result", "file": "ylong_io/src/sys/windows/udp/socket.rs", "line": 52, "evidence": "let _ = unsafe { closesocket(socket) };", "description": "可能忽略了返回的错误结果，导致失败未被处理。", "suggestion": "显式处理 Result（? 传播或 match），确保错误路径涵盖资源回收与日志记录。", "confidence": 0.55, "severity": "low"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/unix/tcp/listener.rs", "line": 40, "evidence": "inner: unsafe { net::TcpListener::from_raw_fd(socket.as_raw_fd()) },", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/unix/tcp/listener.rs", "line": 67, "evidence": "Ok(socket) => unsafe { net::TcpStream::from_raw_fd(socket) },", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/unix/tcp/listener.rs", "line": 81, "evidence": "unsafe { net::TcpStream::from_raw_fd(socket) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/unix/tcp/listener.rs", "line": 86, "evidence": "let ret = unsafe { trans_addr_2_socket(addr.as_ptr()) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/unix/tcp/listener.rs", "line": 160, "evidence": "pub(crate) unsafe fn trans_addr_2_socket(", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/unix/tcp/listener.rs", "line": 76, "evidence": "addr.as_mut_ptr() as *mut _,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/unix/tcp/listener.rs", "line": 161, "evidence": "storage: *const libc::sockaddr_storage,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_io/src/sys/unix/tcp/listener.rs", "line": 15, "evidence": "use std::mem::{size_of, MaybeUninit};", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_io/src/sys/unix/tcp/listener.rs", "line": 57, "evidence": "let mut addr: MaybeUninit<sockaddr_storage> = MaybeUninit::uninit();", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_io/src/sys/unix/tcp/listener.rs", "line": 57, "evidence": "let mut addr: MaybeUninit<sockaddr_storage> = MaybeUninit::uninit();", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/unix/tcp/socket.rs", "line": 80, "evidence": "inner: unsafe { net::TcpStream::from_raw_fd(self.socket) },", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/unix/tcp/socket.rs", "line": 97, "evidence": "unsafe fn from_raw_fd(fd: RawFd) -> TcpSocket {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/unix/tcp/socket.rs", "line": 114, "evidence": "let linger = unsafe { payload.assume_init() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/unix/tcp/socket.rs", "line": 57, "evidence": "(&set_value as *const c_int).cast::<c_void>(),", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/unix/tcp/socket.rs", "line": 125, "evidence": "(&payload as *const linger).cast::<c_void>(),", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_io/src/sys/unix/tcp/socket.rs", "line": 15, "evidence": "use std::mem::{self, size_of, MaybeUninit};", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_io/src/sys/unix/tcp/socket.rs", "line": 103, "evidence": "let mut payload: MaybeUninit<linger> = MaybeUninit::uninit();", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_io/src/sys/unix/tcp/socket.rs", "line": 114, "evidence": "let linger = unsafe { payload.assume_init() };", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_io/src/sys/unix/tcp/socket.rs", "line": 103, "evidence": "let mut payload: MaybeUninit<linger> = MaybeUninit::uninit();", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/unix/udp/socket.rs", "line": 46, "evidence": "inner: unsafe { net::UdpSocket::from_raw_fd(self.socket) },", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/unix/udp/socket.rs", "line": 63, "evidence": "unsafe fn from_raw_fd(fd: RawFd) -> UdpSock {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/unix/uds/listener.rs", "line": 62, "evidence": "let mut addr = unsafe { MaybeUninit::<libc::sockaddr_un>::zeroed().assume_init() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/unix/uds/listener.rs", "line": 75, "evidence": ".map(|socket| unsafe { net::UnixStream::from_raw_fd(socket) })?", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/unix/uds/listener.rs", "line": 86, "evidence": "let socket = unsafe { net::UnixStream::from_raw_fd(socket) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/unix/uds/listener.rs", "line": 71, "evidence": "(&mut addr as *mut libc::sockaddr_un).cast::<libc::sockaddr>(),", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/unix/uds/listener.rs", "line": 81, "evidence": "(&mut addr as *mut libc::sockaddr_un).cast::<libc::sockaddr>(),", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_io/src/sys/unix/uds/listener.rs", "line": 15, "evidence": "use std::mem::{self, MaybeUninit};", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_io/src/sys/unix/uds/listener.rs", "line": 62, "evidence": "let mut addr = unsafe { MaybeUninit::<libc::sockaddr_un>::zeroed().assume_init() };", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7999999999999999, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_io/src/sys/unix/uds/listener.rs", "line": 62, "evidence": "let mut addr = unsafe { MaybeUninit::<libc::sockaddr_un>::zeroed().assume_init() };", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/unix/uds/socket_addr.rs", "line": 30, "evidence": "let mut sockaddr = unsafe { sockaddr.assume_init() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/unix/uds/socket_addr.rs", "line": 21, "evidence": "let path = &sockaddr.sun_path as *const _ as usize;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/unix/uds/socket_addr.rs", "line": 22, "evidence": "let base = sockaddr as *const _ as usize;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_io/src/sys/unix/uds/socket_addr.rs", "line": 27, "evidence": "let sockaddr: std::mem::MaybeUninit<libc::sockaddr_un> =", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7999999999999999, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_io/src/sys/unix/uds/socket_addr.rs", "line": 28, "evidence": "std::mem::MaybeUninit::<libc::sockaddr_un>::zeroed();", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7999999999999999, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_io/src/sys/unix/uds/socket_addr.rs", "line": 30, "evidence": "let mut sockaddr = unsafe { sockaddr.assume_init() };", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7999999999999999, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_io/src/sys/unix/uds/socket_addr.rs", "line": 28, "evidence": "std::mem::MaybeUninit::<libc::sockaddr_un>::zeroed();", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/unix/uds/socket.rs", "line": 31, "evidence": "let net = unsafe { net::UnixListener::from_raw_fd(socket) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/unix/uds/socket.rs", "line": 45, "evidence": "let net = unsafe { net::UnixStream::from_raw_fd(socket) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/unix/uds/socket.rs", "line": 54, "evidence": "let net = unsafe { net::UnixDatagram::from_raw_fd(socket) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_io/src/sys/unix/uds/socket.rs", "line": 91, "evidence": "Ok(unsafe { (T::from_raw_fd(fds[0]), T::from_raw_fd(fds[1])) })", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/unix/uds/socket.rs", "line": 28, "evidence": "let socket_addr = (&socket_addr as *const libc::sockaddr_un).cast::<libc::sockaddr>();", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/unix/uds/socket.rs", "line": 42, "evidence": "let sockaddr = (&sockaddr as *const libc::sockaddr_un).cast::<libc::sockaddr>();", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_io/src/sys/unix/uds/socket.rs", "line": 60, "evidence": "let socket_addr = (&socket_addr as *const libc::sockaddr_un).cast::<libc::sockaddr>();", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_signal/src/common.rs", "line": 75, "evidence": "pub(super) unsafe fn register_action<F>(sig_num: c_int, handler: F) -> io::Result<()>", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_signal/src/common.rs", "line": 181, "evidence": "let res = unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_signal/src/common.rs", "line": 188, "evidence": "let res = unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_signal/src/common.rs", "line": 196, "evidence": "unsafe { libc::raise(libc::SIGINT) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_signal/src/common.rs", "line": 200, "evidence": "unsafe { libc::raise(libc::SIGTERM) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_signal/src/common.rs", "line": 209, "evidence": "let res = unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_signal/src/common.rs", "line": 216, "evidence": "unsafe { libc::raise(libc::SIGTERM) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_signal/src/common.rs", "line": 207, "evidence": "Signal::deregister_action(libc::SIGINT).unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_signal/src/unix.rs", "line": 25, "evidence": "let mut old_act: libc::sigaction = unsafe { mem::zeroed() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_signal/src/unix.rs", "line": 26, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_signal/src/unix.rs", "line": 40, "evidence": "let mut handler: libc::sigaction = unsafe { mem::zeroed() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_signal/src/unix.rs", "line": 41, "evidence": "let mut old_act: libc::sigaction = unsafe { mem::zeroed() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_signal/src/unix.rs", "line": 46, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_signal/src/unix.rs", "line": 65, "evidence": "unsafe { libc::abort() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_signal/src/unix.rs", "line": 68, "evidence": "let info = unsafe { &*sig_info };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_signal/src/unix.rs", "line": 101, "evidence": "let action = unsafe { mem::transmute::<usize, extern \" \" fn(c_int)>(handler) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_signal/src/unix.rs", "line": 105, "evidence": "let action = unsafe { mem::transmute::<usize, Action>(handler) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_signal/src/unix.rs", "line": 56, "evidence": "pub(crate) extern \" \" fn sig_handler(sig_num: c_int, sig_info: *mut siginfo_t, data: *mut c_void) {", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_signal/src/unix.rs", "line": 87, "evidence": "fn execute_act(act: &sigaction, sig_num: c_int, sig_info: *mut siginfo_t, data: *mut c_void) {", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_signal/src/unix.rs", "line": 104, "evidence": "type Action = extern \" \" fn(c_int, *mut siginfo_t, *mut c_void);", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "mem::transmute", "file": "ylong_signal/src/unix.rs", "line": 101, "evidence": "let action = unsafe { mem::transmute::<usize, extern \" \" fn(c_int)>(handler) };", "description": "使用 mem::transmute 进行类型转换，若未严格保证布局/对齐/生命周期，将导致未定义行为。", "suggestion": "避免使用 transmute，优先采用安全转换或 bytemuck 等受审计抽象；必须使用时严格注明不变式。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "mem::transmute", "file": "ylong_signal/src/unix.rs", "line": 105, "evidence": "let action = unsafe { mem::transmute::<usize, Action>(handler) };", "description": "使用 mem::transmute 进行类型转换，若未严格保证布局/对齐/生命周期，将导致未定义行为。", "suggestion": "避免使用 transmute，优先采用安全转换或 bytemuck 等受审计抽象；必须使用时严格注明不变式。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_signal/src/unix.rs", "line": 25, "evidence": "let mut old_act: libc::sigaction = unsafe { mem::zeroed() };", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_signal/src/unix.rs", "line": 40, "evidence": "let mut handler: libc::sigaction = unsafe { mem::zeroed() };", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "uninit/zeroed", "file": "ylong_signal/src/unix.rs", "line": 41, "evidence": "let mut old_act: libc::sigaction = unsafe { mem::zeroed() };", "description": "使用 uninit/zeroed 创建未初始化内存，若在初始化前读取将导致未定义行为。", "suggestion": "确保在使用前完成初始化；优先使用 MaybeUninit 进行更安全的未初始化内存管理。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_signal/src/windows.rs", "line": 25, "evidence": "let old_act = unsafe { libc::signal(sig_num, SIG_GET) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_signal/src/windows.rs", "line": 41, "evidence": "let old_act = unsafe { libc::signal(sig_num, new_action) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_signal/src/windows.rs", "line": 53, "evidence": "let old = unsafe { libc::signal(sig_num, sig_handler as usize) };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_signal/src/windows.rs", "line": 55, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_signal/src/windows.rs", "line": 86, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "mem::transmute", "file": "ylong_signal/src/windows.rs", "line": 87, "evidence": "let action = mem::transmute::<usize, extern \" \" fn(c_int)>(act);", "description": "使用 mem::transmute 进行类型转换，若未严格保证布局/对齐/生命周期，将导致未定义行为。", "suggestion": "避免使用 transmute，优先采用安全转换或 bytemuck 等受审计抽象；必须使用时严格注明不变式。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_signal/src/spin_rwlock.rs", "line": 71, "evidence": "unsafe { libc::abort() };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_signal/src/spin_rwlock.rs", "line": 91, "evidence": "let data = unsafe { &*data };", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_signal/src/spin_rwlock.rs", "line": 160, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_signal/src/spin_rwlock.rs", "line": 172, "evidence": "unsafe { &*data }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_signal/src/spin_rwlock.rs", "line": 101, "evidence": "let guard = self.write_lock.lock().unwrap();", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "from_raw_parts/from_raw", "file": "ylong_signal/src/spin_rwlock.rs", "line": 161, "evidence": "drop(Box::from_raw(old_data));", "description": "使用 from_raw_parts/from_raw 从原始指针构造，需确保指针有效性、对齐与生命周期安全。", "suggestion": "优先使用安全的构造函数；必须使用时，在 SAFETY 注释中证明所有前置条件（有效性/对齐/生命周期）。", "confidence": 0.85, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_signal/src/lib.rs", "line": 72, "evidence": "pub unsafe fn register_signal_action<F>(sig_num: c_int, handler: F) -> io::Result<()>", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "MaybeUninit/assume_init", "file": "ylong_signal/src/sig_map.rs", "line": 15, "evidence": "use std::mem::MaybeUninit;", "description": "使用 MaybeUninit/assume_init 需保证正确初始化与读取顺序，否则可能导致未定义行为。", "suggestion": "确保初始化前不读取；使用更安全的构造函数；在 SAFETY 注释中说明前置条件。", "confidence": 0.7, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/sys_event.rs", "line": 18, "evidence": "type FfrtSysEventHandleT = *mut c_void;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/sys_event.rs", "line": 19, "evidence": "type DestroyFunc = extern \" \" fn(*mut c_void);", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/sys_event.rs", "line": 20, "evidence": "type FfrtFdCallBack = extern \" \" fn(*const c_void, c_uint, c_uchar);", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/sys_event.rs", "line": 21, "evidence": "type FfrtExecHook = extern \" \" fn(*mut c_void);", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/sys_event.rs", "line": 22, "evidence": "type FfrtTimerHandle = *mut c_void;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/sys_event.rs", "line": 30, "evidence": "fn ffrt_sys_event_destroy(event: FfrtSysEventHandleT, func: DestroyFunc, arg: *mut c_void);", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/sys_event.rs", "line": 37, "evidence": "data: *const c_void,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/sys_event.rs", "line": 48, "evidence": "waker: *mut c_void,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_ffrt/src/task.rs", "line": 50, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_ffrt/src/task.rs", "line": 59, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_ffrt/src/task.rs", "line": 68, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_ffrt/src/task.rs", "line": 79, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_ffrt/src/task.rs", "line": 88, "evidence": "unsafe { ffrt_task_attr_get_qos(self as _) }", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "unsafe", "file": "ylong_ffrt/src/task.rs", "line": 94, "evidence": "unsafe {", "description": "存在 unsafe 代码块/标识，需证明内存/别名/生命周期安全性。", "suggestion": "将不安全操作封装在最小作用域内，并提供 SAFETY 注释说明前置条件与不变式。", "confidence": 0.8, "severity": "high"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/task.rs", "line": 20, "evidence": "type FfrtHook = extern \" \" fn(*mut c_void);", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/task.rs", "line": 22, "evidence": "type FfrtExecHook = extern \" \" fn(*mut c_void) -> FfrtRet;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/task.rs", "line": 24, "evidence": "type RawTaskCtx = *mut c_void;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/task.rs", "line": 49, "evidence": "let attr = self as *mut FfrtTaskAttr;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/task.rs", "line": 57, "evidence": "let attr_ptr = self as *mut FfrtTaskAttr;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/task.rs", "line": 67, "evidence": "let attr_ptr = self as *const FfrtTaskAttr;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/task.rs", "line": 80, "evidence": "let ptr = self as *mut FfrtTaskAttr;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/task.rs", "line": 105, "evidence": "fn ffrt_task_attr_init(attr: *mut FfrtTaskAttr);", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/task.rs", "line": 106, "evidence": "fn ffrt_task_attr_set_name(attr: *mut FfrtTaskAttr, name: *const c_char);", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/task.rs", "line": 107, "evidence": "fn ffrt_task_attr_get_name(attr: *const FfrtTaskAttr) -> *const c_char;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/task.rs", "line": 108, "evidence": "fn ffrt_task_attr_destroy(attr: *mut FfrtTaskAttr);", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/task.rs", "line": 109, "evidence": "fn ffrt_task_attr_set_qos(attr: *mut FfrtTaskAttr, qos: Qos);", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/task.rs", "line": 110, "evidence": "fn ffrt_task_attr_get_qos(attr: *const FfrtTaskAttr) -> Qos;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/task.rs", "line": 113, "evidence": "fn ffrt_alloc_auto_free_function_storage_base() -> *const c_void;", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/task.rs", "line": 118, "evidence": "data: *mut c_void,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/task.rs", "line": 124, "evidence": "in_deps: *const FfrtDeps,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/task.rs", "line": 126, "evidence": "out_deps: *const FfrtDeps,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/task.rs", "line": 128, "evidence": "attr: *const FfrtTaskAttr,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_ffrt/src/task.rs", "line": 58, "evidence": "let c_name = CString::new(name).expect(\"                             \");", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "error_handling", "pattern": "unwrap/expect", "file": "ylong_ffrt/src/task.rs", "line": 72, "evidence": ".expect(\"                             \")", "description": "直接 unwrap/expect 可能在错误条件下 panic，缺少健壮的错误处理路径。", "suggestion": "使用 ? 传播错误或 match 显式处理；为关键路径提供错误上下文与恢复策略。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "ffi", "pattern": "CString/CStr", "file": "ylong_ffrt/src/task.rs", "line": 14, "evidence": "use std::ffi::{CStr, CString};", "description": "FFI 中使用 CString/CStr 需要确保正确的生命周期管理与空字节处理。", "suggestion": "确保 CString 生命周期覆盖 FFI 调用期间；注意 CStr 不能包含内部空字节。", "confidence": 0.65, "severity": "medium"}
{"language": "rust", "category": "unsafe_usage", "pattern": "raw_pointer", "file": "ylong_ffrt/src/lib.rs", "line": 50, "evidence": "items: *const *const c_void,", "description": "出现原始指针（*mut/*const），可能绕过借用/生命周期检查，带来未定义行为风险。", "suggestion": "优先使用引用/智能指针；必须使用原始指针时，严格证明无别名、对齐与生命周期安全。", "confidence": 0.75, "severity": "medium"}
