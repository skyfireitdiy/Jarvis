{"language": "c/cpp", "category": "error_handling", "pattern": "io_call", "file": "frameworks/libhilog/hilog_printf.cpp", "line": 230, "evidence": "return TEMP_FAILURE_RETRY(write(fd, logInfo, strlen(logInfo)));", "confidence": 0.65, "severity": "medium", "gid": 4, "verify": "检查write系统调用的返回值是否被正确处理", "has_risk": true, "preconditions": "写入/dev/kmsg失败（如权限不足、设备不可用等）", "trigger_path": "调用路径推导：HiLogPrintArgs() -> LogToKmsg() -> write()。数据流：日志信息通过HiLogPrintArgs接收，当type为LOG_KMSG时传递给LogToKmsg，LogToKmsg格式化日志后直接调用write写入/dev/kmsg。关键调用点：HiLogPrintArgs和LogToKmsg都没有处理write的返回值。", "consequences": "日志写入失败不会被检测到，可能导致重要日志丢失且无法通知调用者", "suggestions": "1. 检查write返回值并处理错误情况；2. 考虑添加重试机制或备用日志路径；3. 向上层调用者返回适当的错误码", "verification_notes": "分析结论正确，前置条件合理（确实可能因权限不足或设备不可用导致写入失败），触发路径清晰（HiLogPrintArgs->LogToKmsg->write调用链成立），后果评估准确（write返回值未被处理确实会导致日志丢失且无错误通知），建议合适（应检查write返回值并考虑备用方案）"}
{"language": "c/cpp", "category": "error_handling", "pattern": "io_call", "file": "frameworks/libhilog/hilog_printf.cpp", "line": 232, "evidence": "return write(fd, logInfo, strlen(logInfo));", "confidence": 0.65, "severity": "medium", "gid": 5, "verify": "检查write系统调用的返回值是否被正确处理", "has_risk": true, "preconditions": "写入/dev/kmsg失败（如权限不足、设备不可用等）", "trigger_path": "调用路径推导：HiLogPrintArgs() -> LogToKmsg() -> write()。数据流：日志信息通过HiLogPrintArgs接收，当type为LOG_KMSG时传递给LogToKmsg，LogToKmsg格式化日志后直接调用write写入/dev/kmsg。关键调用点：HiLogPrintArgs和LogToKmsg都没有处理write的返回值。", "consequences": "日志写入失败不会被检测到，可能导致重要日志丢失且无法通知调用者", "suggestions": "1. 检查write返回值并处理错误情况；2. 考虑添加重试机制或备用日志路径；3. 向上层调用者返回适当的错误码", "verification_notes": "分析结论正确，前置条件合理（确实可能因权限不足或设备不可用导致写入失败），触发路径清晰（HiLogPrintArgs->LogToKmsg->write调用链成立），后果评估准确（write返回值未被处理确实会导致日志丢失且无错误通知），建议合适（应检查write返回值并考虑备用方案）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "wild_pointer_deref", "file": "frameworks/include/hilog_inner.h", "line": 28, "evidence": "const unsigned int, const unsigned int, const char *fmt, ...);", "confidence": 0.65, "severity": "high", "gid": 6, "verify": "验证函数调用时传入的const char *fmt指针是否非空", "has_risk": true, "preconditions": "调用 HiLogPrintDictNew 或 HiLogPrintComm 时传入空的 fmt 参数", "trigger_path": "调用路径推导：未知调用者 -> HiLogPrintDictNew/HiLogPrintComm -> HiLogPrintArgs -> vsnprintfp_s。数据流：fmt 参数从调用者传递到 HiLogPrintDictNew/HiLogPrintComm，再直接传递给 HiLogPrintArgs，最终在 vsnprintfp_s 中使用。关键调用点：HiLogPrintDictNew 和 HiLogPrintComm 未对 fmt 参数进行空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在 HiLogPrintDictNew 和 HiLogPrintComm 函数中添加 fmt 参数的非空检查", "verification_notes": "代码确认 HiLogPrintDictNew 和 HiLogPrintComm 函数均未对 fmt 参数进行空指针检查，直接传递给 HiLogPrintArgs 使用并在 vsnprintfp_s 中调用，存在空指针解引用风险。分析结论正确，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "wild_pointer_deref", "file": "frameworks/include/hilog_inner.h", "line": 30, "evidence": "const unsigned int, const unsigned int, const char *fmt, ...);", "confidence": 0.65, "severity": "high", "gid": 7, "verify": "验证函数调用时传入的const char *fmt指针是否非空", "has_risk": true, "preconditions": "调用 HiLogPrintDictNew 或 HiLogPrintComm 时传入空的 fmt 参数", "trigger_path": "调用路径推导：未知调用者 -> HiLogPrintDictNew/HiLogPrintComm -> HiLogPrintArgs -> vsnprintfp_s。数据流：fmt 参数从调用者传递到 HiLogPrintDictNew/HiLogPrintComm，再直接传递给 HiLogPrintArgs，最终在 vsnprintfp_s 中使用。关键调用点：HiLogPrintDictNew 和 HiLogPrintComm 未对 fmt 参数进行空指针检查。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在 HiLogPrintDictNew 和 HiLogPrintComm 函数中添加 fmt 参数的非空检查", "verification_notes": "代码确认 HiLogPrintDictNew 和 HiLogPrintComm 函数均未对 fmt 参数进行空指针检查，直接传递给 HiLogPrintArgs 使用并在 vsnprintfp_s 中调用，存在空指针解引用风险。分析结论正确，前置条件合理，触发路径清晰，后果评估准确，建议合适"}
{"language": "c/cpp", "category": "error_handling", "pattern": "io_call", "file": "frameworks/libhilog/socket/socket.cpp", "line": 88, "evidence": "return TEMP_FAILURE_RETRY(write(socketHandler, data, len));", "confidence": 0.65, "severity": "medium", "gid": 55, "verify": "验证IO系统调用(close/read/write)的错误处理是否正确，包括文件描述符有效性检查及返回值处理", "has_risk": true, "preconditions": "socketHandler为无效文件描述符（<=0）", "trigger_path": "调用路径推导：Write()/Read() -> write()/read()。数据流：socketHandler作为类成员变量，未在IO操作前验证其有效性。关键调用点：Write()和Read()函数未检查socketHandler的有效性就直接进行IO操作。", "consequences": "可能导致EBADF错误或程序崩溃", "suggestions": "在write()/read()调用前检查socketHandler是否为有效文件描述符（>0）", "verification_notes": "分析结论正确，Socket类的Write/Read方法确实缺少对socketHandler的有效性检查，可能导致EBADF错误"}
{"language": "c/cpp", "category": "error_handling", "pattern": "io_call", "file": "frameworks/libhilog/socket/socket.cpp", "line": 121, "evidence": "return TEMP_FAILURE_RETRY(read(socketHandler, buffer, len));", "confidence": 0.65, "severity": "medium", "gid": 57, "verify": "验证IO系统调用(close/read/write)的错误处理是否正确，包括文件描述符有效性检查及返回值处理", "has_risk": true, "preconditions": "socketHandler为无效文件描述符（<=0）", "trigger_path": "调用路径推导：Write()/Read() -> write()/read()。数据流：socketHandler作为类成员变量，未在IO操作前验证其有效性。关键调用点：Write()和Read()函数未检查socketHandler的有效性就直接进行IO操作。", "consequences": "可能导致EBADF错误或程序崩溃", "suggestions": "在write()/read()调用前检查socketHandler是否为有效文件描述符（>0）", "verification_notes": "分析结论正确，Socket类的Write/Read方法确实缺少对socketHandler的有效性检查，可能导致EBADF错误"}
{"language": "c/cpp", "category": "error_handling", "pattern": "io_call", "file": "frameworks/libhilog/socket/socket.cpp", "line": 150, "evidence": "close(socketHandler);", "confidence": 0.65, "severity": "medium", "gid": 59, "verify": "验证IO系统调用(close/read/write)的错误处理是否正确，包括文件描述符有效性检查及返回值处理", "has_risk": true, "preconditions": "socketHandler为无效文件描述符（<=0）", "trigger_path": "调用路径推导：~Socket() -> close(socketHandler)。数据流：socketHandler作为类成员变量，在析构时未验证其有效性。关键调用点：析构函数未检查socketHandler的有效性就直接调用close()。", "consequences": "可能导致EBADF错误", "suggestions": "在close()调用前检查socketHandler是否为有效文件描述符（>0）", "verification_notes": "分析结论正确，析构函数中未验证socketHandler有效性就直接调用close()，可能导致EBADF错误"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "alloc_no_null_check", "file": "frameworks/libhilog/param/properties.cpp", "line": 97, "evidence": "g_propResources = new PropRes[static_cast<int>(PropType::PROP_MAX)]{", "confidence": 0.65, "severity": "medium", "gid": 63, "verify": "验证new操作是否可能失败(抛出bad_alloc异常)以及是否有相应的异常处理机制", "has_risk": true, "preconditions": "系统内存不足导致 new 操作抛出 bad_alloc 异常", "trigger_path": "调用路径推导：所有 new 操作都是在静态初始化或静态变量中使用，没有显式的异常处理机制。数据流：程序启动时自动执行静态初始化，直接调用 new 操作分配内存。关键调用点：所有 new 操作都没有 try-catch 块捕获异常。", "consequences": "程序无法正常启动或运行，可能导致服务不可用", "suggestions": "1. 为关键 new 操作添加 try-catch 块捕获 bad_alloc 异常；2. 使用 std::nothrow 版本的 new 操作并检查返回值；3. 对于静态初始化，考虑使用懒加载模式", "verification_notes": "分析结论正确，代码中存在静态初始化中的new操作且无异常处理，内存不足会导致程序启动失败，建议的异常处理方案和懒加载模式合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "alloc_no_null_check", "file": "frameworks/libhilog/param/properties.cpp", "line": 304, "evidence": "static auto *switchCache = new SwitchCache(TextToBool, true, PropType::PROP_PRIVATE);", "confidence": 0.8, "severity": "high", "gid": 64, "verify": "验证new操作是否可能失败(抛出bad_alloc异常)以及是否有相应的异常处理机制", "has_risk": true, "preconditions": "系统内存不足导致 new 操作抛出 bad_alloc 异常", "trigger_path": "调用路径推导：所有 new 操作都是在静态初始化或静态变量中使用，没有显式的异常处理机制。数据流：程序启动时自动执行静态初始化，直接调用 new 操作分配内存。关键调用点：所有 new 操作都没有 try-catch 块捕获异常。", "consequences": "程序无法正常启动或运行，可能导致服务不可用", "suggestions": "1. 为关键 new 操作添加 try-catch 块捕获 bad_alloc 异常；2. 使用 std::nothrow 版本的 new 操作并检查返回值；3. 对于静态初始化，考虑使用懒加载模式", "verification_notes": "分析结论正确，代码中存在静态初始化中的new操作且无异常处理，内存不足会导致程序启动失败，建议的异常处理方案和懒加载模式合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "alloc_no_null_check", "file": "frameworks/libhilog/param/properties.cpp", "line": 313, "evidence": "static auto *switchCache = new SwitchCache(TextToBool, false, PropType::PROP_ONCE_DEBUG);", "confidence": 0.8, "severity": "high", "gid": 65, "verify": "验证new操作是否可能失败(抛出bad_alloc异常)以及是否有相应的异常处理机制", "has_risk": true, "preconditions": "系统内存不足导致 new 操作抛出 bad_alloc 异常", "trigger_path": "调用路径推导：所有 new 操作都是在静态初始化或静态变量中使用，没有显式的异常处理机制。数据流：程序启动时自动执行静态初始化，直接调用 new 操作分配内存。关键调用点：所有 new 操作都没有 try-catch 块捕获异常。", "consequences": "程序无法正常启动或运行，可能导致服务不可用", "suggestions": "1. 为关键 new 操作添加 try-catch 块捕获 bad_alloc 异常；2. 使用 std::nothrow 版本的 new 操作并检查返回值；3. 对于静态初始化，考虑使用懒加载模式", "verification_notes": "分析结论正确，代码中存在静态初始化中的new操作且无异常处理，内存不足会导致程序启动失败，建议的异常处理方案和懒加载模式合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "alloc_no_null_check", "file": "frameworks/libhilog/param/properties.cpp", "line": 322, "evidence": "static auto *switchCache = new SwitchCache(TextToBool, false, PropType::PROP_PERSIST_DEBUG);", "confidence": 0.8, "severity": "high", "gid": 66, "verify": "验证new操作是否可能失败(抛出bad_alloc异常)以及是否有相应的异常处理机制", "has_risk": true, "preconditions": "系统内存不足导致 new 操作抛出 bad_alloc 异常", "trigger_path": "调用路径推导：所有 new 操作都是在静态初始化或静态变量中使用，没有显式的异常处理机制。数据流：程序启动时自动执行静态初始化，直接调用 new 操作分配内存。关键调用点：所有 new 操作都没有 try-catch 块捕获异常。", "consequences": "程序无法正常启动或运行，可能导致服务不可用", "suggestions": "1. 为关键 new 操作添加 try-catch 块捕获 bad_alloc 异常；2. 使用 std::nothrow 版本的 new 操作并检查返回值；3. 对于静态初始化，考虑使用懒加载模式", "verification_notes": "分析结论正确，代码中存在静态初始化中的new操作且无异常处理，内存不足会导致程序启动失败，建议的异常处理方案和懒加载模式合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "alloc_no_null_check", "file": "frameworks/libhilog/param/properties.cpp", "line": 359, "evidence": "static auto *logLevelCache = new LogLevelCache(TextToLogLevel, LOG_LEVEL_MIN, PropType::PROP_GLOBAL_LOG_LEVEL);", "confidence": 0.8, "severity": "high", "gid": 67, "verify": "验证new操作是否可能失败(抛出bad_alloc异常)以及是否有相应的异常处理机制", "has_risk": true, "preconditions": "系统内存不足导致 new 操作抛出 bad_alloc 异常", "trigger_path": "调用路径推导：所有 new 操作都是在静态初始化或静态变量中使用，没有显式的异常处理机制。数据流：程序启动时自动执行静态初始化，直接调用 new 操作分配内存。关键调用点：所有 new 操作都没有 try-catch 块捕获异常。", "consequences": "程序无法正常启动或运行，可能导致服务不可用", "suggestions": "1. 为关键 new 操作添加 try-catch 块捕获 bad_alloc 异常；2. 使用 std::nothrow 版本的 new 操作并检查返回值；3. 对于静态初始化，考虑使用懒加载模式", "verification_notes": "分析结论正确，代码中存在静态初始化中的new操作且无异常处理，内存不足会导致程序启动失败，建议的异常处理方案和懒加载模式合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "alloc_no_null_check", "file": "frameworks/libhilog/param/properties.cpp", "line": 372, "evidence": "static shared_timed_mutex* levelMtx = new shared_timed_mutex;", "confidence": 0.65, "severity": "medium", "gid": 68, "verify": "验证new操作是否可能失败(抛出bad_alloc异常)以及是否有相应的异常处理机制", "has_risk": true, "preconditions": "系统内存不足导致 new 操作抛出 bad_alloc 异常", "trigger_path": "调用路径推导：所有 new 操作都是在静态初始化或静态变量中使用，没有显式的异常处理机制。数据流：程序启动时自动执行静态初始化，直接调用 new 操作分配内存。关键调用点：所有 new 操作都没有 try-catch 块捕获异常。", "consequences": "程序无法正常启动或运行，可能导致服务不可用", "suggestions": "1. 为关键 new 操作添加 try-catch 块捕获 bad_alloc 异常；2. 使用 std::nothrow 版本的 new 操作并检查返回值；3. 对于静态初始化，考虑使用懒加载模式", "verification_notes": "分析结论正确，代码中存在静态初始化中的new操作且无异常处理，内存不足会导致程序启动失败，建议的异常处理方案和懒加载模式合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "alloc_no_null_check", "file": "frameworks/libhilog/param/properties.cpp", "line": 385, "evidence": "LogLevelCache* levelCache = new LogLevelCache(TextToLogLevel, LOG_LEVEL_MIN, propType, Uint2HexStr(key));", "confidence": 0.65, "severity": "medium", "gid": 69, "verify": "验证new操作是否可能失败(抛出bad_alloc异常)以及是否有相应的异常处理机制", "has_risk": true, "preconditions": "系统内存不足导致 new 操作抛出 bad_alloc 异常", "trigger_path": "调用路径推导：所有 new 操作都是在静态初始化或静态变量中使用，没有显式的异常处理机制。数据流：程序启动时自动执行静态初始化，直接调用 new 操作分配内存。关键调用点：所有 new 操作都没有 try-catch 块捕获异常。", "consequences": "程序无法正常启动或运行，可能导致服务不可用", "suggestions": "1. 为关键 new 操作添加 try-catch 块捕获 bad_alloc 异常；2. 使用 std::nothrow 版本的 new 操作并检查返回值；3. 对于静态初始化，考虑使用懒加载模式", "verification_notes": "分析结论正确，代码中存在静态初始化中的new操作且无异常处理，内存不足会导致程序启动失败，建议的异常处理方案和懒加载模式合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "alloc_no_null_check", "file": "frameworks/libhilog/param/properties.cpp", "line": 399, "evidence": "static shared_timed_mutex* levelMtx = new shared_timed_mutex;", "confidence": 0.65, "severity": "medium", "gid": 70, "verify": "验证new操作是否可能失败(抛出bad_alloc异常)以及是否有相应的异常处理机制", "has_risk": true, "preconditions": "系统内存不足导致 new 操作抛出 bad_alloc 异常", "trigger_path": "调用路径推导：所有 new 操作都是在静态初始化或静态变量中使用，没有显式的异常处理机制。数据流：程序启动时自动执行静态初始化，直接调用 new 操作分配内存。关键调用点：所有 new 操作都没有 try-catch 块捕获异常。", "consequences": "程序无法正常启动或运行，可能导致服务不可用", "suggestions": "1. 为关键 new 操作添加 try-catch 块捕获 bad_alloc 异常；2. 使用 std::nothrow 版本的 new 操作并检查返回值；3. 对于静态初始化，考虑使用懒加载模式", "verification_notes": "分析结论正确，代码中存在静态初始化中的new操作且无异常处理，内存不足会导致程序启动失败，建议的异常处理方案和懒加载模式合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "alloc_no_null_check", "file": "frameworks/libhilog/param/properties.cpp", "line": 412, "evidence": "LogLevelCache* levelCache = new LogLevelCache(TextToLogLevel, LOG_LEVEL_MIN, propType, key);", "confidence": 0.65, "severity": "medium", "gid": 71, "verify": "验证new操作是否可能失败(抛出bad_alloc异常)以及是否有相应的异常处理机制", "has_risk": true, "preconditions": "系统内存不足导致 new 操作抛出 bad_alloc 异常", "trigger_path": "调用路径推导：所有 new 操作都是在静态初始化或静态变量中使用，没有显式的异常处理机制。数据流：程序启动时自动执行静态初始化，直接调用 new 操作分配内存。关键调用点：所有 new 操作都没有 try-catch 块捕获异常。", "consequences": "程序无法正常启动或运行，可能导致服务不可用", "suggestions": "1. 为关键 new 操作添加 try-catch 块捕获 bad_alloc 异常；2. 使用 std::nothrow 版本的 new 操作并检查返回值；3. 对于静态初始化，考虑使用懒加载模式", "verification_notes": "分析结论正确，代码中存在静态初始化中的new操作且无异常处理，内存不足会导致程序启动失败，建议的异常处理方案和懒加载模式合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "alloc_no_null_check", "file": "frameworks/libhilog/param/properties.cpp", "line": 426, "evidence": "static auto *domainMap = new std::unordered_map<uint32_t, LogLevelCache*>();", "confidence": 0.65, "severity": "medium", "gid": 72, "verify": "验证new操作是否可能失败(抛出bad_alloc异常)以及是否有相应的异常处理机制", "has_risk": true, "preconditions": "系统内存不足导致 new 操作抛出 bad_alloc 异常", "trigger_path": "调用路径推导：所有 new 操作都是在静态初始化或静态变量中使用，没有显式的异常处理机制。数据流：程序启动时自动执行静态初始化，直接调用 new 操作分配内存。关键调用点：所有 new 操作都没有 try-catch 块捕获异常。", "consequences": "程序无法正常启动或运行，可能导致服务不可用", "suggestions": "1. 为关键 new 操作添加 try-catch 块捕获 bad_alloc 异常；2. 使用 std::nothrow 版本的 new 操作并检查返回值；3. 对于静态初始化，考虑使用懒加载模式", "verification_notes": "分析结论正确，代码中存在静态初始化中的new操作且无异常处理，内存不足会导致程序启动失败，建议的异常处理方案和懒加载模式合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "alloc_no_null_check", "file": "frameworks/libhilog/param/properties.cpp", "line": 432, "evidence": "static auto *persistDomainMap = new std::unordered_map<uint32_t, LogLevelCache*>();", "confidence": 0.65, "severity": "medium", "gid": 73, "verify": "验证new操作是否可能失败(抛出bad_alloc异常)以及是否有相应的异常处理机制", "has_risk": true, "preconditions": "系统内存不足导致 new 操作抛出 bad_alloc 异常", "trigger_path": "调用路径推导：所有 new 操作都是在静态初始化或静态变量中使用，没有显式的异常处理机制。数据流：程序启动时自动执行静态初始化，直接调用 new 操作分配内存。关键调用点：所有 new 操作都没有 try-catch 块捕获异常。", "consequences": "程序无法正常启动或运行，可能导致服务不可用", "suggestions": "1. 为关键 new 操作添加 try-catch 块捕获 bad_alloc 异常；2. 使用 std::nothrow 版本的 new 操作并检查返回值；3. 对于静态初始化，考虑使用懒加载模式", "verification_notes": "分析结论正确，代码中存在静态初始化中的new操作且无异常处理，内存不足会导致程序启动失败，建议的异常处理方案和懒加载模式合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "alloc_no_null_check", "file": "frameworks/libhilog/param/properties.cpp", "line": 438, "evidence": "static auto *tagMap = new std::unordered_map<std::string, LogLevelCache*>();", "confidence": 0.65, "severity": "medium", "gid": 74, "verify": "验证new操作是否可能失败(抛出bad_alloc异常)以及是否有相应的异常处理机制", "has_risk": true, "preconditions": "系统内存不足导致 new 操作抛出 bad_alloc 异常", "trigger_path": "调用路径推导：所有 new 操作都是在静态初始化或静态变量中使用，没有显式的异常处理机制。数据流：程序启动时自动执行静态初始化，直接调用 new 操作分配内存。关键调用点：所有 new 操作都没有 try-catch 块捕获异常。", "consequences": "程序无法正常启动或运行，可能导致服务不可用", "suggestions": "1. 为关键 new 操作添加 try-catch 块捕获 bad_alloc 异常；2. 使用 std::nothrow 版本的 new 操作并检查返回值；3. 对于静态初始化，考虑使用懒加载模式", "verification_notes": "分析结论正确，代码中存在静态初始化中的new操作且无异常处理，内存不足会导致程序启动失败，建议的异常处理方案和懒加载模式合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "alloc_no_null_check", "file": "frameworks/libhilog/param/properties.cpp", "line": 444, "evidence": "static auto *persistTagMap = new std::unordered_map<std::string, LogLevelCache*>();", "confidence": 0.65, "severity": "medium", "gid": 75, "verify": "验证new操作是否可能失败(抛出bad_alloc异常)以及是否有相应的异常处理机制", "has_risk": true, "preconditions": "系统内存不足导致 new 操作抛出 bad_alloc 异常", "trigger_path": "调用路径推导：所有 new 操作都是在静态初始化或静态变量中使用，没有显式的异常处理机制。数据流：程序启动时自动执行静态初始化，直接调用 new 操作分配内存。关键调用点：所有 new 操作都没有 try-catch 块捕获异常。", "consequences": "程序无法正常启动或运行，可能导致服务不可用", "suggestions": "1. 为关键 new 操作添加 try-catch 块捕获 bad_alloc 异常；2. 使用 std::nothrow 版本的 new 操作并检查返回值；3. 对于静态初始化，考虑使用懒加载模式", "verification_notes": "分析结论正确，代码中存在静态初始化中的new操作且无异常处理，内存不足会导致程序启动失败，建议的异常处理方案和懒加载模式合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "alloc_no_null_check", "file": "frameworks/libhilog/param/properties.cpp", "line": 451, "evidence": "static auto *switchCache = new SwitchCache(TextToBool, false, PropType::PROP_PROCESS_FLOWCTRL);", "confidence": 0.8, "severity": "high", "gid": 76, "verify": "验证new操作是否可能失败(抛出bad_alloc异常)以及是否有相应的异常处理机制", "has_risk": true, "preconditions": "系统内存不足导致 new 操作抛出 bad_alloc 异常", "trigger_path": "调用路径推导：所有 new 操作都是在静态初始化或静态变量中使用，没有显式的异常处理机制。数据流：程序启动时自动执行静态初始化，直接调用 new 操作分配内存。关键调用点：所有 new 操作都没有 try-catch 块捕获异常。", "consequences": "程序无法正常启动或运行，可能导致服务不可用", "suggestions": "1. 为关键 new 操作添加 try-catch 块捕获 bad_alloc 异常；2. 使用 std::nothrow 版本的 new 操作并检查返回值；3. 对于静态初始化，考虑使用懒加载模式", "verification_notes": "分析结论正确，代码中存在静态初始化中的new操作且无异常处理，内存不足会导致程序启动失败，建议的异常处理方案和懒加载模式合理"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "alloc_no_null_check", "file": "frameworks/libhilog/param/properties.cpp", "line": 460, "evidence": "static auto *switchCache = new SwitchCache(TextToBool, false, PropType::PROP_DOMAIN_FLOWCTRL);", "confidence": 0.8, "severity": "high", "gid": 77, "verify": "验证new操作是否可能失败(抛出bad_alloc异常)以及是否有相应的异常处理机制", "has_risk": true, "preconditions": "系统内存不足导致 new 操作抛出 bad_alloc 异常", "trigger_path": "调用路径推导：所有 new 操作都是在静态初始化或静态变量中使用，没有显式的异常处理机制。数据流：程序启动时自动执行静态初始化，直接调用 new 操作分配内存。关键调用点：所有 new 操作都没有 try-catch 块捕获异常。", "consequences": "程序无法正常启动或运行，可能导致服务不可用", "suggestions": "1. 为关键 new 操作添加 try-catch 块捕获 bad_alloc 异常；2. 使用 std::nothrow 版本的 new 操作并检查返回值；3. 对于静态初始化，考虑使用懒加载模式", "verification_notes": "分析结论正确，代码中存在静态初始化中的new操作且无异常处理，内存不足会导致程序启动失败，建议的异常处理方案和懒加载模式合理"}
{"language": "c/cpp", "category": "error_handling", "pattern": "io_call", "file": "frameworks/libhilog/socket/include/socket.h", "line": 41, "evidence": "int Read(char *buffer, unsigned int len);", "confidence": 0.65, "severity": "medium", "gid": 113, "verify": "检查IO操作函数的返回值是否被正确处理，以及指针参数是否有效", "has_risk": true, "preconditions": "调用者传入nullptr作为buffer参数或socketHandler无效", "trigger_path": "调用路径推导：外部调用者 -> Socket::Read()。数据流：外部调用者直接调用Read()函数，未对buffer指针和socketHandler有效性进行检查。关键调用点：Read()函数内部未对buffer指针和socketHandler进行校验。", "consequences": "可能导致空指针解引用或无效socket操作", "suggestions": "1. 在Read()函数中添加buffer指针null检查；2. 添加socketHandler有效性检查", "verification_notes": "分析结论正确，Read()函数确实未对buffer指针和socketHandler进行校验（代码119-122行），外部可直接调用且无调用链保护（记忆2确认），可能导致空指针解引用或无效socket操作，添加null检查和有效性检查的建议合理"}
{"language": "c/cpp", "category": "error_handling", "pattern": "io_call", "file": "services/hilogd/service_controller.cpp", "line": 998, "evidence": "fread(&info, sizeof(PersistRecoveryInfo), 1, infile);", "confidence": 0.65, "severity": "medium", "gid": 119, "verify": "检查fread操作的返回值是否被正确处理", "has_risk": true, "preconditions": "读取的日志恢复信息文件可能损坏或包含恶意构造的数据", "trigger_path": "调用路径推导：main() -> RestorePersistJobs()。数据流：从文件系统读取日志恢复信息文件，通过fopen打开后直接传递给fread。关键调用点：RestorePersistJobs()函数未检查fread返回值，可能导致使用未初始化的内存数据。", "consequences": "可能使用未初始化的内存数据，导致程序异常行为或信息泄露", "suggestions": "1. 检查fread返回值确保读取成功；2. 添加文件完整性校验；3. 对读取失败的情况进行错误处理", "verification_notes": "分析结论正确，代码中确实存在未检查fread返回值的风险点（行998），前置条件合理（文件可能损坏或被篡改），触发路径清晰（main->RestorePersistJobs），后果评估准确（可能使用未初始化内存导致异常或信息泄露），建议恰当（检查返回值、添加校验和错误处理）"}
{"language": "c/cpp", "category": "buffer_overflow", "pattern": "string_bounds_check", "file": "services/hilogd/service_controller.cpp", "line": 558, "evidence": "if (rqst.fileName[0] && IsValidFileName(rqst.fileName) == false) {", "confidence": 0.6, "severity": "medium", "gid": 181, "verify": "确认IsValidFileName函数是否能有效防止路径遍历等攻击", "has_risk": true, "preconditions": "用户提供包含路径遍历字符（如../）或特殊字符的文件名", "trigger_path": "调用路径推导：HandleOutputRqst() -> CheckPersistStartRqst() -> IsValidFileName()。数据流：从socket接收PersistStartRqst请求，包含fileName字段，CheckPersistStartRqst()调用IsValidFileName()进行验证。关键调用点：IsValidFileName()仅检查部分特殊字符，未完全防止路径遍历。", "consequences": "可能导致路径遍历攻击，允许写入非预期目录", "suggestions": "1. 添加对`.`和`..`的检查；2. 拒绝绝对路径；3. 限制文件名长度；4. 检查文件名是否为空或仅包含空格", "verification_notes": "分析结论正确，前置条件合理，触发路径清晰（HandleOutputRqst->CheckPersistStartRqst->IsValidFileName），后果评估准确（路径遍历风险确实存在），建议措施恰当"}
{"language": "c/cpp", "category": "error_handling", "pattern": "io_call", "file": "services/hilogd/log_persister_rotator.cpp", "line": 61, "evidence": "m_infoFile.close();", "confidence": 0.65, "severity": "medium", "gid": 225, "verify": "检查IO操作(open/close/write)是否失败并正确处理错误", "has_risk": true, "preconditions": "文件IO操作失败（如磁盘空间不足、权限问题等）", "trigger_path": "调用路径推导：1) 对于m_infoFile操作：通过Init() -> OpenInfoFile()路径调用；2) 对于m_currentLogOutput操作：通过Input() -> CreateLogFile()路径调用或Rotate() -> CreateLogFile()调用。数据流：所有IO操作都缺乏错误处理。关键调用点：所有文件操作函数都未检查操作返回值或状态。", "consequences": "可能导致数据丢失、文件损坏或程序异常行为", "suggestions": "1) 检查所有IO操作的返回值或状态；2) 添加适当的错误处理逻辑；3) 记录错误日志以便诊断问题", "verification_notes": "分析结论正确，前置条件合理（确实存在文件IO操作失败的风险），触发路径成立（通过Init()->OpenInfoFile()和Input()->CreateLogFile()路径调用），后果评估准确（可能导致数据丢失或程序异常），建议合适（应添加错误处理逻辑）"}
{"language": "c/cpp", "category": "error_handling", "pattern": "io_call", "file": "services/hilogd/log_persister_rotator.cpp", "line": 90, "evidence": "m_infoFile.open(m_infoFilePath, std::ios::binary | std::ios::out | std::ios::trunc);", "confidence": 0.65, "severity": "medium", "gid": 226, "verify": "检查IO操作(open/close/write)是否失败并正确处理错误", "has_risk": true, "preconditions": "文件IO操作失败（如磁盘空间不足、权限问题等）", "trigger_path": "调用路径推导：1) 对于m_infoFile操作：通过Init() -> OpenInfoFile()路径调用；2) 对于m_currentLogOutput操作：通过Input() -> CreateLogFile()路径调用或Rotate() -> CreateLogFile()调用。数据流：所有IO操作都缺乏错误处理。关键调用点：所有文件操作函数都未检查操作返回值或状态。", "consequences": "可能导致数据丢失、文件损坏或程序异常行为", "suggestions": "1) 检查所有IO操作的返回值或状态；2) 添加适当的错误处理逻辑；3) 记录错误日志以便诊断问题", "verification_notes": "分析结论正确，前置条件合理（确实存在文件IO操作失败的风险），触发路径成立（通过Init()->OpenInfoFile()和Input()->CreateLogFile()路径调用），后果评估准确（可能导致数据丢失或程序异常），建议合适（应添加错误处理逻辑）"}
{"language": "c/cpp", "category": "error_handling", "pattern": "io_call", "file": "services/hilogd/log_persister_rotator.cpp", "line": 105, "evidence": "m_currentLogOutput.write(buf, length);", "confidence": 0.65, "severity": "medium", "gid": 227, "verify": "检查IO操作(open/close/write)是否失败并正确处理错误", "has_risk": true, "preconditions": "文件IO操作失败（如磁盘空间不足、权限问题等）", "trigger_path": "调用路径推导：1) 对于m_infoFile操作：通过Init() -> OpenInfoFile()路径调用；2) 对于m_currentLogOutput操作：通过Input() -> CreateLogFile()路径调用或Rotate() -> CreateLogFile()调用。数据流：所有IO操作都缺乏错误处理。关键调用点：所有文件操作函数都未检查操作返回值或状态。", "consequences": "可能导致数据丢失、文件损坏或程序异常行为", "suggestions": "1) 检查所有IO操作的返回值或状态；2) 添加适当的错误处理逻辑；3) 记录错误日志以便诊断问题", "verification_notes": "分析结论正确，前置条件合理（确实存在文件IO操作失败的风险），触发路径成立（通过Init()->OpenInfoFile()和Input()->CreateLogFile()路径调用），后果评估准确（可能导致数据丢失或程序异常），建议合适（应添加错误处理逻辑）"}
{"language": "c/cpp", "category": "error_handling", "pattern": "io_call", "file": "services/hilogd/log_persister_rotator.cpp", "line": 154, "evidence": "m_currentLogOutput.close();", "confidence": 0.65, "severity": "medium", "gid": 228, "verify": "检查IO操作(open/close/write)是否失败并正确处理错误", "has_risk": true, "preconditions": "文件IO操作失败（如磁盘空间不足、权限问题等）", "trigger_path": "调用路径推导：1) 对于m_infoFile操作：通过Init() -> OpenInfoFile()路径调用；2) 对于m_currentLogOutput操作：通过Input() -> CreateLogFile()路径调用或Rotate() -> CreateLogFile()调用。数据流：所有IO操作都缺乏错误处理。关键调用点：所有文件操作函数都未检查操作返回值或状态。", "consequences": "可能导致数据丢失、文件损坏或程序异常行为", "suggestions": "1) 检查所有IO操作的返回值或状态；2) 添加适当的错误处理逻辑；3) 记录错误日志以便诊断问题", "verification_notes": "分析结论正确，前置条件合理（确实存在文件IO操作失败的风险），触发路径成立（通过Init()->OpenInfoFile()和Input()->CreateLogFile()路径调用），后果评估准确（可能导致数据丢失或程序异常），建议合适（应添加错误处理逻辑）"}
{"language": "c/cpp", "category": "error_handling", "pattern": "io_call", "file": "services/hilogd/log_persister_rotator.cpp", "line": 156, "evidence": "m_currentLogOutput.open(newFile.str(), std::ios::out | std::ios::trunc);", "confidence": 0.65, "severity": "medium", "gid": 229, "verify": "检查IO操作(open/close/write)是否失败并正确处理错误", "has_risk": true, "preconditions": "文件IO操作失败（如磁盘空间不足、权限问题等）", "trigger_path": "调用路径推导：1) 对于m_infoFile操作：通过Init() -> OpenInfoFile()路径调用；2) 对于m_currentLogOutput操作：通过Input() -> CreateLogFile()路径调用或Rotate() -> CreateLogFile()调用。数据流：所有IO操作都缺乏错误处理。关键调用点：所有文件操作函数都未检查操作返回值或状态。", "consequences": "可能导致数据丢失、文件损坏或程序异常行为", "suggestions": "1) 检查所有IO操作的返回值或状态；2) 添加适当的错误处理逻辑；3) 记录错误日志以便诊断问题", "verification_notes": "分析结论正确，前置条件合理（确实存在文件IO操作失败的风险），触发路径成立（通过Init()->OpenInfoFile()和Input()->CreateLogFile()路径调用），后果评估准确（可能导致数据丢失或程序异常），建议合适（应添加错误处理逻辑）"}
{"language": "c/cpp", "category": "error_handling", "pattern": "io_call", "file": "services/hilogd/log_persister_rotator.cpp", "line": 169, "evidence": "m_currentLogOutput.close();", "confidence": 0.65, "severity": "medium", "gid": 230, "verify": "检查IO操作(open/close/write)是否失败并正确处理错误", "has_risk": true, "preconditions": "文件IO操作失败（如磁盘空间不足、权限问题等）", "trigger_path": "调用路径推导：1) 对于m_infoFile操作：通过Init() -> OpenInfoFile()路径调用；2) 对于m_currentLogOutput操作：通过Input() -> CreateLogFile()路径调用或Rotate() -> CreateLogFile()调用。数据流：所有IO操作都缺乏错误处理。关键调用点：所有文件操作函数都未检查操作返回值或状态。", "consequences": "可能导致数据丢失、文件损坏或程序异常行为", "suggestions": "1) 检查所有IO操作的返回值或状态；2) 添加适当的错误处理逻辑；3) 记录错误日志以便诊断问题", "verification_notes": "分析结论正确，前置条件合理（确实存在文件IO操作失败的风险），触发路径成立（通过Init()->OpenInfoFile()和Input()->CreateLogFile()路径调用），后果评估准确（可能导致数据丢失或程序异常），建议合适（应添加错误处理逻辑）"}
{"language": "c/cpp", "category": "thread_safety", "pattern": "time_api_not_threadsafe", "file": "services/hilogd/log_persister_rotator.cpp", "line": 144, "evidence": "struct tm *tmNow = localtime(&tnow);", "confidence": 0.6, "severity": "medium", "gid": 231, "verify": "检查是否使用了线程安全的替代方案替代localtime()", "has_risk": true, "preconditions": "LogPersisterRotator在多线程环境下被调用", "trigger_path": "调用路径推导：LogPersisterRotator::CreateLogFile() -> localtime()。数据流：time(nullptr)获取当前时间，传递给localtime()。关键调用点：CreateLogFile()函数直接使用非线程安全的localtime()函数处理时间数据。", "consequences": "在多线程环境下可能导致时间数据错误或程序崩溃", "suggestions": "应改用线程安全的localtime_r()函数替代localtime()", "verification_notes": "分析结论正确，记忆信息确认了LogPersisterRotator::CreateLogFile()中使用非线程安全的localtime()，调用路径与触发路径一致，多线程环境下确实可能导致时间数据错误或程序崩溃，建议使用localtime_r()替代是合理的"}
{"language": "c/cpp", "category": "error_handling", "pattern": "io_call", "file": "services/hilogd/log_kmsg.cpp", "line": 153, "evidence": "close(kmsgCtl);", "confidence": 0.65, "severity": "medium", "gid": 237, "verify": "验证close(kmsgCtl)的返回值是否被检查", "has_risk": true, "preconditions": "kmsgCtl文件描述符有效且未被关闭", "trigger_path": "调用路径推导：LogKmsg对象析构 -> ~LogKmsg() -> close(kmsgCtl)。数据流：kmsgCtl通过GetControlFile()或open()获取，在析构函数中直接关闭。关键调用点：~LogKmsg()未检查close()返回值。", "consequences": "可能导致文件描述符泄漏或错误状态未被正确处理", "suggestions": "检查close()返回值并记录错误日志，或使用RAII包装器管理文件描述符", "verification_notes": "分析结论正确，kmsgCtl文件描述符管理确实存在风险，析构函数中直接调用close()未检查返回值，可能导致文件描述符泄漏"}
{"language": "c/cpp", "category": "error_handling", "pattern": "io_call", "file": "services/hilogd/main.cpp", "line": 57, "evidence": "close(g_fd);", "confidence": 0.65, "severity": "medium", "gid": 240, "verify": "验证文件描述符关闭操作(close)是否正确处理错误情况", "has_risk": true, "preconditions": "文件描述符关闭操作(close)返回错误", "trigger_path": "调用路径推导：1) gid 240: 信号处理路径(SIGINT信号) -> SigHandler() -> close(g_fd)；2) gid 241: WriteStringToFile() -> WaitingToDo() -> close(fd)；3) gid 242: WriteStringToFile() -> close(fd)。数据流：文件描述符通过open/dup2等系统调用获取，传递给close操作。关键调用点：所有close操作均未检查返回值。", "consequences": "可能导致文件描述符泄漏或资源未正确释放", "suggestions": "在close操作后添加错误处理逻辑，至少记录错误日志；对于关键文件描述符，应考虑重试机制或更严格的错误处理", "verification_notes": "分析结论正确，前置条件合理（close操作确实未检查返回值），触发路径清晰（通过信号处理和文件写入路径触发），后果评估准确（确实可能导致文件描述符泄漏），建议合适（应添加错误处理）"}
{"language": "c/cpp", "category": "error_handling", "pattern": "io_call", "file": "services/hilogd/main.cpp", "line": 86, "evidence": "close(fd);", "confidence": 0.65, "severity": "medium", "gid": 241, "verify": "验证文件描述符关闭操作(close)是否正确处理错误情况", "has_risk": true, "preconditions": "文件描述符关闭操作(close)返回错误", "trigger_path": "调用路径推导：1) gid 240: 信号处理路径(SIGINT信号) -> SigHandler() -> close(g_fd)；2) gid 241: WriteStringToFile() -> WaitingToDo() -> close(fd)；3) gid 242: WriteStringToFile() -> close(fd)。数据流：文件描述符通过open/dup2等系统调用获取，传递给close操作。关键调用点：所有close操作均未检查返回值。", "consequences": "可能导致文件描述符泄漏或资源未正确释放", "suggestions": "在close操作后添加错误处理逻辑，至少记录错误日志；对于关键文件描述符，应考虑重试机制或更严格的错误处理", "verification_notes": "分析结论正确，前置条件合理（close操作确实未检查返回值），触发路径清晰（通过信号处理和文件写入路径触发），后果评估准确（确实可能导致文件描述符泄漏），建议合适（应添加错误处理）"}
{"language": "c/cpp", "category": "error_handling", "pattern": "io_call", "file": "services/hilogd/main.cpp", "line": 103, "evidence": "close(fd);", "confidence": 0.65, "severity": "medium", "gid": 242, "verify": "验证文件描述符关闭操作(close)是否正确处理错误情况", "has_risk": true, "preconditions": "文件描述符关闭操作(close)返回错误", "trigger_path": "调用路径推导：1) gid 240: 信号处理路径(SIGINT信号) -> SigHandler() -> close(g_fd)；2) gid 241: WriteStringToFile() -> WaitingToDo() -> close(fd)；3) gid 242: WriteStringToFile() -> close(fd)。数据流：文件描述符通过open/dup2等系统调用获取，传递给close操作。关键调用点：所有close操作均未检查返回值。", "consequences": "可能导致文件描述符泄漏或资源未正确释放", "suggestions": "在close操作后添加错误处理逻辑，至少记录错误日志；对于关键文件描述符，应考虑重试机制或更严格的错误处理", "verification_notes": "分析结论正确，前置条件合理（close操作确实未检查返回值），触发路径清晰（通过信号处理和文件写入路径触发），后果评估准确（确实可能导致文件描述符泄漏），建议合适（应添加错误处理）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "services/hilogtool/main.cpp", "line": 1170, "evidence": "int ret = cmdEntry->handler(context, cmdArgs.c_str());", "confidence": 0.6, "severity": "high", "gid": 331, "verify": "验证cmdEntry指针在解引用前是否非空", "has_risk": true, "preconditions": "GetOptEntry()函数返回NULL时，cmdEntry会被设置为NULL", "trigger_path": "调用路径推导：main() -> HilogEntry() -> getopt_long()处理 -> cmdEntry赋值。数据流：argv参数通过main()传入，经过getopt_long()处理后，cmdEntry可能被GetOptEntry()结果覆盖。关键调用点：GetOptEntry()可能返回NULL，但后续没有对cmdEntry进行空指针检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在1170行前添加空指针检查：if (cmdEntry == nullptr) { return ERR_INVALID_CMD; }，或确保GetOptEntry()永远不会返回NULL", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "data_race_suspect", "file": "services/hilogd/include/log_persister.h", "line": 58, "evidence": "static void Clear();", "confidence": 0.5, "severity": "medium", "gid": 366, "verify": "验证静态方法是否在多线程环境下被调用且没有适当的同步机制", "has_risk": true, "preconditions": "多线程环境下同时调用Clear()方法", "trigger_path": "调用路径推导：外部调用者 -> LogPersister::Clear()。数据流：无明确输入参数，直接操作文件系统。关键调用点：Clear()方法未使用任何同步机制保护文件操作。", "consequences": "可能导致文件系统操作冲突或文件删除异常", "suggestions": "在Clear()方法中添加互斥锁保护文件操作，或确保该方法仅在单线程环境下调用", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "concurrency", "pattern": "volatile_not_threadsafe", "file": "services/hilogd/include/log_persister.h", "line": 96, "evidence": "volatile bool m_stopThread = false;", "confidence": 0.7, "severity": "high", "gid": 367, "verify": "验证volatile变量在多线程环境下的访问是否没有适当的同步机制", "has_risk": true, "preconditions": "多线程环境下同时读写m_stopThread变量", "trigger_path": "调用路径推导：多线程环境 -> LogPersister类成员函数 -> 直接访问m_stopThread。数据流：该变量在log_persister.cpp中被多个线程直接访问(339行和405行)，且未使用互斥锁或其他同步机制保护。关键调用点：在多线程环境中直接访问volatile变量而未加锁。", "consequences": "可能导致数据竞争和未定义行为，线程同步问题", "suggestions": "将m_stopThread改为std::atomic<bool>类型或使用互斥锁保护所有访问", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "type_safety", "pattern": "reinterpret_cast_unsafe", "file": "services/hilogd/include/service_controller.h", "line": 113, "evidence": "T *rqst = reinterpret_cast<T *>(data);", "confidence": 0.7999999999999999, "severity": "high", "gid": 370, "verify": "验证 reinterpret_cast<T*> 转换的安全性", "has_risk": true, "preconditions": "传入的hdr.len小于sizeof(T)或数据缓冲区与T类型不对齐", "trigger_path": "调用路径推导：外部调用 -> RequestHandler -> reinterpret_cast。数据流：从外部调用传入MsgHeader和回调函数，RequestHandler根据hdr.len创建缓冲区，通过GetRqst获取数据后直接进行reinterpret_cast转换。关键调用点：RequestHandler未验证hdr.len是否足够容纳T类型数据，GetRqst函数实现未找到无法确认其安全检查。", "consequences": "缓冲区溢出或类型不对齐导致未定义行为，可能引发程序崩溃或内存破坏", "suggestions": "1) 在转换前验证hdr.len >= sizeof(T); 2) 确保数据缓冲区与T类型对齐; 3) 添加类型安全检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/ets/ani/hilog/src/hilog_ani_base.cpp", "line": 131, "evidence": "if (ANI_OK != env->Array_GetLength(args, &length)) {", "confidence": 0.6, "severity": "high", "gid": 379, "verify": "env指针在调用Array_GetLength和Array_Get_Ref前必须非空", "has_risk": true, "preconditions": "env指针为nullptr", "trigger_path": "调用路径推导：HilogAniBase::Debug/Info/Warn/Error/Fatal() -> HilogAniBase::HilogImpl()。数据流：env指针作为参数从外部传入，通过Debug/Info/Warn/Error/Fatal方法传递给HilogImpl方法。关键调用点：HilogImpl方法直接使用env指针调用Array_GetLength和Array_Get_Ref，未进行非空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在HilogImpl方法开始处添加对env指针的非空检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/ets/ani/hilog/src/hilog_ani_base.cpp", "line": 143, "evidence": "if (ANI_OK != env->Array_Get_Ref(static_cast<ani_array_ref>(args), i, &element)) {", "confidence": 0.6, "severity": "high", "gid": 380, "verify": "env指针在调用Array_GetLength和Array_Get_Ref前必须非空", "has_risk": true, "preconditions": "env指针为nullptr", "trigger_path": "调用路径推导：HilogAniBase::Debug/Info/Warn/Error/Fatal() -> HilogAniBase::HilogImpl()。数据流：env指针作为参数从外部传入，通过Debug/Info/Warn/Error/Fatal方法传递给HilogImpl方法。关键调用点：HilogImpl方法直接使用env指针调用Array_GetLength和Array_Get_Ref，未进行非空检查。", "consequences": "空指针解引用，导致程序崩溃", "suggestions": "在HilogImpl方法开始处添加对env指针的非空检查", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "buffer_overflow", "pattern": "vector_bounds_check", "file": "interfaces/ets/ani/hilog/src/hilog_ani_base.cpp", "line": 60, "evidence": "if (params[contentPos.count].type == AniArgsType::ANI_INT ||", "confidence": 0.6, "severity": "medium", "gid": 381, "verify": "contentPos.count必须小于params数组的长度", "has_risk": true, "preconditions": "contentPos.count 的值大于等于 params 数组的长度", "trigger_path": "调用路径推导：HilogImpl() -> ParseLogContent() -> ProcessLogContent()。数据流：外部输入通过 HilogImpl 的参数 args 和 format 传入，args 被解析为 params 向量，format 转换为字符串后与 params 一起传递给 ParseLogContent。关键调用点：ParseLogContent 中虽然检查了 params.empty() 和 contentPos.count >= size，但 ProcessLogContent 内部直接使用 params[contentPos.count] 而没有边界检查。", "consequences": "数组越界访问，可能导致程序崩溃或信息泄露", "suggestions": "在 ProcessLogContent 函数内部添加对 contentPos.count 的边界检查，确保它小于 params.size()", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "buffer_overflow", "pattern": "vector_bounds_check", "file": "interfaces/ets/ani/hilog/src/hilog_ani_base.cpp", "line": 61, "evidence": "params[contentPos.count].type == AniArgsType::ANI_NUMBER ||", "confidence": 0.6, "severity": "medium", "gid": 382, "verify": "contentPos.count必须小于params数组的长度", "has_risk": true, "preconditions": "contentPos.count 的值大于等于 params 数组的长度", "trigger_path": "调用路径推导：HilogImpl() -> ParseLogContent() -> ProcessLogContent()。数据流：外部输入通过 HilogImpl 的参数 args 和 format 传入，args 被解析为 params 向量，format 转换为字符串后与 params 一起传递给 ParseLogContent。关键调用点：ParseLogContent 中虽然检查了 params.empty() 和 contentPos.count >= size，但 ProcessLogContent 内部直接使用 params[contentPos.count] 而没有边界检查。", "consequences": "数组越界访问，可能导致程序崩溃或信息泄露", "suggestions": "在 ProcessLogContent 函数内部添加对 contentPos.count 的边界检查，确保它小于 params.size()", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "buffer_overflow", "pattern": "vector_bounds_check", "file": "interfaces/ets/ani/hilog/src/hilog_ani_base.cpp", "line": 62, "evidence": "params[contentPos.count].type == AniArgsType::ANI_BIGINT) {", "confidence": 0.6, "severity": "medium", "gid": 383, "verify": "contentPos.count必须小于params数组的长度", "has_risk": true, "preconditions": "contentPos.count 的值大于等于 params 数组的长度", "trigger_path": "调用路径推导：HilogImpl() -> ParseLogContent() -> ProcessLogContent()。数据流：外部输入通过 HilogImpl 的参数 args 和 format 传入，args 被解析为 params 向量，format 转换为字符串后与 params 一起传递给 ParseLogContent。关键调用点：ParseLogContent 中虽然检查了 params.empty() 和 contentPos.count >= size，但 ProcessLogContent 内部直接使用 params[contentPos.count] 而没有边界检查。", "consequences": "数组越界访问，可能导致程序崩溃或信息泄露", "suggestions": "在 ProcessLogContent 函数内部添加对 contentPos.count 的边界检查，确保它小于 params.size()", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "buffer_overflow", "pattern": "vector_bounds_check", "file": "interfaces/ets/ani/hilog/src/hilog_ani_base.cpp", "line": 63, "evidence": "ret += isPriv ? PRIV_STR : params[contentPos.count].val;", "confidence": 0.6, "severity": "medium", "gid": 384, "verify": "contentPos.count必须小于params数组的长度", "has_risk": true, "preconditions": "contentPos.count 的值大于等于 params 数组的长度", "trigger_path": "调用路径推导：HilogImpl() -> ParseLogContent() -> ProcessLogContent()。数据流：外部输入通过 HilogImpl 的参数 args 和 format 传入，args 被解析为 params 向量，format 转换为字符串后与 params 一起传递给 ParseLogContent。关键调用点：ParseLogContent 中虽然检查了 params.empty() 和 contentPos.count >= size，但 ProcessLogContent 内部直接使用 params[contentPos.count] 而没有边界检查。", "consequences": "数组越界访问，可能导致程序崩溃或信息泄露", "suggestions": "在 ProcessLogContent 函数内部添加对 contentPos.count 的边界检查，确保它小于 params.size()", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "buffer_overflow", "pattern": "vector_bounds_check", "file": "interfaces/ets/ani/hilog/src/hilog_ani_base.cpp", "line": 69, "evidence": "if (params[contentPos.count].type == AniArgsType::ANI_STRING ||", "confidence": 0.6, "severity": "medium", "gid": 385, "verify": "contentPos.count必须小于params数组的长度", "has_risk": true, "preconditions": "contentPos.count 的值大于等于 params 数组的长度", "trigger_path": "调用路径推导：HilogImpl() -> ParseLogContent() -> ProcessLogContent()。数据流：外部输入通过 HilogImpl 的参数 args 和 format 传入，args 被解析为 params 向量，format 转换为字符串后与 params 一起传递给 ParseLogContent。关键调用点：ParseLogContent 中虽然检查了 params.empty() 和 contentPos.count >= size，但 ProcessLogContent 内部直接使用 params[contentPos.count] 而没有边界检查。", "consequences": "数组越界访问，可能导致程序崩溃或信息泄露", "suggestions": "在 ProcessLogContent 函数内部添加对 contentPos.count 的边界检查，确保它小于 params.size()", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "buffer_overflow", "pattern": "vector_bounds_check", "file": "interfaces/ets/ani/hilog/src/hilog_ani_base.cpp", "line": 70, "evidence": "params[contentPos.count].type == AniArgsType::ANI_UNDEFINED ||", "confidence": 0.6, "severity": "medium", "gid": 386, "verify": "contentPos.count必须小于params数组的长度", "has_risk": true, "preconditions": "contentPos.count 的值大于等于 params 数组的长度", "trigger_path": "调用路径推导：HilogImpl() -> ParseLogContent() -> ProcessLogContent()。数据流：外部输入通过 HilogImpl 的参数 args 和 format 传入，args 被解析为 params 向量，format 转换为字符串后与 params 一起传递给 ParseLogContent。关键调用点：ParseLogContent 中虽然检查了 params.empty() 和 contentPos.count >= size，但 ProcessLogContent 内部直接使用 params[contentPos.count] 而没有边界检查。", "consequences": "数组越界访问，可能导致程序崩溃或信息泄露", "suggestions": "在 ProcessLogContent 函数内部添加对 contentPos.count 的边界检查，确保它小于 params.size()", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "buffer_overflow", "pattern": "vector_bounds_check", "file": "interfaces/ets/ani/hilog/src/hilog_ani_base.cpp", "line": 71, "evidence": "params[contentPos.count].type == AniArgsType::ANI_BOOLEAN ||", "confidence": 0.6, "severity": "medium", "gid": 387, "verify": "contentPos.count必须小于params数组的长度", "has_risk": true, "preconditions": "contentPos.count 的值大于等于 params 数组的长度", "trigger_path": "调用路径推导：HilogImpl() -> ParseLogContent() -> ProcessLogContent()。数据流：外部输入通过 HilogImpl 的参数 args 和 format 传入，args 被解析为 params 向量，format 转换为字符串后与 params 一起传递给 ParseLogContent。关键调用点：ParseLogContent 中虽然检查了 params.empty() 和 contentPos.count >= size，但 ProcessLogContent 内部直接使用 params[contentPos.count] 而没有边界检查。", "consequences": "数组越界访问，可能导致程序崩溃或信息泄露", "suggestions": "在 ProcessLogContent 函数内部添加对 contentPos.count 的边界检查，确保它小于 params.size()", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "buffer_overflow", "pattern": "vector_bounds_check", "file": "interfaces/ets/ani/hilog/src/hilog_ani_base.cpp", "line": 72, "evidence": "params[contentPos.count].type == AniArgsType::ANI_NULL) {", "confidence": 0.6, "severity": "medium", "gid": 388, "verify": "contentPos.count必须小于params数组的长度", "has_risk": true, "preconditions": "contentPos.count 的值大于等于 params 数组的长度", "trigger_path": "调用路径推导：HilogImpl() -> ParseLogContent() -> ProcessLogContent()。数据流：外部输入通过 HilogImpl 的参数 args 和 format 传入，args 被解析为 params 向量，format 转换为字符串后与 params 一起传递给 ParseLogContent。关键调用点：ParseLogContent 中虽然检查了 params.empty() 和 contentPos.count >= size，但 ProcessLogContent 内部直接使用 params[contentPos.count] 而没有边界检查。", "consequences": "数组越界访问，可能导致程序崩溃或信息泄露", "suggestions": "在 ProcessLogContent 函数内部添加对 contentPos.count 的边界检查，确保它小于 params.size()", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "buffer_overflow", "pattern": "vector_bounds_check", "file": "interfaces/ets/ani/hilog/src/hilog_ani_base.cpp", "line": 73, "evidence": "ret += isPriv ? PRIV_STR : params[contentPos.count].val;", "confidence": 0.6, "severity": "medium", "gid": 389, "verify": "contentPos.count必须小于params数组的长度", "has_risk": true, "preconditions": "contentPos.count 的值大于等于 params 数组的长度", "trigger_path": "调用路径推导：HilogImpl() -> ParseLogContent() -> ProcessLogContent()。数据流：外部输入通过 HilogImpl 的参数 args 和 format 传入，args 被解析为 params 向量，format 转换为字符串后与 params 一起传递给 ParseLogContent。关键调用点：ParseLogContent 中虽然检查了 params.empty() 和 contentPos.count >= size，但 ProcessLogContent 内部直接使用 params[contentPos.count] 而没有边界检查。", "consequences": "数组越界访问，可能导致程序崩溃或信息泄露", "suggestions": "在 ProcessLogContent 函数内部添加对 contentPos.count 的边界检查，确保它小于 params.size()", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "buffer_overflow", "pattern": "vector_bounds_check", "file": "interfaces/ets/ani/hilog/src/hilog_ani_base.cpp", "line": 80, "evidence": "if (params[contentPos.count].type == AniArgsType::ANI_OBJECT) {", "confidence": 0.6, "severity": "medium", "gid": 390, "verify": "contentPos.count必须小于params数组的长度", "has_risk": true, "preconditions": "contentPos.count 的值大于等于 params 数组的长度", "trigger_path": "调用路径推导：HilogImpl() -> ParseLogContent() -> ProcessLogContent()。数据流：外部输入通过 HilogImpl 的参数 args 和 format 传入，args 被解析为 params 向量，format 转换为字符串后与 params 一起传递给 ParseLogContent。关键调用点：ParseLogContent 中虽然检查了 params.empty() 和 contentPos.count >= size，但 ProcessLogContent 内部直接使用 params[contentPos.count] 而没有边界检查。", "consequences": "数组越界访问，可能导致程序崩溃或信息泄露", "suggestions": "在 ProcessLogContent 函数内部添加对 contentPos.count 的边界检查，确保它小于 params.size()", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "buffer_overflow", "pattern": "vector_bounds_check", "file": "interfaces/ets/ani/hilog/src/hilog_ani_base.cpp", "line": 81, "evidence": "ret += isPriv ? PRIV_STR : params[contentPos.count].val;", "confidence": 0.6, "severity": "medium", "gid": 391, "verify": "contentPos.count必须小于params数组的长度", "has_risk": true, "preconditions": "contentPos.count 的值大于等于 params 数组的长度", "trigger_path": "调用路径推导：HilogImpl() -> ParseLogContent() -> ProcessLogContent()。数据流：外部输入通过 HilogImpl 的参数 args 和 format 传入，args 被解析为 params 向量，format 转换为字符串后与 params 一起传递给 ParseLogContent。关键调用点：ParseLogContent 中虽然检查了 params.empty() 和 contentPos.count >= size，但 ProcessLogContent 内部直接使用 params[contentPos.count] 而没有边界检查。", "consequences": "数组越界访问，可能导致程序崩溃或信息泄露", "suggestions": "在 ProcessLogContent 函数内部添加对 contentPos.count 的边界检查，确保它小于 params.size()", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/ets/ani/hilog/src/hilog_ani.cpp", "line": 26, "evidence": "if (ANI_OK != vm->GetEnv(ANI_VERSION_1, &env)) {", "confidence": 0.6, "severity": "high", "gid": 392, "verify": "验证指针(vm/env/ns/result)在使用前是否非空", "has_risk": true, "preconditions": "外部调用者传入的vm或result参数为nullptr", "trigger_path": "调用路径推导：外部模块 -> ANI_Constructor(vm, result)。数据流：vm和result参数由外部模块直接传入，函数内部未进行空指针检查。关键调用点：ANI_Constructor函数未对输入参数进行空指针校验。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在函数开始处添加参数检查：if (vm == nullptr || result == nullptr) { return ANI_ERROR; }", "verification_notes": "未进行二次验证（--no-verification）"}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "interfaces/ets/ani/hilog/src/hilog_ani.cpp", "line": 50, "evidence": "*result = ANI_VERSION_1;", "confidence": 0.6, "severity": "high", "gid": 395, "verify": "验证指针(vm/env/ns/result)在使用前是否非空", "has_risk": true, "preconditions": "外部调用者传入的vm或result参数为nullptr", "trigger_path": "调用路径推导：外部模块 -> ANI_Constructor(vm, result)。数据流：vm和result参数由外部模块直接传入，函数内部未进行空指针检查。关键调用点：ANI_Constructor函数未对输入参数进行空指针校验。", "consequences": "空指针解引用，可能导致程序崩溃", "suggestions": "在函数开始处添加参数检查：if (vm == nullptr || result == nullptr) { return ANI_ERROR; }", "verification_notes": "未进行二次验证（--no-verification）"}
