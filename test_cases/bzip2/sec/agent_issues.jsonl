{"language": "c/cpp", "category": "error_handling", "pattern": "io_call", "file": "dlltest.c", "line": 138, "evidence": "fwrite(buff,1,len,fp_w);", "confidence": 0.65, "severity": "medium", "gid": 31, "verify": "fwrite操作返回值需校验写入字节数与预期一致", "preconditions": "fwrite操作因磁盘空间不足、IO错误、文件权限问题等原因无法完整写入数据", "trigger_path": "BZ2_bzread读取压缩数据后，调用fwrite进行文件或标准输出写入，但未验证实际写入字节数是否与预期一致", "consequences": "数据写入不完整可能导致文件损坏，程序错误认为操作成功而实际数据丢失", "suggestions": "检查fwrite返回值确保写入字节数与预期一致，如不一致应进行错误处理", "has_risk": true}
{"language": "c/cpp", "category": "unsafe_api", "pattern": "sprintf", "file": "bzip2recover.c", "line": 482, "evidence": "sprintf (split, \"      \", wrBlock+1);", "confidence": 0.9, "severity": "high", "gid": 43, "verify": "'rec%5d'格式化结果长度不超过split指向的缓冲区剩余空间", "preconditions": "输入文件名长度接近BZ_MAX_FILENAME限制，且路径分隔符位置使得split指向的缓冲区剩余空间较小", "trigger_path": "通过命令行参数传入较长的文件名，经过路径解析后split位置剩余空间不足容纳'rec%5d'格式化结果", "consequences": "缓冲区溢出，可能导致程序崩溃、内存破坏或潜在任意代码执行", "suggestions": "使用snprintf替代sprintf，并检查格式化后的长度是否超过缓冲区剩余空间；或重写文件命名逻辑以保证安全性", "has_risk": true}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "use_after_free_suspect", "file": "bzlib.c", "line": 954, "evidence": "{ BZ_SETERR(ret); free(bzf); return NULL; };", "confidence": 0.65, "severity": "high", "gid": 324, "verify": "free(bzf)后未再访问bzf及其成员", "preconditions": "BZ2_bzCompressInit函数调用失败返回值不为BZ_OK", "trigger_path": "BZ2_bzWriteOpen函数在调用BZ2_bzCompressInit失败后，执行BZ_SETERR(ret)时触发use-after-free", "consequences": "访问已释放内存，可能导致程序崩溃、内存损坏或任意代码执行", "suggestions": "在free(bzf)之前执行BZ_SETERR(ret)，或者在BZ_SETERR宏中增加对bzf是否为NULL的检查", "has_risk": true}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "use_after_free_suspect", "file": "bzlib.c", "line": 1132, "evidence": "{ BZ_SETERR(ret); free(bzf); return NULL; };", "confidence": 0.65, "severity": "high", "gid": 325, "verify": "free(bzf)后未再访问bzf及其成员", "preconditions": "BZ2_bzDecompressInit函数调用失败返回值不为BZ_OK", "trigger_path": "BZ2_bzReadOpen函数在调用BZ2_bzDecompressInit失败后，执行BZ_SETERR(ret)时触发use-after-free", "consequences": "访问已释放内存，可能导致程序崩溃、内存损坏或任意代码执行", "suggestions": "在free(bzf)之前执行BZ_SETERR(ret)，或者在BZ_SETERR宏中增加对bzf是否为NULL的检查", "has_risk": true}
{"language": "c/cpp", "category": "memory_mgmt", "pattern": "possible_null_deref", "file": "bzlib.c", "line": 1564, "evidence": "*errnum = err;", "confidence": 0.6, "severity": "high", "gid": 728, "verify": "指针bzf在访问成员前非空", "preconditions": "传递给 BZ2_bzerror 函数的 BZFILE* b 参数为NULL", "trigger_path": "外部调用者将NULL指针传递给BZ2_bzerror函数，函数直接对b参数进行强制转换并访问成员变量", "consequences": "程序在访问 ((bzFile *)b)->lastErr 时会发生段错误，导致应用程序崩溃", "suggestions": "在函数开头添加空指针检查：if (b == NULL) { *errnum = BZ_PARAM_ERROR; return \"PARAM_ERROR\"; }", "has_risk": true}
{"language": "c/cpp", "category": "unsafe_api", "pattern": "strcat", "file": "bzip2.c", "line": 1136, "evidence": "strcat ( name, newSuffix );", "confidence": 0.9, "severity": "high", "gid": 729, "verify": "目标缓冲区必须足够容纳源字符串加上追加的后缀", "preconditions": "文件名在截断旧后缀后，剩余缓冲区空间不足以容纳新后缀", "trigger_path": "调用mapSuffix函数处理带后缀的文件名时，原文件名长度接近缓冲区边界，截断后空间不足", "consequences": "缓冲区溢出，可能造成程序崩溃、数据泄露或任意代码执行", "suggestions": "在追加新后缀前检查剩余缓冲区空间，考虑使用strncat并指定最大追加长度", "has_risk": true}
{"language": "c/cpp", "category": "unsafe_api", "pattern": "strcat", "file": "bzip2.c", "line": 1163, "evidence": "strcat ( outName, \"    \" );", "confidence": 0.9, "severity": "high", "gid": 730, "verify": "目标缓冲区必须足够容纳源字符串加上追加的后缀", "preconditions": "输入文件名长度达到copyFileName允许的最大值（FILE_NAME_LEN-10）", "trigger_path": "compress函数在SM_F2F模式下获取可能最大长度文件名后，直接追加固定长度后缀", "consequences": "缓冲区溢出，可能导致程序异常终止、内存数据泄露或安全漏洞", "suggestions": "在strcat调用前验证剩余缓冲区空间，或使用strncat限制追加长度", "has_risk": true}
{"language": "c/cpp", "category": "unsafe_api", "pattern": "strcat", "file": "bzip2.c", "line": 1351, "evidence": "strcat ( outName, \"    \" );", "confidence": 0.9, "severity": "high", "gid": 731, "verify": "目标缓冲区必须足够容纳源字符串加上追加的后缀", "preconditions": "输入文件名经过多次后缀映射处理后，最终文件名接近缓冲区边界", "trigger_path": "uncompress函数在SM_F2F模式中处理无法识别后缀的文件时，追加固定后缀", "consequences": "缓冲区溢出，可能造成程序运行时错误、数据损坏或安全漏洞", "suggestions": "在处理文件后缀映射后，重新评估缓冲区剩余空间，确保固定后缀不会导致越界", "has_risk": true}
{"language": "c/cpp", "category": "unsafe_api", "pattern": "strcpy", "file": "bzip2.c", "line": 1744, "evidence": "strcpy ( tmp->name, name );", "confidence": 0.9, "severity": "high", "gid": 732, "verify": "目标缓冲区必须足够容纳源字符串加上追加的后缀", "preconditions": "输入字符串长度接近整数最大值，或myMalloc(5 + strlen(name))存在整数溢出", "trigger_path": "snocString函数递归处理字符串列表时，分配的内存和字符串拷贝存在边界检查缺失", "consequences": "潜在的整数溢出导致堆缓冲区溢出，可能引起内存损坏或任意代码执行", "suggestions": "使用strncpy并指定明确的最大拷贝长度，或检查分配的内存大小是否足够", "has_risk": true}
{"language": "c/cpp", "category": "unsafe_usage", "pattern": "format_string", "file": "bzip2.c", "line": 1638, "evidence": "fprintf (", "confidence": 0.8, "severity": "high", "gid": 779, "verify": "fprintf格式字符串参数由用户输入控制", "preconditions": "用户通过命令行参数或修改环境变量控制fullProgName参数的命名", "trigger_path": "main函数从argv[0]获取程序名并传递给usage函数作格式化输出", "consequences": "恶意用户可控制程序名来触发缓冲区溢出或格式化字符串攻击", "suggestions": "将fprintf改为fputs并使用固定格式字符串，或对用户输入进行严格验证和限制", "has_risk": true}
{"language": "c/cpp", "category": "unsafe_usage", "pattern": "format_string", "file": "bzip2.c", "line": 1682, "evidence": "fprintf (", "confidence": 0.8, "severity": "high", "gid": 780, "verify": "fprintf格式字符串参数由用户输入控制", "preconditions": "用户能够控制命令行参数flag和程序名", "trigger_path": "用户提供包含格式化说明符的flag参数，在redundant函数中进行格式化输出", "consequences": "可能导致格式化字符串攻击，攻击者可读取内存内容或执行任意代码", "suggestions": "使用硬编码的错误消息格式，避免在格式化字符串中使用用户提供的参数", "has_risk": true}
