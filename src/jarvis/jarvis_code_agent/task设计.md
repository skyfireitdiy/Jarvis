本文档作为Jarvis Code Agent架构中任务列表模块的开发核心指导文件，以规范开发为核心目标，系统梳理模块架构逻辑、数据结构设计、接口约束规则及关键实施要点。旨在为开发人员提供清晰、可落地的技术方案，保障任务列表模块具备上下文共享可控、任务流转高效、状态管理精准的核心能力，适配主 Agent 与子 Agent 的协同需求。

一、文档基础信息

1.1 核心目标

构建支持多任务动态管理、上下文分层共享、Agent 权限隔离的任务列表模块，实现用户需求拆解、任务调度、状态追踪、结果回流的全流程自动化，为Jarvis Code Agent整体任务执行提供核心数据载体与调度支撑。

1.2 适用范围

本指南适用于Jarvis Code Agent架构下任务列表模块的开发、测试及集成人员，覆盖模块设计、编码实现、接口联调、部署验证全流程。

1.3 关键术语定义

术语

定义

主 Agent

统筹全局任务流，负责任务列表创建、维护、调度及状态监控的核心主体，拥有任务列表完整读写权限

子 Agent

由主 Agent 克隆，负责特定子任务执行的主体，仅拥有自身关联任务的有限访问权限

任务列表容器

结构化存储任务实体的核心载体，包含任务集合、全局配置及状态统计信息

全局上下文

所有任务共享的基础信息，含用户核心需求、系统配置、工具调用基础参数等

任务上下文

单个任务专属的执行信息，含任务属性、前置依赖结果、临时执行日志等

二、核心架构逻辑设计

2.1 架构定位

任务列表模块是Jarvis Code Agent任务执行体系的“中枢核心”，上承用户需求拆解，下接 Agent 调度与工具调用，核心承担三大职责：一是将用户自然语言需求转化为结构化任务集合；二是动态管理任务状态与依赖关系，保障任务流转有序；三是实现上下文分层共享与 Agent 权限隔离，兼顾协同效率与数据安全。

2.2 分层架构设计

模块采用三层架构设计，各层职责清晰、耦合度低，便于开发维护：

1. 数据层：负责任务数据的结构化存储与持久化，含任务实体、任务列表容器及版本快照，支持内存实时存储与磁盘持久化备份双重机制。

2. 核心逻辑层：封装任务全生命周期管理能力，含任务初始化、状态转换、优先级调整、依赖校验、合并拆分等核心算法，是模块的核心功能载体。

3. 接口层：提供标准化接口供外部模块调用，含主 Agent 专属的全权限接口、子 Agent 专属的有限权限接口及与上下文管理、工具调用模块的集成接口。

2.3 关键交互流程

模块核心交互流程围绕“需求拆解-任务调度-执行反馈-状态更新”闭环展开：

1. 主 Agent 接收用户需求后，调用核心逻辑层任务初始化接口，生成结构化任务列表；

2. 主 Agent 通过调度接口获取待执行任务，根据任务类型分配给自身或子 Agent 执行；

3. Agent 执行任务过程中，通过接口实时同步执行状态，工具调用结果同步至任务上下文；

4. 任务完成/失败后，Agent 提交执行结果，核心逻辑层更新任务状态，触发依赖任务优先级调整；

5. 数据层同步更新任务信息并生成版本快照，保障数据可追溯。

三、数据结构设计规范

3.1 任务实体（Task）设计

任务实体为最小数据单元，采用结构化字典存储，字段设计兼顾完整性与实用性，必选字段严格约束，可选字段适配灵活需求：

字段名

数据类型

是否必选

约束规则

核心描述

task_id

字符串（UUID v4）

是

全局唯一，格式为“task-xxxx-xxxx-xxxx”

任务唯一标识，用于状态追踪与依赖关联

task_name

字符串

是

长度 10-50 字符，清晰描述任务核心目标

任务名称，便于 Agent 快速识别任务意图

task_desc

字符串

是

长度 50-200 字符，含执行要求与输出标准

任务详细描述，明确执行边界与预期效果

priority

整数

是

取值 1-5，5 为最高优先级

任务优先级，用于调度排序

status

枚举

是

仅允许取值：pending/running/completed/failed/abandoned

任务执行状态，遵循固定转换规则

dependencies

列表（task_id 集合）

否

元素需为有效 task_id，无循环依赖

前置任务 ID 集合，未完成则当前任务不可执行

expected_output

字符串

是

明确输出格式与核心内容

任务预期输出，用于结果校验

actual_output

字符串

否

任务完成/失败后填充

任务实际执行结果

agent_type

枚举

是

仅允许取值：main/sub/tool

负责执行任务的 Agent 类型

create_time

时间戳（毫秒）

是

基于系统 UTC 时间

任务创建时间

update_time

时间戳（毫秒）

是

状态变更时自动更新

任务最后更新时间

timeout

整数

否

默认 300 秒，取值 ≥60 秒

任务执行超时阈值

retry_count

整数

否

默认 0，取值 ≥0

任务已重试次数

retry_limit

整数

否

默认 3，取值 1-5

任务最大重试次数

3.2 任务列表容器（TaskList）设计

任务列表容器用于管理多个任务实体，采用有序字典存储，支持按优先级与创建时间排序，核心字段设计如下：

字段名

数据类型

约束规则

核心描述

tasks

字典（key:task_id, value:Task）

key 全局唯一

存储所有任务实体的键值对集合

main_goal

字符串

长度 50-200 字符

关联的用户核心需求，全局上下文核心内容

active_task_ids

列表（task_id 集合）

元素为 status 为 pending/running 的任务 ID

活跃任务 ID 列表，用于快速调度

completed_task_ids

列表（task_id 集合）

元素为 status 为 completed 的任务 ID

已完成任务 ID 列表，用于依赖校验

max_active_tasks

整数

默认 10，取值 5-20

最大活跃任务数，避免任务过载

version

整数

初始为 1，修改后自增 1

任务列表版本号，用于版本管理与回滚

四、接口约束与调用规则

4.1 接口设计原则

接口设计遵循“权限分级、职责单一、参数标准化”原则：主 Agent 拥有全权限接口访问权，子 Agent 仅开放任务查询与结果提交接口；每个接口仅实现单一功能，避免多职责耦合；输入输出参数采用 JSON 格式，字段类型与约束严格匹配数据结构定义。

4.2 核心接口约束详情

接口名称

访问权限

输入参数

输出参数

调用场景

异常处理规则

create_task_list

仅主 Agent

main_goal:字符串（必选）

task_list_id:字符串；status:布尔值

用户需求初始化时，创建任务列表容器

main_goal 格式不合法时返回 false，附带错误信息

add_task

仅主 Agent

task_info:字典（含 Task 必选字段，必选）

task_id:字符串；status:布尔值

需求拆解后，添加新任务至任务列表

字段缺失/格式错误时返回 false，附带错误字段信息

update_task_status

主 Agent/子 Agent

task_id:字符串（必选）；status:枚举（必选）；actual_output:字符串（可选）

status:布尔值；msg:字符串

任务执行过程中，更新任务状态与执行结果

子 Agent 访问非关联任务时返回 false，提示权限不足

get_next_task

仅主 Agent

无

task:Task 实体/None；msg:字符串

任务调度时，获取优先级最高的待执行任务

无活跃任务时返回 None，提示“暂无待执行任务”

get_task_detail

主 Agent/子 Agent

task_id:字符串（必选）

task:Task 实体；status:布尔值

Agent 执行任务前，获取任务详细信息

子 Agent 访问非关联任务时返回 false，提示权限不足

rollback_task_list

仅主 Agent

version:整数（必选）

status:布尔值；msg:字符串

任务列表异常时，回滚至指定版本

版本不存在时返回 false，提示“版本无效”

五、开发实施关键要点

5.1 权限隔离实现

开发时需通过“任务-Agent 关联映射表”实现权限隔离：主 Agent 初始化子 Agent 时，记录子 Agent 与关联 task_id 的映射关系；子 Agent 调用接口时，系统自动校验 task_id 是否在其关联范围内，未关联则拒绝访问。

5.2 状态转换控制

严格遵循状态转换规则：仅允许 pending→running→completed/failed/abandoned、pending→abandoned 的转换路径；超时任务需通过定时任务（每 5 秒扫描）自动标记为 failed，触发重试逻辑；重试达上限后，自动标记为 abandoned 并移除出活跃任务列表。

5.3 持久化与容错设计

采用“内存+磁盘”双重持久化机制：Redis 存储实时任务列表数据，保障查询效率；每 30 秒将数据序列化（JSON 格式）写入磁盘，生成版本快照；系统启动时，优先加载 Redis 数据，Redis 异常则加载磁盘最新快照，确保数据不丢失。

5.4 性能优化要点

任务数量超过 100 个时，自动按 agent_type 分片存储，主 Agent 调度时仅加载对应分片数据；任务上下文采用懒加载机制，仅执行时加载关联前置任务结果，减少内存占用与 Token 消耗；并发修改时采用乐观锁（基于 version 字段），避免数据冲突。

六、测试验证标准

开发完成后需覆盖三类核心测试场景：一是单元测试，验证任务实体字段校验、状态转换、接口参数校验等核心逻辑；二是集成测试，模拟主/子 Agent 协同流程，验证任务调度、结果回流、权限隔离的正确性；三是性能测试，模拟 1000 个任务并发创建与调度，确保响应时间 ≤500ms，无数据一致性问题。

本指南涵盖任务列表模块开发的核心技术要点，开发过程中需严格遵循数据结构约束与接口规则，重点保障权限隔离、状态管理与数据持久化的稳定性。后续可根据业务需求扩展任务标签分类、多用户隔离等功能，迭代优化模块能力。
