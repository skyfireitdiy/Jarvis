# -*- coding: utf-8 -*-
from jarvis.jarvis_utils.tag import ct, ot

DEFAULT_SUMMARY_PROMPT = """<report>
请生成任务执行的上下文结构化总结报告，作为后续对话的"无关键信息缺失"上下文支撑：

<content>
#### 1. 目标层次结构（必须清晰区分）
- **整体目标**（顶层愿景）：
  - 格式："[目标类型] 在[时间范围]内，实现[具体成果]，达到[量化指标]"
  - 示例："[架构升级] 在2周内，完成用户认证系统重构，达到QPS≥1000，99.9%可用性"

- **阶段目标**（当前阶段交付）：
  - 格式："阶段[序号]：[具体目标] → [验收标准]"
  - 示例："阶段1：数据库表设计完成 → user/auth表结构定义+索引优化方案"

#### 2. 任务状态矩阵（精确跟踪）
- **已完成**（✅）：按优先级排序的已交付成果
  - 格式："[优先级] [交付物] - [验证方式]"
  - 示例："P0 用户表结构设计 - 已通过代码审查"

- **待完成**（📋）：剩余任务清单及依赖
  - 格式："[优先级] [任务描述] - [前置依赖] - [预计工时] - [负责人]"
  - 示例："P1 实现JWT认证接口 - 依赖：用户表完成 - 4小时 - @后端开发"

#### 3. 关键信息导航系统（快速索引）
- **关键信息位置**（📍）：使用记忆标签建立索引
  - 项目长期记忆：关键架构决策、配置方案、业务规则
  - 全局长期记忆：通用解决方案、最佳实践、技术标准
  - 短期记忆：当前任务的临时数据、调试信息、中间结果

- **关键文件路径**（📁）：建立项目核心文件映射
  - 配置文件：`src/jarvis/config/` - 系统配置和参数
  - 核心代码：`src/jarvis/jarvis_agent/` - 代理核心逻辑
  - 工具定义：`src/jarvis/jarvis_tools/` - 可用工具集合
  - 测试文件：`tests/` - 测试用例和验证脚本

#### 4. 执行结果与关键发现
- **执行结果**：成功/失败/部分完成
- **关键信息**：执行过程中提取的重要技术/业务信息
- **重要发现**：任何值得注意的发现或意外收获
- **无效方案总结**：如果当前是在修复问题，总结尝试过但无效的方案
  - 已尝试的方法及其失败原因
  - 排除的错误假设
  - 不可行的解决路径

#### 5. 技术与业务上下文（必保保留）
- **技术栈与版本**：Python版本、框架版本、关键依赖
- **架构决策**：技术选型理由、权衡考虑、未来扩展性
- **配置参数**：数据库配置、API密钥、环境变量
- **代码位置**：核心函数、配置文件、关键算法实现
- **调试信息**：错误日志、性能数据、测试结果

#### 6. 用户偏好与约束（精确记录）
- **质量要求**：代码规范、测试覆盖率、文档标准
- **性能约束**：响应时间、并发量、资源限制
- **兼容性要求**：系统版本、浏览器支持、设备适配
- **禁忌项**：明确禁止的技术方案或实现方式
- **交付偏好**：输出格式、沟通频率、验收流程

#### 7. 后续行动建议
- **下一步**：具体可执行的行动项
- **优先级排序**：基于依赖关系的任务执行顺序
- **注意事项**：潜在风险和需要特别关注的技术点
</content>

<format>
1. 语言风格：简洁、客观、专业，使用编程领域规范表述；
2. 结构组织：按"核心目标→已确认事实→决策与共识→技术细节→任务进展→待办事项→用户约束"的逻辑组织；
3. 呈现形式：分点列出，关键技术内容用`代码块`/加粗标注，待办事项用"【优先级】+ 内容 + 责任人"明确；
4. 长度限制：严格控制在500词以内，优先压缩冗余，不压缩必保信息。
</format>
</report>"""

SUMMARY_REQUEST_PROMPT = """<summary_request>
<objective>
请对当前对话历史进行精准总结，核心目标是为后续对话提供“无关键信息缺失”的上下文支撑：既要提炼核心逻辑，又要完整保留影响后续决策/操作的关键细节，确保后续对话无需回溯原始历史即可顺畅推进。
</objective>

#### 1. 目标层次结构（必须清晰区分）
- **整体目标**（顶层愿景）：
  - 格式："[目标类型] 在[时间范围]内，实现[具体成果]，达到[量化指标]"
  - 示例："[架构升级] 在2周内，完成用户认证系统重构，达到QPS≥1000，99.9%可用性"
  - 必须包含：业务意义、成功标准、时间约束

- **阶段目标**（当前阶段交付）：
  - 格式："阶段[序号]：[具体目标] → [验收标准]"
  - 示例："阶段1：数据库表设计完成 → user/auth表结构定义+索引优化方案"
  - 必须包含：当前阶段边界、可验证的交付物

#### 2. 任务状态矩阵（精确跟踪）
- **已完成**（✅）：按优先级排序的已交付成果
  - 格式："[优先级] [交付物] - [验证方式]"
  - 示例："P0 用户表结构设计 - 已通过代码审查"
  - 必须包含：具体交付物、验证标准

- **待完成**（📋）：剩余任务清单及依赖
  - 格式："[优先级] [任务描述] - [前置依赖] - [预计工时] - [负责人]"
  - 示例："P1 实现JWT认证接口 - 依赖：用户表完成 - 4小时 - @后端开发"
  - 必须包含：任务边界、依赖关系、资源需求

#### 3. 关键信息导航系统（快速索引）
- **关键信息位置**（📍）：使用记忆标签建立索引
  - 项目长期记忆：关键架构决策、配置方案、业务规则
  - 全局长期记忆：通用解决方案、最佳实践、技术标准
  - 短期记忆：当前任务的临时数据、调试信息、中间结果

- **关键文件路径**（📁）：建立项目核心文件映射
  - 配置文件：`src/jarvis/config/` - 系统配置和参数
  - 核心代码：`src/jarvis/jarvis_agent/` - 代理核心逻辑
  - 工具定义：`src/jarvis/jarvis_tools/` - 可用工具集合
  - 测试文件：`tests/` - 测试用例和验证脚本
  - 具体文件：提供精确到文件的路径和关键函数位置

#### 4. 上下文完整性检查清单（总结前自检）
- [ ] 整体目标明确且可量化（包含时间+指标）
- [ ] 阶段目标递进且可验证（每个阶段有验收标准）
- [ ] 已完成任务有明确验收标准（可复现的验证方式）
- [ ] 待完成任务有优先级和依赖关系（任务网络清晰）
- [ ] 关键信息可通过记忆标签快速定位（建立索引系统）
- [ ] 关键文件路径准确且最新（便于快速访问）
- [ ] 技术约束和边界条件已明确（兼容性和限制）
- [ ] 后续行动建议具体可操作（下一步明确指令）

#### 5. 核心技术与业务信息（必保保留）
1. **技术栈与版本**：Python版本、框架版本、关键依赖
2. **架构决策**：技术选型理由、权衡考虑、未来扩展性
3. **配置参数**：数据库配置、API密钥、环境变量
4. **代码位置**：核心函数、配置文件、关键算法实现
5. **调试信息**：错误日志、性能数据、测试结果
6. **接口定义**：API端点、参数格式、响应结构
7. **数据模型**：数据库表结构、字段定义、关系映射

#### 6. 用户偏好与约束（精确记录）
- **质量要求**：代码规范、测试覆盖率、文档标准
- **性能约束**：响应时间、并发量、资源限制
- **兼容性要求**：系统版本、浏览器支持、设备适配
- **禁忌项**：明确禁止的技术方案或实现方式
- **交付偏好**：输出格式、沟通频率、验收流程

#### 7. 可省略的冗余内容（无需保留）
- 寒暄与无关闲聊（如"您好""谢谢""今天天气不错"）；
- 重复表述（用户多次强调的同一需求，仅保留1次核心表述）；
- 临时试错/未落地的想法（如"我先试试这个思路""可能用XX方案"，未确认的不保留）；
- 与任务无关的细节（如"用户提及的其他项目经验""无关的技术科普"）。
</guidelines>

<format>
1. 语言风格：简洁、客观、专业，使用编程领域规范表述（如“非阻塞IO”而非“不等待的输入输出”）；
2. 结构组织：按“核心目标→已确认事实→决策与共识→技术细节→任务进展→待办事项→用户约束”的逻辑组织（替代“时间顺序”，更贴合后续对话需求）；
3. 呈现形式：分点列出，关键技术内容用`代码块`/加粗标注，待办事项用“【优先级】+ 内容 + 责任人”明确（如“【高】补充跨域配置 - 助手”）；
4. 长度限制：严格控制在500词以内，优先压缩冗余，不压缩必保信息（若必保信息较多，可适当放宽至600词）。
</format>
</summary_request>
"""


def get_task_analysis_prompt(
    has_save_memory: bool = False, has_generate_new_tool: bool = False
) -> str:
    """根据配置返回任务分析提示词

    参数:
        has_save_memory: 是否有 save_memory 工具（工具可用性）
        has_generate_new_tool: 是否有 generate_new_tool 工具
    """
    # 第一步：记忆保存部分
    if not has_save_memory:
        # 如果没有 save_memory 工具，说明无法保存记忆
        memory_step = """第一步：记忆值得保存的信息
1. 识别任务中的关键信息和知识点
2. 评估是否有值得保存的项目长期记忆或全局长期记忆
3. 注意：当前环境不支持 save_memory 工具，无法保存记忆。请直接说明识别到的关键信息即可。"""
    else:
        # 有 save_memory 工具
        memory_step = """第一步：记忆值得保存的信息
1. 识别任务中的关键信息和知识点
2. 评估是否有值得保存的项目长期记忆或全局长期记忆
3. 如果有价值，使用 save_memory 工具保存有价值的信息：
   - project_long_term: 保存与当前项目相关的长期信息（如项目配置、架构决策、开发规范等）
   - global_long_term: 保存通用的信息、用户偏好、知识或方法（如技术知识、最佳实践、用户习惯等）"""

    # 第二步：工具/方法论分析部分
    if has_generate_new_tool:
        solution_step = """第二步：分析任务解决方案
1. 检查现有工具或方法论是否已经可以完成该任务，如果可以，直接说明即可，无需生成新内容
2. 如果现有工具/方法论不足，评估当前任务是否可以通过编写新工具来自动化解决
3. 如果可以通过工具解决，请使用 generate_new_tool 工具创建新工具：
   - 使用 generate_new_tool 工具，传入 tool_name 和 tool_code 参数
   - tool_code 应包含完整的工具类定义，遵循工具代码要求
4. 如果无法通过编写通用工具完成，评估当前的执行流程是否可以总结为通用方法论
5. 如果以上都不可行，给出详细理由"""
    else:
        solution_step = """第二步：分析任务解决方案
1. 检查现有工具或方法论是否已经可以完成该任务，如果可以，直接说明即可，无需生成新内容
2. 如果现有工具/方法论不足，评估当前任务是否可以通过编写新工具来自动化解决
3. 如果可以通过工具解决，请设计并提供工具代码（注意：当前环境不支持 generate_new_tool 工具，需要手动创建工具文件）
4. 如果无法通过编写通用工具完成，评估当前的执行流程是否可以总结为通用方法论
5. 如果以上都不可行，给出详细理由"""

    # 输出要求部分
    if has_generate_new_tool:
        output_requirements = f"""<output_requirements>
根据分析结果，输出以下三种情况之一：
1. 如果现有工具/方法论可以解决，直接输出说明：
已有工具/方法论可以解决该问题，无需创建新内容。
可用的工具/方法论：[列出工具名称或方法论名称]
使用方法：[简要说明如何使用]
2. 工具创建（如果需要创建新工具）:
{ot("TOOL_CALL")}
{{
  "want": "创建新工具来解决XXX问题",
  "name": "generate_new_tool",
  "arguments": {{
    "tool_name": "工具名称",
    "tool_code": `# -*- coding: utf-8 -*-
from typing import Dict, Any

class 工具名称:
    name = "工具名称"
    description = "Tool description"
    parameters = {{
        "type": "object",
        "properties": {{
            # 参数定义
        }},
        "required": []
    }}
    @staticmethod
    def check() -> bool:
        return True
    def execute(self, args: Dict[str, Any]) -> Dict[str, Any]:
        try:
            # 使用print显示执行过程
            print("ℹ️ 开始执行操作...")
            # 实现逻辑
            # ...
            print("✅ 操作已完成")
            return {{
                "success": True,
                "stdout": "结果输出",
                "stderr": ""
            }}
        except Exception as e:
            print(f"❌ 操作失败: {{str(e)}}")
            return {{
                "success": False,
                "stdout": "",
                "stderr": f"操作失败: {{str(e)}}"
            }}`
  }}
}}
{ct("TOOL_CALL")}

注意：tool_code 参数推荐使用 ||| 或 ``` 分隔符包裹多行代码，直接换行无需转义，支持保留缩进。
3. 方法论创建（如果需要创建新方法论）:
{ot("TOOL_CALL")}
{{
  "want": "添加/更新xxxx的方法论",
  "name": "methodology",
  "arguments": {{
    "operation": "add/update",
    "problem_type": "方法论类型，不要过于细节，也不要过于泛化",
    "content": |||
方法论内容
可以包含多行内容
推荐使用 ||| 或 ``` 分隔符包裹多行字符串，直接换行无需转义，支持保留缩进
包含"双引号"和'单引号'都无需转义
    |||
  }}
}}
{ct("TOOL_CALL")}

注意：如果 content 参数包含多行内容，推荐使用 ||| 或 ``` 分隔符包裹，直接换行无需转义，支持保留缩进。
如果以上三种情况都不适用，则直接输出原因分析，不要使用工具调用格式。
</output_requirements>"""
    else:
        output_requirements = f"""<output_requirements>
根据分析结果，输出以下三种情况之一：
1. 如果现有工具/方法论可以解决，直接输出说明：
已有工具/方法论可以解决该问题，无需创建新内容。
可用的工具/方法论：[列出工具名称或方法论名称]
使用方法：[简要说明如何使用]
2. 工具创建（如果需要创建新工具）:
注意：当前环境不支持 generate_new_tool 工具。如果需要创建新工具，请提供完整的工具代码和说明，用户需要手动创建工具文件。
3. 方法论创建（如果需要创建新方法论）:
{ot("TOOL_CALL")}
{{
  "want": "添加/更新xxxx的方法论",
  "name": "methodology",
  "arguments": {{
    "operation": "add/update",
    "problem_type": "方法论类型，不要过于细节，也不要过于泛化",
    "content": |||
方法论内容
可以包含多行内容
推荐使用 ||| 或 ``` 分隔符包裹多行字符串，直接换行无需转义，支持保留缩进
包含"双引号"和'单引号'都无需转义
    |||
  }}
}}
{ct("TOOL_CALL")}

注意：如果 content 参数包含多行内容，推荐使用 ||| 或 ``` 分隔符包裹，直接换行无需转义，支持保留缩进。
如果以上三种情况都不适用，则直接输出原因分析，不要使用工具调用格式。
</output_requirements>"""

    return f"""<task_analysis>
<request>
当前任务已结束，请按以下步骤分析该任务：

{memory_step}

{solution_step}

请根据分析结果采取相应行动。

重要提示：每次只能执行一个操作！
- 如果有记忆需要保存，可以调用一次 save_memory 批量保存多条记忆
- 保存完所有记忆后，再进行工具/方法论的创建或说明
- 不要在一次响应中同时调用多个工具（如同时保存记忆和创建工具/方法论）
</request>
<evaluation_criteria>
现有资源评估: 检查现有工具/方法论/组合使用是否可解决问题
工具评估: 通用性、自动化、可靠性、简单性
方法论评估: 聚焦通用可重复流程，纳入用户反馈，面向未来复用
</evaluation_criteria>
<tool_requirements>
工具代码要求:
1. 工具类名与工具名称一致，包含name、description、parameters属性，实现execute方法
2. 参数定义遵循JSON Schema，工具调用使用Jsonnet格式（支持 ||| 或 ``` 分隔符多行字符串、尾随逗号）
3. 使用print显示执行过程，返回{{success, stdout, stderr}}结构化结果
4. 妥善处理异常，失败时清理资源。如需调用大模型，创建独立实例避免干扰主流程
</tool_requirements>
<methodology_requirements>
方法论格式: 问题重述、可复用解决流程（步骤化+工具）、注意事项、可选步骤
</methodology_requirements>
{output_requirements}
</task_analysis>"""


# 为了向后兼容，保留原来的常量（使用默认参数，假设有 save_memory 工具）
TASK_ANALYSIS_PROMPT = get_task_analysis_prompt(has_save_memory=True)
