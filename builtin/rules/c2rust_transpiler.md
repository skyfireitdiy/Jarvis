# C2Rust 转译规则

## 规则简介

用于指导 C/C++ 到 Rust 的代码转译过程，确保转译质量、功能一致性和类型安全。本规则涵盖从规划、实现、构建、审查到优化的完整转译流程。

⚠️ **重要提醒**：c2rust 是一项非常复杂的任务，必须保证每个指定接口的功能一致性，任何疏忽都可能导致严重的功能错误。

## 你必须遵守的原则

### 1. 任务管理原则（核心）

**要求说明：**

- **必须**：每个函数的转译过程都必须使用 `task_list_manager` 进行任务管理
- **必须**：在开始转译前创建任务列表，规划所有任务（规划、实现、构建、审查、优化）
- **必须**：使用 task_list_manager 的 `add_tasks` 操作添加所有子任务
- **必须**：按照依赖关系设置任务依赖（如：实现阶段依赖规划阶段）
- **禁止**：跳过 task_list_manager，直接执行任务

**任务列表要求：**

- 任务类型：复杂任务使用 `sub` 类型，简单任务使用 `main` 类型
- 任务描述：每个任务必须包含约束条件、必须要求、禁止事项、验证标准
- 预期输出：必须使用结构化格式列出预期输出
- 验证方法：任务完成后必须提供验证方法说明

**示例：**

```json
// ✅ 正确：使用 task_list_manager
{
  "action": "add_tasks",
  "main_goal": "转译函数 foo",
  "background": "C 函数 foo 位于 path/to/foo.c，功能是...",
  "tasks_info": [
    {
      "task_name": "规划阶段",
      "task_desc": "为函数 foo 选择模块位置和设计 Rust 签名...",
      "expected_output": "- 模块路径：src/foo.rs\n- Rust 签名：pub fn foo(...) ...",
      "agent_type": "sub",
      "dependencies": []
    },
    {
      "task_name": "实现阶段",
      "task_desc": "使用 TDD 方法实现函数 foo...",
      "expected_output": "- 测试用例已编写\n- 实现已完成",
      "agent_type": "sub",
      "dependencies": ["规划阶段"]
    }
  ]
}
```

```bash
# ❌ 错误：直接执行，未使用 task_list_manager
echo "开始转译函数 foo"
# 直接编写代码，没有任务管理
```

### 2. TDD 开发原则

**要求说明：**

- **必须**：先写测试（#[cfg(test)] mod tests），基于 C 函数行为设计测试用例
- **必须**：编写实现使测试通过，确保与 C 语义等价
- **必须**：优化代码，保持测试通过（重构阶段）
- **禁止**：在没有测试的情况下直接编写实现代码
- **禁止**：使用 `todo!` 或 `unimplemented!` 作为占位符

**示例：**

```rust
// ❌ 错误：先写实现
pub fn calculate(x: i32) -> i32 {
    x * 2
}

#[cfg(test)]
mod tests {
    #[test]
    fn test_calculate() { }
}
```

```rust
// ✅ 正确：先写测试
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_calculate_normal() {
        assert_eq!(calculate(5), 10);
    }

    #[test]
    fn test_calculate_zero() {
        assert_eq!(calculate(0), 0);
    }
}

pub fn calculate(x: i32) -> i32 {
    x * 2
}
```

### 3. 功能一致性原则

**要求说明：**

- **必须**：核心功能定义与 C 实现一致（主要目的和预期行为）
- **允许**：安全改进导致的行为不一致（修复缓冲区溢出、空指针解引用等安全漏洞）
- **忽略**：语言差异导致的行为不一致（整数溢出处理、未定义行为处理等）
- **允许**：使用不同的类型设计、错误处理方式、资源管理方式
- **禁止**：改变核心功能逻辑

**说明：** 核心功能指函数的主要目的（如"计算哈希值"、"解析字符串"），不包括实现细节。

### 4. 模块化设计原则

**要求说明：**

- **必须**：按功能内聚与依赖方向选择模块，避免循环依赖
- **必须**：模块路径必须位于 crate 的 src/ 目录下
- **必须**：优先将函数放置到已存在的模块中
- **允许**：必要时创建新的子模块文件
- **禁止**：将不相关的功能放在同一模块

### 5. 类型安全原则

**要求说明：**

- **必须**：优先使用 Rust 原生类型（i32/u32、&str/String、&[T]/&mut [T]、Result<T,E>）
- **禁止**：优先使用 C 风格类型（core::ffi::c*\*、libc::c*\*）
- **禁止**：使用 extern "C"（除非是 FFI 导出要求）
- **必须**：函数签名应遵循 Rust 最佳实践，不需要兼容 C 的数据类型
- **禁止**：使用 `use ...::*` 通配导入

## 你必须执行的操作

### 阶段 1：规划阶段

#### 操作1：选择模块位置

- 分析函数的功能特性，确定所属的功能模块
- 检查 crate 目录结构，选择或创建合适的模块文件
- 确保模块路径位于 src/ 目录下
- 评估是否需要创建新的子模块文件

#### 操作2：设计 Rust 函数签名

- 根据 C 函数签名设计 Rust 函数签名
- 优先使用 Rust 原生类型，避免 C 风格类型
- 考虑使用 `Result<T, E>` 或 `Option<T>` 处理错误
- 如果是根符号，必须使用 `pub` 关键字

#### 操作3：评估是否需要实现

以下情况可以跳过实现（设置 skip_implementation 为 true）：

- **已实现的函数**：函数已经在目标模块中实现，且功能与 C 实现一致
- **资源释放类函数**：如 fclose、free 等，通过 RAII 自动管理
- **已被库替代**：函数已被标准库或第三方 crate 替代，且功能完全一致
- **空实现或无意义函数**：C 函数是空实现、简单返回常量
- **内联函数或宏**：在 C 中是内联函数或宏

**重要**：跳过实现必须在 notes 字段中详细说明原因。

### 阶段 2：实现阶段

#### 操作1：编写测试用例

- 在 `#[cfg(test)] mod tests { ... }` 块中编写测试
- 测试用例必须覆盖：
  - 主要功能路径
  - 边界情况（空输入、极值、边界值）
  - 错误情况（如果 C 实现有错误处理）
- 测试用例的预期结果必须与 C 实现的行为一致
- 使用清晰的测试名称和适当的断言

#### 操作2：实现函数

- 使测试通过，实现与 C 语义等价的功能
- 使用 Rust 原生类型和惯用法
- 考虑使用 RAII 管理资源
- 添加中文注释说明逻辑

#### 操作3：重构代码

- 优化代码结构，保持测试通过
- 改进代码可读性和可维护性
- 确保不改变功能行为

### 阶段 3：构建阶段

#### 操作1：运行 cargo test

- 确保所有测试用例都能通过
- 修复编译错误和测试失败
- 如果修复过程中导致其他测试失败，必须一并修复

#### 操作2：修复构建问题

- 处理编译错误（类型不匹配、缺少依赖等）
- 处理测试失败（断言错误、panic 等）
- 最小化修改，避免无关重构
- 使用精确的 use 语句，禁止通配导入

### 阶段 4：审查阶段

**审查优先级：**

1. **测试破坏性检查**（最高优先级）
   - 检查 `#[test]` 标记是否丢失
   - 检查 `#[test]` 标记是否重复
   - 检查代码插入位置是否破坏测试结构
   - 验证测试仍然可以运行

2. **严重问题检查**
   - 空指针解引用风险
   - 越界访问问题
   - 会导致 panic 的严重错误

3. **测试用例完备性检查**
   - 是否有测试用例
   - 是否覆盖主要功能
   - 是否覆盖边界情况
   - 是否覆盖错误情况

4. **功能一致性检查**
   - 核心输入输出是否一致
   - 主要功能逻辑是否一致
   - 允许安全改进导致的行为不一致

5. **破坏性变更检测**
   - 检查模块导出变更
   - 检查类型定义变更
   - 允许签名不一致（只要功能实现）

6. **文件结构合理性检查**
   - 模块文件位置是否合理
   - 文件命名是否符合规范
   - 模块导出是否正确

**操作：** 根据审查结果，提供详细的问题描述、修复建议和修复代码示例。

### 阶段 5：优化阶段

#### 操作1：修复审查发现的问题

- 按优先级修复问题（严重问题 > 功能一致性问题 > 其他问题）
- 最小化修改，避免无关重构
- 修复后必须重新运行 cargo test 验证

#### 操作2：验证所有测试通过

- 确保当前函数的测试通过
- 确保其他函数的测试没有因修改而失败
- 如果引入回归问题，必须一并修复

## 检查清单

### 任务管理检查清单

- [ ] 已使用 task_list_manager 创建任务列表
- [ ] 任务列表包含所有阶段（规划、实现、构建、审查、优化）
- [ ] 任务类型正确（sub/main）
- [ ] 任务描述完整（包含约束条件、必须要求、禁止事项、验证标准）
- [ ] 预期输出结构化（使用分条列出格式）
- [ ] 任务依赖关系正确设置
- [ ] 已验证任务列表创建成功

### 规划阶段检查清单

- [ ] 已选择合适的模块位置
- [ ] 已设计符合 Rust 最佳实践的函数签名
- [ ] 已评估是否需要实现（如跳过，已详细说明原因）
- [ ] 如果是根符号，签名包含 `pub` 关键字

### 实现阶段检查清单

- [ ] 已先编写测试用例
- [ ] 测试用例覆盖主要功能、边界情况、错误情况
- [ ] 已实现函数使测试通过
- [ ] 未使用 `todo!` 或 `unimplemented!` 占位符
- [ ] 使用 Rust 原生类型和惯用法
- [ ] 注释使用中文
- [ ] 未使用 `use ...::*` 通配导入

### 构建阶段检查清单

- [ ] 所有测试用例通过
- [ ] 无编译错误
- [ ] 修复过程未破坏其他测试
- [ ] 修改最小化，无无关重构

### 审查阶段检查清单

- [ ] 测试用例未被破坏（#[test] 标记完整）
- [ ] 无严重问题（空指针、越界等）
- [ ] 测试用例完备（覆盖主要功能、边界、错误）
- [ ] 核心功能与 C 实现一致
- [ ] 文件结构合理
- [ ] 问题报告包含详细描述、修复建议和修复代码示例

### 优化阶段检查清单

- [ ] 已按优先级修复所有问题
- [ ] 修复后所有测试通过
- [ ] 未引入回归问题
- [ ] 修改最小化

### 根符号特殊要求

如果函数是根符号（需要从 crate 外部访问）：

- [ ] 函数签名包含 `pub` 关键字
- [ ] 函数所在的模块已在 `src/lib.rs` 中导出（`pub mod <模块名>;`）
- [ ] 如果需要 FFI 导出，使用了 `#[no_mangle]` 和 `pub extern "C"`

## 相关资源

- 参考 TDD 规则：{{ rule_file_dir }}/tdd.md
- 参考代码审查规则：{{ rule_file_dir }}/code_review.md
- 参考 Rust 性能优化：{{ rule_file_dir }}/rust_performance.md
