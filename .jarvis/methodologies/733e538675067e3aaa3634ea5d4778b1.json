{
  "problem_type": "Python代码依赖分析实施",
  "content": "# Python代码依赖分析实施方法论\n\n## 规则简介\n\n本方法论提供Python代码依赖关系分析的完整实施指南，包括循环依赖检测、耦合度计算和依赖层级分析。适用于架构分析工具开发、代码健康度检查等场景。\n\n## 你必须遵守的原则\n\n### 原则1：准确性优先\n\n**要求说明：**\n\n- **必须**：使用AST模块解析Python代码，而非正则表达式\n- **必须**：正确处理相对导入（from . import x）和绝对导入\n- **必须**：区分项目内依赖和外部依赖\n- **禁止**：跳过系统库和第三方库的分析（除非明确要求）\n\n### 原则2：算法可靠性\n\n**要求说明：**\n\n- **必须**：循环依赖检测使用DFS+递归栈算法，避免无限递归\n- **必须**：设置最大迭代次数，防止循环依赖导致的死循环\n- **必须**：处理边界情况（空模块、无依赖、孤立模块）\n- **禁止**：假设依赖图总是DAG（有向无环图）\n\n### 原则3：性能考虑\n\n**要求说明：**\n\n- **必须**：分两阶段构建依赖图（先收集模块，再分析依赖）\n- **必须**：使用字典/集合进行快速查找，O(1)时间复杂度\n- **建议**：对大型项目使用采样策略\n- **禁止**：在循环中进行重复的文件I/O操作\n\n## 你必须执行的操作\n\n### 阶段1：依赖图构建\n\n1. **步骤1：收集所有Python模块**\n   - 递归扫描目标目录\n   - 过滤__pycache__、.pytest_cache等\n   - 为每个模块创建DependencyNode\n\n2. **步骤2：解析import语句**\n   - 使用ast.parse()解析Python文件\n   - 遍历AST节点，提取Import和ImportFrom节点\n   - 标准化模块名（处理相对导入）\n\n3. **步骤3：构建依赖关系**\n   - 维护模块名到DependencyNode的映射\n   - 更新dependencies和dependents集合\n   - 区分项目内依赖和外部依赖\n\n### 阶段2：循环依赖检测\n\n1. **步骤1：实现DFS遍历**\n   - 维护visited集合记录已访问节点\n   - 维护recursion_stack记录当前递归路径\n   - 为每个节点分配发现时间（index）\n\n2. **步骤2：识别回边**\n   - 当遇到已访问且在递归栈中的节点时，检测到循环\n   - 记录完整循环路径\n   - 评估严重程度（循环长度、涉及模块数）\n\n3. **步骤3：生成循环报告**\n   - 收集所有循环依赖\n   - 格式化循环路径为可读字符串\n   - 按严重程度排序\n\n### 阶段3：耦合度计算\n\n1. **步骤1：计算基础指标**\n   - Afferent Coupling (Ca) = len(node.dependents)\n   - Efferent Coupling (Ce) = len(node.dependencies)\n\n2. **步骤2：计算不稳定性**\n   - I = Ce / (Ca + Ce)，当Ca+Ce=0时，I=0\n   - I范围[0,1]，越接近1越不稳定（高度依赖外部）\n\n3. **步骤3：计算统计值**\n   - 平均耦合度 = sum(Ce) / total_modules\n   - 最大耦合度 = max(Ce)\n   - 识别高耦合模块（Ce > 5）\n\n### 阶段4：依赖层级计算\n\n1. **步骤1：初始化层级**\n   - 所有模块初始层级为0\n   - 无依赖的模块（叶子节点）层级为1\n\n2. **步骤2：迭代传播**\n   - 重复迭代直到收敛或达到最大次数\n   - level = max(被依赖模块的层级) + 1\n   - 设置最大迭代次数（如100）防止死循环\n\n3. **步骤3：计算统计值**\n   - 最大依赖深度 = max(所有模块的层级)\n   - 平均层级 = sum(层级) / total_modules\n\n### 阶段5：评分与报告\n\n1. **步骤1：定义评分策略**\n   - 基础分100分\n   - 每个循环依赖扣10分\n   - 平均耦合度>3时，超出部分每单位扣5分\n\n2. **步骤2：确定状态**\n   - 有循环依赖 → fail\n   - 平均耦合度>3 → warning\n   - 其他 → pass\n\n3. **步骤3：生成建议**\n   - 列出循环依赖路径\n   - 标识高耦合模块\n   - 提供重构建议\n\n## 实践指导\n\n### 数据结构设计\n\n```python\n@dataclass\nclass DependencyNode:\n    module_name: str  # 模块名（点分格式）\n    file_path: Path   # 文件路径\n    dependencies: set[str]  # 依赖的模块集合\n    dependents: set[str]    # 被依赖的模块集合\n    level: int = 0          # 依赖层级\n\n@dataclass\nclass CircularDependency:\n    cycle: list[str]  # 循环路径\n    severity: str     # 严重程度：low/medium/high\n```\n\n### AST解析技巧\n\n- 使用`ast.walk()`遍历所有节点\n- 区分`ast.Import`和`ast.ImportFrom`\n- 处理`ImportFrom.module=None`的情况（from . import x）\n- 记录行号便于定位问题\n\n### 性能优化\n\n- 使用`functools.lru_cache`缓存解析结果\n- 并行处理多个文件（需注意GIL）\n- 增量更新：只重新分析变更的文件\n\n## 检查清单\n\n- [ ] 能正确识别循环依赖（包括自依赖）\n- [ ] 耦合度计算准确（Ca、Ce、I）\n- [ ] 依赖层级合理（无循环时单调递增）\n- [ ] 处理相对导入正确\n- [ ] 测试覆盖率≥80%\n- [ ] 性能可接受（<5秒/1000文件）\n- [ ] 边界情况处理（空项目、单文件等）",
  "scope": "project"
}