{
  "id": "20250911_084804_275436",
  "type": "project_long_term",
  "tags": [
    "jarvis_agent",
    "architecture",
    "code_structure",
    "call_flow",
    "events",
    "prompt_manager",
    "run_loop",
    "tool_registry"
  ],
  "content": "概览\n- 入口与CLI:\n  - src/jarvis/jarvis_agent/jarvis.py: 高级CLI入口（jarvis）与选项处理（内置配置选择、Git仓库检测并可切到jca、交互式配置等），最终创建 AgentManager 并运行\n  - src/jarvis/jarvis_agent/main.py: 简化版CLI（jarvis-agent），直接加载配置并创建 Agent\n  - AgentManager: 封装 Agent 的初始化与任务运行（可传入 model_group/tool_group/restore_session/use_methodology/use_analysis）\n- Agent核心:\n  - src/jarvis/jarvis_agent/__init__.py: 定义 Agent 与系统原始提示 origin_agent_system_prompt\n  - 关键组成: SessionManager, PromptManager, EventBus, MemoryManager, TaskAnalyzer, FileMethodologyManager, ToolRegistry(OutputHandler), UserInteractionHandler\n  - 运行循环委派到 AgentRunLoop（run_loop.py）\n- 运行循环:\n  - AgentRunLoop.run: while True 主循环\n    1) 首次初始化 _first_run（工具筛选、记忆标签提示、文件/方法论处理）\n    2) _call_model: 输入处理链 -> 附加提示 -> 历史长度管理（必要时摘要/文件上传）-> 调用模型（事件 BEFORE/AFTER_MODEL_CALL）\n    3) 中断处理 _handle_run_interrupt（可跳过本轮或立即完成）\n    4) 工具调用：事件 BEFORE_TOOL_CALL -> _call_tools -> 拼接 tool_prompt -> after_tool_call_cb -> 事件 AFTER_TOOL_CALL\n    5) 若仍有 prompt 或 addon_prompt 继续循环\n    6) 自动完成标记检测（ot('!!!COMPLETE!!!')）则 _complete_task\n    7) 请求下一步用户动作（继续/完成）\n- 输入输出与工具:\n  - OutputHandlerProtocol/OutputHandler 抽象接口\n  - ToolRegistry 实现 OutputHandler，用于解析并执行工具（注册的工具包括 execute_script/save_memory/retrieve_memory/ask_user 等）\n  - execute_tool_call: 在 Agent._call_tools 中被调用；按 can_handle 选择唯一工具并执行，可选用户确认\n  - 输入处理器:\n    - shell_input_handler: 解析以!开头的脚本，调用 execute_script 工具执行并可选择反馈结果\n    - builtin_input_handler: 处理 '<Summary>/<Clear>/<ToolUsage>/<ReloadConfig>/<SaveSession>' 等特殊标记\n- 会话与提示:\n  - SessionManager: 维护 prompt/addon_prompt/conversation_length，支持 save/restore/clear_history\n  - PromptManager: 构建系统提示与默认附加提示（集成工具列表+记忆工具说明）\n  - prompt_builder.build_action_prompt: 将各 OutputHandler 的 prompt 合成为 actions 块\n  - Agent._setup_system_prompt: 首选使用 PromptManager，否则回退到原逻辑\n  - utils.join_prompts: 统一拼接策略（仅拼接非空段落，双换行）\n- 事件总线:\n  - EventBus: 简单同步发布/订阅，回调异常隔离\n  - events.py: 定义事件常量与负载类型提示\n  - 广播点:\n    - BEFORE/AFTER_MODEL_CALL, BEFORE/AFTER_TOOL_CALL\n    - BEFORE/AFTER_ADDON_PROMPT\n    - BEFORE/AFTER_HISTORY_CLEAR\n    - TASK_STARTED/TASK_COMPLETED\n    - BEFORE_TOOL_FILTER/TOOL_FILTERED\n    - INTERRUPT_TRIGGERED\n- 记忆与分析:\n  - MemoryManager: 订阅 TASK_STARTED/BEFORE_HISTORY_CLEAR/TASK_COMPLETED；支持强制保存记忆 force_save_memory，提供记忆标签提示与在附加提示中注入 save/retrieve 提示；自动判断并调用 save_memory 工具\n  - TaskAnalyzer: 订阅 BEFORE_SUMMARY/TASK_COMPLETED；在需要时执行分析循环（TASK_ANALYSIS_PROMPT），可在分析中继续触发工具调用；收集满意度反馈\n  - _check_and_organize_memory: 每日检查全局/项目记忆是否需要整理\n- 文件与方法论:\n  - FileMethodologyManager: 首轮与历史清理时处理文件上传/本地方法论加载；支持模型文件上传路径和本地加载路径\n- 任务与预定义:\n  - TaskManager: 从数据目录和当前项目 .jarvis/pre-command 读取预定义任务，fzf/手动选择并可追加补充信息\n- 其他:\n  - config.AgentConfig: 聚合 Agent 初始化配置并解析默认值（use_methodology/use_analysis/execute_tool_confirm/summary_prompt/max_token_count/force_save_memory）\n  - user_interaction: 封装多行输入与确认，便于未来替换 UI\n  - edit_file_handler: PATCH 工具的解析与快速编辑实现（独立 OutputHandler，可作为 ToolRegistry 的工具之一）\n  - share_manager/methodology_share_manager/tool_share_manager: 将本地方法论/工具分享至中心仓库的流程\n  - jarvis.py 还包含内置配置选择器与根据 Git 仓库自动建议切换到 jca 的逻辑\n\n关键调用链\n- CLI -> AgentManager.initialize -> Agent(...) 构造:\n  - _init_model -> _init_session -> _init_handlers(output/input/multiline) -> user_interaction 封装 -> _init_config -> 事件总线 -> 记忆/分析/文件方法论/提示管理器 -> _setup_system_prompt -> show_agent_startup_stats\n- Agent.run(user_input):\n  - 设置 session.prompt -> set_agent -> 事件 TASK_STARTED -> _main_loop -> AgentRunLoop.run 循环\n- AgentRunLoop.run:\n  - 首次 _first_run: 工具筛选(_filter_tools_if_needed)->记忆标签->文件/方法论处理\n  - _call_model: 输入处理链(builtin/shell) -> addon_prompt -> 长度控制(超限则 _summarize_and_clear_history 或 file upload) -> _invoke_model(事件 before/after)\n  - 中断处理 _handle_run_interrupt: 可能返回 LoopAction.SKIP_TURN 或最终结果\n  - 工具调用: 事件 BEFORE_TOOL_CALL -> _call_tools(execute_tool_call) -> 拼接 tool_prompt -> 回调 after_tool_call_cb -> 事件 AFTER_TOOL_CALL\n  - 若仍有 session.prompt/addon_prompt -> continue\n  - 自动完成 -> _complete_task（事件 BEFORE/AFTER_SUMMARY，最终 TASK_COMPLETED；期间可能触发 TaskAnalyzer/MemoryManager 事件逻辑）\n  - 请求下一步用户动作 -> continue/complete\n\n扩展点与可插拔性\n- OutputHandlerProtocol/ToolRegistry：新增工具即插即用\n- 输入处理器链：可追加 shell/builtin 之外的处理器\n- 事件总线：旁路集成统计/观测/插件逻辑，异常隔离\n- PromptManager：集中管理提示构建\n- Config(AgentConfig)：集中默认值解析\n- after_tool_call_cb：工具调用后回调钩子\n- 工具自动筛选：当工具过多时，借助临时模型筛选并重设系统提示\n\n重要状态与标志\n- Agent.first, run_input_handlers_next_turn, session.prompt/addon_prompt, conversation_length\n- 配置开关：use_methodology/use_analysis/execute_tool_confirm/need_summary/auto_complete/force_save_memory\n- 记忆标记：__memory_save_prompted__/__task_analysis_done__/__last_executed_tool__/__executed_tools__\n\n依赖\n- jarvis_utils: output/input/config/tag/embedding/methodology/globals/fzf/utils 等\n- jarvis_platform: BasePlatform/PlatformRegistry（模型实例、chat/save/restore/reset/upload_files 等）\n- jarvis_tools: ToolRegistry（工具注册与执行）\n- rich/prompt_toolkit/typer/yaml 等第三方库\n",
  "created_at": "2025-09-11T08:48:04.275469",
  "updated_at": "2025-09-11T08:48:04.275474"
}