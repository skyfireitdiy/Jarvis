{
  "id": "20260214_220929_805619",
  "type": "project_long_term",
  "tags": [
    "Bug修复",
    "playwright_browser",
    "事件循环",
    "prompt_toolkit"
  ],
  "content": "## playwright_browser工具事件循环冲突修复（最终方案）\n\n### Bug描述\n- **错误现象**：RuntimeError: asyncio.run() cannot be called from a running event loop\n- **错误位置**：prompt_toolkit 的 Application.run() 调用时\n\n### 根本原因分析\n1. **playwright_browser** 使用同步 API（playwright.sync_api），但内部通过 greenlet 实现同步等待\n2. greenlet 依赖 asyncio 事件循环来执行异步操作\n3. 当 prompt_toolkit 的 Application.run() 尝试创建新事件循环时，与 playwright 内部已有的事件循环冲突\n4. prompt_toolkit 检测到已有事件循环时，会尝试使用 asyncio.run()，但这在已有事件循环中是禁止的\n\n### 解决方案演进\n\n**方案1：nest_asyncio（已废弃）**\n- 方法：在 run_loop.py 中应用 nest_asyncio.apply()\n- 问题：虽然解决了启动时的冲突，但在 Ctrl+C 退出时，greenlet 的事件循环清理与 nest_asyncio 的嵌套事件循环产生冲突，导致严重的资源清理错误\n- 结论：不推荐使用 nest_asyncio，因为它引入了更多的问题\n\n**方案2：事件循环感知的 Application 调用（最终方案）**\n- 方法：在 input.py 的 get_choice 函数中检测是否有正在运行的事件循环\n- 如果有：使用 `loop.run_until_complete(app.run_async())`\n- 如果没有：使用常规的 `app.run()`\n- 优点：避免了事件循环冲突，不引入额外的依赖，资源清理正常\n\n### 实施修改\n**文件**：`src/jarvis/jarvis_utils/input.py`\n\n**修改1**：添加 asyncio 导入\n```python\nimport asyncio\n```\n\n**修改2**：修改 get_choice 函数中的 Application.run() 调用\n```python\ntry:\n    # 检测是否有正在运行的事件循环\n    try:\n        loop = asyncio.get_running_loop()\n        # 如果已有事件循环，使用 run_until_complete + run_async\n        result = loop.run_until_complete(app.run_async())\n    except RuntimeError:\n        # 没有运行中的事件循环，使用常规的 run()\n        result = app.run()\n    return result if result is not None else \"\"\nexcept (KeyboardInterrupt, EOFError):\n    return \"\"\n```\n\n### 验证结果\n- ✅ PlaywrightBrowserTool 导入成功\n- ✅ 浏览器启动成功\n- ✅ 浏览器关闭成功\n- ✅ 无事件循环冲突错误\n- ✅ Ctrl+C 退出时无资源清理错误\n\n### 技术要点\n1. **asyncio.get_running_loop()**：检测当前是否有正在运行的事件循环，如果没有会抛出 RuntimeError\n2. **loop.run_until_complete()**：在已有事件循环中运行协程，不需要创建新的事件循环\n3. **app.run_async()**：prompt_toolkit 提供的异步运行方法，返回一个协程\n4. **事件循环兼容性**：这个方案确保了 prompt_toolkit 和 playwright 的事件循环可以和谐共存\n\n### 影响范围\n- 修改文件：src/jarvis/jarvis_utils/input.py\n- 受影响功能：所有使用 get_choice 函数的地方（需要用户选择的交互）\n- 依赖变化：无新依赖\n\n### 注意事项\n1. 不要使用 nest_asyncio，因为它会引入更多的资源清理问题\n2. 事件循环感知的方案更加稳定和可靠\n3. 如果 playwright 不使用同步 API，这个问题可能不会出现\n\n### 相关错误信息\n原始错误：\n```\nRuntimeError: asyncio.run() cannot be called from a running event loop\n```\n\nnest_asyncio 的问题（Ctrl+C 退出时）：\n```\nRuntimeError: Event loop is closed\nTask was destroyed but it is pending!\nTask exception was never retrieved\n```",
  "created_at": "2026-02-14T22:09:29.805642",
  "updated_at": "2026-02-14T22:09:29.805645"
}