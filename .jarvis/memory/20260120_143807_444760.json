{
  "id": "20260120_143807_444760",
  "type": "project_long_term",
  "tags": [
    "上下文压缩",
    "token限制",
    "adaptive_compression",
    "sliding_window_compression",
    "importance_scoring_compression",
    "key_event_extraction_compression",
    "incremental_summarization_compression"
  ],
  "content": "在run_loop.py文件中，由于token原因触发的上下文压缩流程如下：\n\n1. **阈值设置**：在AgentRunLoop.__init__()中，设置`summary_remaining_token_threshold`为模型最大输入token的25%。\n\n2. **检测时机**：在AgentRunLoop.run()方法中，在调用模型前检查剩余token数量。\n\n3. **检测条件**：当`remaining_tokens > 0 and remaining_tokens < self.summary_remaining_token_threshold`时触发压缩逻辑。\n\n4. **压缩策略优先级**：\n   - 首先尝试自适应压缩(`_adaptive_compression`)：根据任务类型自动选择最适合的压缩策略\n   - 如果自适应压缩成功但token仍不足，依次尝试：滑动窗口压缩(`_sliding_window_compression`)、重要性评分压缩(`_importance_scoring_compression`)\n   - 如果自适应压缩失败，则按固定顺序尝试：滑动窗口压缩、重要性评分压缩、关键事件提取压缩(`_key_event_extraction_compression`)、增量摘要压缩(`_incremental_summarization_compression`)\n\n5. **压缩失败处理**：\n   - 如果所有压缩策略都失败，或者压缩后token仍然不足，代码注释表明\"继续执行后续的完整摘要逻辑\"\n   - 压缩过程中的异常会被捕获，不会影响主流程\n\n6. **后续处理**：\n   - 如果压缩后token仍然不足，可能会继续执行完整的摘要逻辑（通过`!!!SUMMARY!!!`标记或其他机制）\n   - 所有压缩算法会在每次尝试后重新获取剩余token数量以验证压缩效果\n\n这种多策略的压缩机制确保了在token不足时能够尝试多种方式来减少上下文大小，从而避免token耗尽导致的错误。",
  "created_at": "2026-01-20T14:38:07.444785",
  "updated_at": "2026-01-20T14:38:07.444789"
}