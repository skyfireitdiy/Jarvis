{
  "id": "20260214_221855_765710",
  "type": "project_long_term",
  "tags": [
    "Bug修复",
    "playwright_browser",
    "事件循环",
    "prompt_toolkit",
    "完整方案"
  ],
  "content": "## playwright_browser工具事件循环冲突修复（完整最终方案）\n\n### Bug描述\n- **错误现象**：\n  - RuntimeWarning: coroutine 'Application.run_async' was never awaited\n  - RuntimeError: asyncio.run() cannot be called from a running event loop\n- **错误位置**：\n  - src/jarvis/jarvis_agent/__init__.py:937 (get_choice)\n  - src/jarvis/jarvis_agent/run_loop.py:790 (multiline_input)\n\n### 根本原因分析\n1. **playwright_browser** 使用同步 API（playwright.sync_api），但内部通过 greenlet 实现同步等待\n2. greenlet 依赖 asyncio 事件循环来执行异步操作\n3. 当 prompt_toolkit 的 Application.run() 或 PromptSession.prompt() 尝试创建新事件循环时，与 playwright 内部已有的事件循环冲突\n4. prompt_toolkit 检测到已有事件循环时，会尝试使用 asyncio.run()，但这在已有事件循环中是禁止的\n\n### 解决方案演进\n\n**方案1：nest_asyncio（已废弃）**\n- 方法：在 run_loop.py 中应用 nest_asyncio.apply()\n- 问题：虽然解决了启动时的冲突，但在 Ctrl+C 退出时，greenlet 的事件循环清理与 nest_asyncio 的嵌套事件循环产生冲突，导致严重的资源清理错误\n- 结论：不推荐使用 nest_asyncio，因为它引入了更多的问题\n\n**方案2：事件循环感知的 Application 调用（最终方案）**\n- 方法：在所有 prompt_toolkit 调用处检测是否有正在运行的事件循环\n- 如果有：使用 `loop.run_until_complete(app.run_async())` 或 `loop.run_until_complete(session.prompt_async())`\n- 如果没有：使用常规的 `app.run()` 或 `session.prompt()`\n- 优点：避免了事件循环冲突，不引入额外的依赖，资源清理正常\n\n### 实施修改\n\n**文件**：`src/jarvis/jarvis_utils/input.py`\n\n**修改1**：添加 asyncio 导入\n```python\nimport asyncio\n```\n\n**修改2**：修改 get_choice 函数中的 Application.run() 调用\n```python\ntry:\n    # 检测是否有正在运行的事件循环\n    try:\n        loop = asyncio.get_running_loop()\n        # 如果已有事件循环，使用 run_until_complete + run_async\n        result = loop.run_until_complete(app.run_async())\n    except RuntimeError:\n        # 没有运行中的事件循环，使用常规的 run()\n        result = app.run()\n    return result if result is not None else \"\"\nexcept (KeyboardInterrupt, EOFError):\n    return \"\"\n```\n\n**修改3**：修改 _get_multiline_input_internal 函数中的 session.prompt() 调用\n```python\ntry:\n    # 检测是否有正在运行的事件循环\n    try:\n        loop = asyncio.get_running_loop()\n        # 如果已有事件循环，使用 run_until_complete + prompt_async\n        result = loop.run_until_complete(\n            session.prompt_async(\n                prompt,\n                style=style,\n                pre_run=_pre_run,\n                bottom_toolbar=_bottom_toolbar,\n                placeholder=FormattedText([(\"class:placeholder\", tip)]),\n                default=(preset or \"\"),\n            )\n        )\n    except RuntimeError:\n        # 没有运行中的事件循环，使用常规的 prompt()\n        result = session.prompt(\n            prompt,\n            style=style,\n            pre_run=_pre_run,\n            bottom_toolbar=_bottom_toolbar,\n            placeholder=FormattedText([(\"class:placeholder\", tip)]),\n            default=(preset or \"\"),\n        )\n    return str(result).strip() if result else \"\"\nexcept (KeyboardInterrupt, EOFError):\n    return \"\"\n```\n\n### 验证结果\n- ✅ PlaywrightBrowserTool 导入成功\n- ✅ 浏览器启动成功\n- ✅ 浏览器关闭成功\n- ✅ 无事件循环冲突错误\n- ✅ 无 RuntimeWarning\n- ✅ Ctrl+C 退出时无资源清理错误\n- ✅ 静态代码检查通过\n\n### 技术要点\n1. **asyncio.get_running_loop()**：检测当前是否有正在运行的事件循环，如果没有会抛出 RuntimeError\n2. **loop.run_until_complete()**：在已有事件循环中运行协程，不需要创建新的事件循环\n3. **app.run_async()**：prompt_toolkit 提供的异步运行方法，返回一个协程\n4. **session.prompt_async()**：PromptSession 的异步版本，返回一个协程\n5. **事件循环兼容性**：这个方案确保了 prompt_toolkit 和 playwright 的事件循环可以和谐共存\n\n### 影响范围\n- 修改文件：src/jarvis/jarvis_utils/input.py\n- 受影响功能：\n  - get_choice 函数（用于用户选择）\n  - get_multiline_input 函数（用于多行输入）\n  - _get_multiline_input_internal 函数（多行输入的内部实现）\n- 依赖变化：无新依赖\n\n### 关键改进点\n1. **修复了所有 prompt_toolkit 调用**：不仅修复了 Application.run()，还修复了 PromptSession.prompt()\n2. **完全事件循环感知**：在任何情况下都能正确处理事件循环\n3. **向后兼容**：没有运行中的事件循环时，使用原有逻辑，不影响其他功能\n\n### 注意事项\n1. 不要使用 nest_asyncio，因为它会引入更多的资源清理问题\n2. 事件循环感知的方案更加稳定和可靠\n3. 如果 playwright 不使用同步 API，这个问题可能不会出现\n4. 所有 prompt_toolkit 的同步调用都需要进行类似的事件循环感知处理\n\n### 相关错误信息\n原始错误：\n```\nRuntimeWarning: coroutine 'Application.run_async' was never awaited\nRuntimeError: asyncio.run() cannot be called from a running event loop\n```\n\nnest_asyncio 的问题（Ctrl+C 退出时）：\n```\nRuntimeError: Event loop is closed\nTask was destroyed but it is pending!\nTask exception was never retrieved\n```\n\n修复后：\n```\n✅ 所有测试通过！playwright_browser工具修复成功！\n```",
  "created_at": "2026-02-14T22:18:55.765731",
  "updated_at": "2026-02-14T22:18:55.765735"
}