{
  "content": "Jarvis C2Rust 渐进迁移系统：测试框架生成、转译子命令与完整实施架构\n\n【总体目标】\n在 Jarvis 项目中创建 jarvis_c2rust 命令行工具，驱动 C/C++ -> Rust 渐进迁移，具备自动修复、断点续跑和每步 Git 提交能力。\n\n【项目结构】\n- 位置：/home/skyfire/code/Jarvis/src/jarvis/jarvis_c2rust\n- 状态目录：.jarvis/c2rust/\n  * test.sh、test_rust.sh（测试脚本）\n  * progress.json、state.json（进度与状态管理）\n  * unit_queue.json（迁移单元队列）\n  * test_cases.json（测试用例收集）\n  * symbol_map.json（符号映射记录）\n\n【Step 1：测试框架生成完成】\n- CLI 命令：python -m jarvis.jarvis_c2rust.cli --root .\n- 功能目标：为 C/C++ 项目生成测试框架的 Agent，负责为已有的 C/C++ 代码创建测试框架\n- 最终在 .jarvis/c2rust/test.sh 生成可执行测试脚本，运行该脚本可执行当前 C 项目的所有测试\n- 优先适配通用构建/测试入口：make test/check, ctest, meson test 等；若不存在则提供可扩展的占位实现\n\n【检测结果】\n- build_system: unknown（未检测到CMake/Meson/Autotools/Make/Bazel）\n- tests_found: false（无显式测试，已搭建smoke test）\n\n【test.sh 逻辑设计】\n- 构建阶段：若无法识别构建系统则跳过，仅输出提示\n- 测试阶段：无显式测试时执行smoke检查（构建成功即通过）\n- 扩展性：为后续添加具体测试用例预留接口\n\n【完整实施步骤】\n1) 扫描当前项目构建与测试方式，生成 .jarvis/c2rust/test.sh（若无测试则搭建一个最小测试）\n2) 运行 test.sh；失败则启用修复 Agent 循环直至通过\n3) 创建 Rust 工程（目标为 C 静态库）；创建 Agent 修改 test.sh，将 Rust 静态库链接入项目\n4) 运行测试并失败自动修复直至通过\n5) 扫描 C/C++ 可迁移单元（函数/类等），写入 .jarvis/c2rust/unit_queue.json（包含位置、类型、签名等）\n6) 遍历 unit_queue.json，为每个单元创建 Agent，补充测试用例\n7) 运行测试并失败自动修复直至通过\n8) 创建 Agent，将已补测的单元迁移到 Rust 并删除 C/C++ 实现\n9) 运行测试并失败自动修复直至通过\n10) 创建 Agent，对已转换的 Rust 代码优化与去 unsafe，必要时同步更新测试\n11) 迭代直至所有单元迁移完成并移除 C/C++ 实现\n12) 收集所有 C/C++ 测试用例到 .jarvis/c2rust/test_cases.json\n13) 编写 .jarvis/c2rust/test_rust.sh 运行 Rust 侧测试\n14) 遍历每条用例：创建 Agent 将 C/C++ 用例迁移到 Rust 工程（保留原实现）\n15) 对每条用例运行 test_rust.sh，失败则自动修复直至通过\n16) 迭代至所有用例迁移完成并删除 C/C++ 实现\n17) 创建 Agent，遍历全仓文件进行整体优化\n18) 每一步修改都进行一次 Git 提交，信息格式：[JARVIS-C2RUST] <步骤描述>\n19) 每一步记录进度，支持异常中断后继续执行\n\n【转译子命令架构】\n- 位置与命名：在 src/jarvis/jarvis_c2rust 下新增模块 transpiler.py，在 cli.py 中新增子命令 transpile，与现有 scan/plan 并列\n\n【数据输入】\n- 依赖 scanner 产物：<root>/.jarvis/c2rust/functions.jsonl（含函数位置信息、调用关系、拓扑顺序）与 types.jsonl（如有）\n- 源码根目录：默认当前工作目录或从扫描记录推断\n\n【转译流程（按 scanner 生成的函数顺序）】\n1) 为每个待转函数创建一个 LLM Agent（模块选择与签名生成Agent）：\n   - 输入：原C函数源码片段（通过位置信息读取）、位置信息（文件、起止行列）、被调用函数清单（若已转：提供已转 Rust 模块/路径；未转：提供原C函数位置信息）\n   - 输入：当前 crate 目录结构（模块树、已存在mod.rs）\n   - 产出：建议落盘目标Rust模块路径、函数签名（summary中输出），并将当前函数进度写入进度JSON\n\n2) 生成实现：\n   - 创建 CodeAgent 作为执行体，上下文包含：目标模块、函数签名、C源码片段、依赖函数信息、crate结构、放置位置建议\n   - 让 CodeAgent 生成/更新对应Rust文件中的函数实现\n\n3) 构建与修复：\n   - 调用 cargo build（或项目构建命令）尝试编译\n   - 若失败：收集错误、相关上下文，创建 CodeAgent 进行修复，迭代直到构建通过（设定失败重试上限，避免死循环）\n\n4) 代码审查与优化：\n   - 创建审查Agent进行代码审查；若summary指出问题，则再次创建 CodeAgent 优化，直至通过\n\n5) 标记与映射：\n   - 将该函数标记为\"已转换\"，记录C符号到Rust符号/模块路径的映射到 symbol_map.json\n\n【CLI 参数建议】\n- --root 指定项目根；--llm-group 指定模型组；--resume 续跑；--max-retries 构建修复最大次数；--only 函数过滤；--dry-run 仅规划不落盘\n\n【断点续跑状态】\n- state_file: .jarvis/c2rust/state.json\n- 当前进度: initialized\n- 当前步骤索引: 0\n- 已提交步骤: []\n\n【设计原则】\n- 兼容性优先：优先适配主流构建系统（CMake/Meson/Autotools/Make/Bazel）\n- 渐进增强：从smoke test开始，逐步完善具体测试用例\n- 最小侵入：不修改现有构建配置，仅生成独立测试脚本\n- 可扩展性：为复杂测试场景预留扩展点\n- 自动化优先：最大化Agent驱动，最小人工干预\n- 可回退性：每步Git提交确保可追溯与可回退\n- 测试驱动：迁移前后必须通过测试验证\n\n【预期效果】\n- 为 C2Rust 转译前后的代码提供统一测试框架\n- 支持构建验证与基本功能检查\n- 为后续 Rust 代码测试迁移提供基线参考\n- 保障转译过程中功能等价性验证\n- 建立完整的 Agent 编排与记录体系支持全流程自动化\n- 提供断点续跑与状态管理能力\n- 实现 C/C++ 到 Rust 的安全、可控、可追溯的渐进迁移",
  "tags": [
    "jarvis_c2rust",
    "c2rust",
    "test_script",
    "agent",
    "cli",
    "step1",
    "progress",
    "build_integration",
    "smoke_test",
    "transpile",
    "migration_system",
    "automated_migration",
    "pipeline_architecture",
    "gradual_migration",
    "test_driven"
  ],
  "type": "project_long_term",
  "merged_from": [
    "merged_38cd2c91",
    "20251024_004920_607524",
    "20251019_205827_418204"
  ],
  "id": "merged_0325f149",
  "created_at": "2025-11-12T23:43:36.436538"
}
